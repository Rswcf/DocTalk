OpenAI Codex v0.46.0 (research preview)
--------
workdir: /Users/mayijie/Projects/Code/010_DocTalk
model: gpt-5
provider: openai
approval: never
sandbox: workspace-write [workdir, /tmp, $TMPDIR]
reasoning effort: high
reasoning summaries: auto
session id: 019c330b-ef9e-7302-9047-0aecf8108e56
--------
user
Phase 1+2: Database, Models, Config & Subscription Backend

## IMPORTANT: Read existing files first before making any changes\!

## Phase 1: DB + Models + Config

### A1. Database Migration
Create file: backend/alembic/versions/20260206_0004_add_subscription_fields.py

Follow the pattern of existing migrations (see backend/alembic/versions/20260205_0003_add_auth_credits_tables.py).
- revision = 'd4e5f6a7b8c9'
- down_revision = 'c3d4e5f6a7b8'

Add 4 columns to users table:
ALTER TABLE users ADD COLUMN plan VARCHAR(20) NOT NULL DEFAULT 'free';
ALTER TABLE users ADD COLUMN stripe_customer_id VARCHAR(255);
ALTER TABLE users ADD COLUMN stripe_subscription_id VARCHAR(255);
ALTER TABLE users ADD COLUMN monthly_credits_granted_at TIMESTAMPTZ;

Include proper downgrade (drop columns).

### A2. User Model
Edit: backend/app/models/tables.py

Add 4 fields to User class (after signup_bonus_granted_at, before created_at):
    plan: Mapped[str] = mapped_column(sa.String(20), nullable=False, server_default=sa.text("'free'"))
    stripe_customer_id: Mapped[Optional[str]] = mapped_column(sa.String(255))
    stripe_subscription_id: Mapped[Optional[str]] = mapped_column(sa.String(255))
    monthly_credits_granted_at: Mapped[Optional[datetime]] = mapped_column(sa.DateTime(timezone=True))

### A3. Config
Edit: backend/app/core/config.py

Add after SIGNUP_BONUS_CREDITS line:
    # Subscription tiers
    PLAN_FREE_MONTHLY_CREDITS: int = 10000
    PLAN_PRO_MONTHLY_CREDITS: int = 100000
    STRIPE_PRICE_PRO_MONTHLY: str = ''

## Phase 2: Subscription Backend

### B1. Monthly Credit Grant
Edit: backend/app/services/credit_service.py

Add function ensure_monthly_credits at the end of the file. It should:
- Accept (db: AsyncSession, user: User)
- Check if monthly_credits_granted_at is older than 30 days or None
- Determine allowance based on user.plan (pro=100K, free=10K) using settings
- Check CreditLedger for idempotency (no monthly_allowance within 30 days)
- Call credit_credits() if not granted yet
- Update user.monthly_credits_granted_at = now
- Import from datetime, timezone, timedelta as needed

### B2. Call ensure_monthly_credits in chat
Edit: backend/app/api/chat.py

In chat_stream endpoint, after verify_session_access and BEFORE the credit balance check, add:
    if user is not None:
        from app.services.credit_service import ensure_monthly_credits
        await ensure_monthly_credits(db, user)
        await db.commit()

### B3. Add subscribe and portal endpoints
Edit: backend/app/api/billing.py

Add these endpoints BEFORE the webhook handler:

POST /subscribe - Stripe Checkout subscription mode:
  - require_auth dependency
  - If user has no stripe_customer_id, create a Stripe Customer and save it
  - Create checkout session with mode='subscription', price=settings.STRIPE_PRICE_PRO_MONTHLY
  - success_url and cancel_url pointing to FRONTEND_URL/billing
  - Return checkout_url

POST /portal - Stripe Customer Portal:
  - require_auth dependency  
  - If no stripe_customer_id, return 400
  - Create billing portal session
  - Return portal_url

### B4. Extend Webhook
Edit: backend/app/api/billing.py

Extend webhook to handle:
1. checkout.session.completed: check mode. If mode=='subscription', set user.plan='pro', store stripe_subscription_id from subscription field, grant 100K credits. If mode=='payment', keep existing logic.
2. invoice.payment_succeeded: for subscription renewals, grant 100K credits with invoice.id as ref_id for idempotency
3. customer.subscription.deleted: set user.plan='free', clear stripe_subscription_id

### B5. Auth service update
Edit: backend/app/services/auth_service.py

In create_user(), add monthly_credits_granted_at=datetime.utcnow() to the User constructor alongside signup_bonus_granted_at.

## RULES:
- Read ALL files before editing
- Only modify specific parts mentioned
- Keep existing code intact
- Same code style as existing code
- Do NOT modify frontend files
- Do NOT touch main.py

thinking
**Preparing for repo changes**

I see that I need to make changes to a repository located in /Users/mayijie/Projects/Code/010_DocTalk. First, I’ll read through the files to understand what we're working with. I'll use the shell to explore the contents. It's important to follow AGENTS spec by logging preamble messages that summarize our next steps. For searching files, I’m planning to use `rg`. Let’s get started!
codex
I’m going to scan the backend codebase and open the relevant files (migrations, models, config, services, API routes) to mirror patterns before making focused edits.
exec
bash -lc 'ls -la' in /Users/mayijie/Projects/Code/010_DocTalk succeeded in 9ms:
total 96
drwxr-xr-x  15 mayijie  staff    480 Feb  6 13:10 .
drwxr-xr-x@ 14 mayijie  staff    448 Feb  4 18:58 ..
drwxr-xr-x@  3 mayijie  staff     96 Feb  6 14:01 .claude
drwxr-xr-x@  8 mayijie  staff    256 Feb  5 00:23 .collab
-rw-r--r--@  1 mayijie  staff    129 Feb  4 23:10 .dockerignore
-rw-r--r--@  1 mayijie  staff   1200 Feb  6 00:27 .env
-rw-r--r--@  1 mayijie  staff   1159 Feb  5 20:30 .env.example
drwxr-xr-x@ 12 mayijie  staff    384 Feb  6 14:01 .git
-rw-r--r--@  1 mayijie  staff    309 Feb  4 22:24 .gitignore
-rw-r--r--@  1 mayijie  staff  14095 Feb  6 13:10 CLAUDE.md
-rw-r--r--@  1 mayijie  staff   8524 Feb  6 09:18 README.md
drwxr-xr-x@ 10 mayijie  staff    320 Feb  6 11:46 backend
-rw-r--r--@  1 mayijie  staff    978 Feb  4 19:38 docker-compose.yml
drwxr-xr-x@ 19 mayijie  staff    608 Feb  6 00:21 frontend
drwxr-xr-x@  4 mayijie  staff    128 Feb  4 23:32 infra
exec
bash -lc 'ls -la backend && rg --files backend | wc -l && rg -n "alembic|models|credit_service|chat|billing|auth_service|config.py|tables.py" -n backend -S' in /Users/mayijie/Projects/Code/010_DocTalk succeeded in 38ms:
total 40
drwxr-xr-x@ 10 mayijie  staff  320 Feb  6 11:46 .
drwxr-xr-x  15 mayijie  staff  480 Feb  6 13:10 ..
-rw-r--r--@  1 mayijie  staff   43 Feb  4 22:49 .dockerignore
-rw-r--r--@  1 mayijie  staff  926 Feb  6 11:46 Dockerfile
drwxr-xr-x@  5 mayijie  staff  160 Feb  4 19:42 alembic
-rw-r--r--@  1 mayijie  staff  522 Feb  4 19:42 alembic.ini
drwxr-xr-x@ 10 mayijie  staff  320 Feb  6 11:57 app
-rw-r--r--@  1 mayijie  staff  162 Feb  4 23:02 railway.toml
-rw-r--r--@  1 mayijie  staff  189 Feb  5 20:20 requirements.txt
drwxr-xr-x@  6 mayijie  staff  192 Feb  5 20:18 tests
      48
backend/alembic/versions/20260204_0001_initial_tables.py:10:from alembic import op
backend/alembic/versions/20260204_0001_initial_tables.py:15:# revision identifiers, used by Alembic.
backend/alembic/versions/20260205_0002_add_session_title.py:10:from alembic import op
backend/alembic/versions/20260205_0002_add_session_title.py:13:# revision identifiers, used by Alembic.
backend/alembic/versions/20260205_0003_add_auth_credits_tables.py:10:from alembic import op
backend/alembic/versions/20260205_0003_add_auth_credits_tables.py:15:# revision identifiers, used by Alembic.
backend/alembic/env.py:11:from alembic import context
backend/alembic/env.py:13:# this is the Alembic Config object, which provides
exec
bash -lc "sed -n '1,200p' backend/alembic/versions/20260205_0003_add_auth_credits_tables.py" in /Users/mayijie/Projects/Code/010_DocTalk succeeded in 16ms:
"""add auth, credits, usage tables and alter documents

Revision ID: c3d4e5f6a7b8
Revises: b2c3d4e5f6a7
Create Date: 2026-02-05 00:30:00

"""
from __future__ import annotations

from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql


# revision identifiers, used by Alembic.
revision = "c3d4e5f6a7b8"
down_revision = "b2c3d4e5f6a7"
branch_labels = None
depends_on = None

exec
bash -lc "sed -n '1,220p' backend/app/models/tables.py" in /Users/mayijie/Projects/Code/010_DocTalk succeeded in 10ms:
from __future__ import annotations

import uuid
from datetime import datetime
from typing import List, Optional

import sqlalchemy as sa
from sqlalchemy.dialects.postgresql import JSONB, UUID
from sqlalchemy.orm import Mapped, mapped_column, relationship

from .base import Base


# Documents table
class Document(Base):
    __tablename__ = "documents"

    id: Mapped[uuid.UUID] = mapped_column(
        UUID(as_uuid=True),
        primary_key=True,
exec
bash -lc "sed -n '220,520p' backend/app/models/tables.py" in /Users/mayijie/Projects/Code/010_DocTalk succeeded in 14ms:
    balance_after: Mapped[int] = mapped_column(sa.Integer, nullable=False)
    reason: Mapped[str] = mapped_column(sa.String(50), nullable=False)
    ref_type: Mapped[Optional[str]] = mapped_column(sa.String(50))
    ref_id: Mapped[Optional[str]] = mapped_column(sa.String(255))
    created_at: Mapped[datetime] = mapped_column(sa.DateTime(timezone=True), server_default=sa.text("now()"))

    __table_args__ = (
        sa.Index("idx_credit_ledger_user_created", "user_id", "created_at"),
        sa.Index("idx_credit_ledger_ref", "ref_type", "ref_id"),
    )


class UsageRecord(Base):
    __tablename__ = "usage_records"

    id: Mapped[uuid.UUID] = mapped_column(
        UUID(as_uuid=True), primary_key=True, server_default=sa.text("gen_random_uuid()")
    )
    user_id: Mapped[uuid.UUID] = mapped_column(
        UUID(as_uuid=True), sa.ForeignKey("users.id", ondelete="CASCADE"), nullable=False

thinking
**Updating User Model**

I'm thinking we need to add a few attributes to the User model, specifically plan, stripe_customer_id, stripe_subscription_id, and monthly_credits_granted_at between signup_bonus_granted_at and created_at. It’s important that we also make sure to import typing Optional and datetime if they're not already included. Next step is to open up config.py to implement these changes. Alright, let's get this going!
exec
bash -lc "sed -n '1,240p' backend/app/core/config.py" in /Users/mayijie/Projects/Code/010_DocTalk succeeded in 17ms:
from __future__ import annotations

from typing import Optional

from pydantic import Field
from pydantic_settings import BaseSettings, SettingsConfigDict


class Settings(BaseSettings):
    # OpenRouter — 统一 API 网关
    OPENROUTER_API_KEY: Optional[str] = None
    OPENROUTER_BASE_URL: str = Field(default="https://openrouter.ai/api/v1")

    # Embedding — 模型与维度强绑定 (通过 OpenRouter 调用)
    EMBEDDING_MODEL: str = Field(default="openai/text-embedding-3-small")
    EMBEDDING_DIM: int = Field(default=1536)

    # Qdrant
    QDRANT_URL: str = Field(default="http://localhost:6333")
    QDRANT_API_KEY: Optional[str] = None

thinking
It looks like I need to add new subscription tier constants, including monthly credits and pricing through Stripe, right after the existing SIGNUP_BONUS_CREDITS. That's a clear step forward! Next, I'll open the credit_service.py file to make those adjustments. It's a straightforward process, and I want to ensure everything is set up correctly. Let’s see what else needs to be done in that file once I get it open!
exec
bash -lc "sed -n '1,260p' backend/app/services/credit_service.py" in /Users/mayijie/Projects/Code/010_DocTalk succeeded in 6ms:
from __future__ import annotations

from typing import Optional
from uuid import UUID

import sqlalchemy as sa
from sqlalchemy.ext.asyncio import AsyncSession

from app.models.tables import CreditLedger, UsageRecord, User


# Token-to-credit rates by model tier
CREDIT_RATES = {
    # Small tier: 3 input, 15 output per 1K tokens
    "anthropic/claude-sonnet-4.5": (3, 15),
    "openai/gpt-5.2": (3, 15),
    "google/gemini-3-pro-preview": (3, 15),
    "mistralai/mistral-large-2512": (3, 15),
    # Large tier: 15 input, 75 output per 1K tokens
    "anthropic/claude-opus-4.5": (15, 75),
exec
bash -lc "sed -n '1,260p' backend/app/api/chat.py" in /Users/mayijie/Projects/Code/010_DocTalk succeeded in 16ms:
from __future__ import annotations

import asyncio
import json
import uuid
from typing import AsyncGenerator, Dict, Optional

from fastapi import APIRouter, Depends, status
from fastapi.responses import JSONResponse, StreamingResponse
from sqlalchemy import asc, select, func, desc
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import selectinload

from app.core.deps import get_current_user_optional, get_db_session
from app.models.tables import ChatSession, Document, Message, User
from app.schemas.chat import (
    ChatMessageResponse,
    ChatRequest,
    SessionMessagesResponse,
    SessionResponse,

thinking
**Updating billing process**

I’m thinking we need to add the ensure_monthly_credits call right after verifying session access but before we do the credit check in chat_stream. That way, everything flows smoothly together. I’ll also need to open the billing API file to make sure I’m looking at the right details. This approach will help keep everything organized, and it
should make the billing process more efficient. Let’s get to it!
exec
bash -lc "sed -n '1,300p' backend/app/api/billing.py" in /Users/mayijie/Projects/Code/010_DocTalk succeeded in 17ms:
from __future__ import annotations

import logging
import uuid
from typing import Literal

import stripe
from fastapi import APIRouter, Depends, HTTPException, Request
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from app.core.config import settings
from app.core.deps import get_db_session, require_auth
from app.models.tables import CreditLedger, User
from app.services.credit_service import credit_credits

logger = logging.getLogger(__name__)

router = APIRouter(prefix="/api/billing", tags=["billing"])


thinking
**Planning webhook improvements**

I'm thinking we need to add two new endpoints specifically for subscription and portal features. It seems like extending the webhook to handle subscription events is essential. Right now, it only processes checkout.session.completed for one-time purchases. I’ll need to add some logic for both mode subscription and handle events like invoice.payment_succeeded and customer.subscription.deleted. Oh, and we should also consider opening the auth_service. Let's get started on these updates!
exec
bash -lc "sed -n '1,260p' backend/app/services/auth_service.py" in /Users/mayijie/Projects/Code/010_DocTalk succeeded in 16ms:
from __future__ import annotations

import hashlib
import logging
from datetime import datetime
from typing import Optional
from uuid import UUID

import sqlalchemy as sa
from sqlalchemy import select
from sqlalchemy.exc import IntegrityError
from sqlalchemy.ext.asyncio import AsyncSession

from app.models.tables import User, Account, VerificationToken, CreditLedger

logger = logging.getLogger(__name__)

SIGNUP_BONUS_CREDITS = 10000



thinking
**Updating user creation process**

I need to modify the `create_user` function to include `monthly_credits_granted_at=datetime.utcnow()`. Additionally, I have to make sure that the Stripe import is used properly, and the API key is set. Since it's already imported in `billing.py`, that’s good. I also need to create a new migration file with the correct revision ID. To ensure consistency, I’ll open the existing migration files, specifically `0001` and `0002`, to mimic their style.
exec
bash -lc "sed -n '1,240p' backend/alembic/versions/20260204_0001_initial_tables.py" in /Users/mayijie/Projects/Code/010_DocTalk succeeded in 15ms:
"""initial tables

Revision ID: a1b2c3d4e5f6
Revises: 
Create Date: 2026-02-04 00:00:00

"""
from __future__ import annotations

from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql


# revision identifiers, used by Alembic.
revision = "a1b2c3d4e5f6"
down_revision = None
branch_labels = None
depends_on = None

exec
bash -lc "sed -n '1,160p' backend/alembic/versions/20260205_0002_add_session_title.py" in /Users/mayijie/Projects/Code/010_DocTalk succeeded in 8ms:
"""add session title

Revision ID: b2c3d4e5f6a7
Revises: a1b2c3d4e5f6
Create Date: 2026-02-05 00:00:00

"""
from __future__ import annotations

from alembic import op
import sqlalchemy as sa

# revision identifiers, used by Alembic.
revision = "b2c3d4e5f6a7"
down_revision = "a1b2c3d4e5f6"
branch_labels = None
depends_on = None


def upgrade() -> None:





thinking
**Planning migration adjustments**

I need to set the `down_revision` to 'c3d4e5f6a7b8' for the new migration file. Next, I must modify `chat_stream` to call the `ensure_monthly_credits` function before checking the credit balance. This function will be implemented in `credit_service`, so I'll import necessary settings. I'll also review the existing import style for `credit_service`. Importing `datetime` and `timedelta/timezone` is on my list, along with checking for a ledger entry reason in alignment with the instructions. I'll update the billing endpoints too!
thinking
**Developing Stripe integration**

First, I need to check if the user has a `stripe_customer_id`. If not, I’ll create a new `stripe.Customer` using the user’s email and name, then save the resulting ID to `user.stripe_customer_id`. After that, I’ll create a `stripe.checkout.Session` with the necessary parameters, including the mode set to 'subscription' and line items based on monthly pricing. I’ll ensure Stripe's API key is set properly and handle any missing settings. Finally, I'll extend the webhook to manage various events like subscription completion and payment processing.
thinking
**Managing credits and subscriptions**

The user wants 100K credits monthly, so I plan to grant that immediately for the subscription start using a reason like "subscription_initial" or "monthly_allowance." To maintain idempotency, I’ll use `ref_type` as 'stripe_subscription' with the subscription ID to avoid double granting. I need to check the ledger for any monthly allowances within the last 30 days as well. For the subscription start, I’ll reference the checkout session and the subscription ID to ensure we meet the idempotency requirements. Lastly, I’ll set the user’s plan to 'pro' and store the `stripe_subscription_id`.
thinking
**Implementing invoice and subscription handling**

For the `invoice.payment_succeeded` event related to subscription renewals, I'll grant 100K credits using the `invoice.id` as the `ref_id` for idempotency. I also need to retrieve the customer ID from `invoice['customer']` to find the corresponding user through `stripe_customer_id`. While checking for the pro price is optional, it might be wise to confirm the `billing_reason` relates to the 'subscription_cycle'. For the `customer.subscription.deleted` event, I'll set the user’s plan to 'free' and clear the `stripe_subscription_id`. I'll ensure to add these event handlers in the webhook and adjust the configuration settings accordingly.
thinking
**Checking dependencies and user authentication**

I need to evaluate potential additional dependencies, specifically since I used `get_current_user_optional` earlier. It's important to note that `require_auth` is utilized for endpoints, which is good for protecting access. I also plan to open the `app/core/deps.py` file to confirm that `require_auth` returns a User object as expected. This ensures that I have the right configurations in place for managing user authentication and accessing necessary user data.
exec
bash -lc "sed -n '1,260p' backend/app/core/deps.py" in /Users/mayijie/Projects/Code/010_DocTalk succeeded in 14ms:
import logging
from typing import AsyncGenerator, Optional
from uuid import UUID

from fastapi import Depends, HTTPException, Request
from jose import JWTError, jwt
from jose.jwt import ExpiredSignatureError, JWTClaimsError
from sqlalchemy.ext.asyncio import AsyncSession

from app.core.config import settings
from app.models.database import AsyncSessionLocal
from app.models.tables import User

logger = logging.getLogger(__name__)


async def get_db_session() -> AsyncGenerator[AsyncSession, None]:
    """Provide an async SQLAlchemy session for FastAPI dependencies."""
    async with AsyncSessionLocal() as session:  # type: AsyncSession
        yield session





thinking
**Considering datetime with SQLAlchemy**

I'm working with `datetime.utcnow()`, which returns a naive datetime, but the column expects something with timezone awareness. SQLAlchemy can handle naive datetimes in a way that adjusts them. Since we won't programmatically set `created_at` often, using `utcnow()` is acceptable. However, I realize it might be better to use `datetime.now(timezone.utc)` for aware datetimes consistently. In my case, since the code uses naive by default, I should stick with `utcnow()`, especially when querying. But I need to be careful about comparisons since `created_at` on the ledger is timezone aware.
thinking
**Implementing ledger query**

I'm planning to implement a ledger query using SQLAlchemy. I’ll create a cutoff timestamp by calculating `func.now() - sa.text("interval '30 days'"` or using `func.now() - sa.cast`. Alternatively, I could compute it in Python using `datetime.utcnow() - timedelta(days=30)` for comparison with `created_at`. I need to be cautious about timezone mismatches since the column is timezone-aware. To keep things simple, I think I’ll check if a row exists with `created_at >= now - interval '30 days'` in the SQL query.
thinking
**Implementing the ledger check**

I’m setting up a check for existing credits in the ledger using a SQLAlchemy query. I’ll compare `CreditLedger.user_id` to `user.id`, check if the reason is 'monthly_allowance', and ensure that `created_at` is within the last 30 days. I'll use `sa.func.now()` with `sa.text("interval '30 days'")` to create a cutoff expression. 

Alternatively, I could compute the date in Python with `datetime.utcnow() - timedelta(days=30)` or even use a timezone-aware date calculation for better accuracy. This definitely keeps things safer when considering timezones!
thinking
**Clarifying datetime handling and updates**

Earlier, the code used naive datetimes, but I realize I should use timezone-aware datetimes here for consistency. I’ll import `datetime`, `timezone`, and `timedelta` as needed, and set `now = datetime.now(timezone.utc)`, which I’ll use for `user.monthly_credits_granted_at`. Although auth_service used naive datetimes, it's generally okay to mix them. 

Next, I need to add new fields to the `User` class in `tables.py`, specifically a 'plan' field with a default value of 'free', ensuring I follow the specified order. I'll also update the configuration settings to incorporate these changes and modify `chat.py` accordingly. Time to implement these patches!
thinking
**Verifying and implementing billing endpoints**

First, I need to confirm that the router path prefix in `backend/app/api/billing.py` is set to "/api/billing" and that it includes the router in the main file. Since we’re adding new subscription endpoints, they should appear before the webhook handler, as specified in the instructions. I’ll place them right after `create_checkout` for organization. 

Additionally, I must ensure that `stripe_customer_id` is stored in the `User` model, which means I need to add that field and handle the migration to update the database properly. Now, it’s time to implement these patches!
file update
A /Users/mayijie/Projects/Code/010_DocTalk/backend/alembic/versions/20260206_0004_add_subscription_fields.py
"""add subscription fields to users

Revision ID: d4e5f6a7b8c9
Revises: c3d4e5f6a7b8
Create Date: 2026-02-06 00:40:00

"""
from __future__ import annotations

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = "d4e5f6a7b8c9"
down_revision = "c3d4e5f6a7b8"
branch_labels = None
depends_on = None


def upgrade() -> None:
    # Add subscription-related columns to users
    op.add_column(
        "users",
        sa.Column("plan", sa.String(length=20), nullable=False, server_default=sa.text("'free'")),
    )
    op.add_column("users", sa.Column("stripe_customer_id", sa.String(length=255), nullable=True))
    op.add_column("users", sa.Column("stripe_subscription_id", sa.String(length=255), nullable=True))
    op.add_column("users", sa.Column("monthly_credits_granted_at", sa.DateTime(timezone=True), nullable=True))


def downgrade() -> None:
    # Drop subscription-related columns from users
    op.drop_column("users", "monthly_credits_granted_at")
    op.drop_column("users", "stripe_subscription_id")
    op.drop_column("users", "stripe_customer_id")
    op.drop_column("users", "plan")

apply_patch(auto_approved=true) exited 0 in 34ms:
Success. Updated the following files:
A backend/alembic/versions/20260206_0004_add_subscription_fields.py
file update:
diff --git a/backend/alembic/versions/20260206_0004_add_subscription_fields.py b/backend/alembic/versions/20260206_0004_add_subscription_fields.py
new file mode 100644
index 0000000000000000000000000000000000000000..f84be09226785ea3dbc1b413b3cfd2cb07dff81e
--- /dev/null
+++ b/backend/alembic/versions/20260206_0004_add_subscription_fields.py
@@ -0,0 +1,38 @@
+"""add subscription fields to users
+
+Revision ID: d4e5f6a7b8c9
+Revises: c3d4e5f6a7b8
+Create Date: 2026-02-06 00:40:00
+
+"""
+from __future__ import annotations
+
+from alembic import op
+import sqlalchemy as sa
+
+
+# revision identifiers, used by Alembic.
+revision = "d4e5f6a7b8c9"
+down_revision = "c3d4e5f6a7b8"
+branch_labels = None
+depends_on = None
+
+
+def upgrade() -> None:
+    # Add subscription-related columns to users
+    op.add_column(
+        "users",
+        sa.Column("plan", sa.String(length=20), nullable=False, server_default=sa.text("'free'")),
+    )
+    op.add_column("users", sa.Column("stripe_customer_id", sa.String(length=255), nullable=True))
+    op.add_column("users", sa.Column("stripe_subscription_id", sa.String(length=255), nullable=True))
+    op.add_column("users", sa.Column("monthly_credits_granted_at", sa.DateTime(timezone=True), nullable=True))
+
+
+def downgrade() -> None:
+    # Drop subscription-related columns from users
+    op.drop_column("users", "monthly_credits_granted_at")
+    op.drop_column("users", "stripe_subscription_id")
+    op.drop_column("users", "stripe_customer_id")
+    op.drop_column("users", "plan")
+

file update:
diff --git a/backend/alembic/versions/20260206_0004_add_subscription_fields.py b/backend/alembic/versions/20260206_0004_add_subscription_fields.py
new file mode 100644
index 0000000000000000000000000000000000000000..f84be09226785ea3dbc1b413b3cfd2cb07dff81e
--- /dev/null
+++ b/backend/alembic/versions/20260206_0004_add_subscription_fields.py
@@ -0,0 +1,38 @@
+"""add subscription fields to users
+
+Revision ID: d4e5f6a7b8c9
+Revises: c3d4e5f6a7b8
+Create Date: 2026-02-06 00:40:00
+
+"""
+from __future__ import annotations
+
+from alembic import op
+import sqlalchemy as sa
+
+
+# revision identifiers, used by Alembic.
+revision = "d4e5f6a7b8c9"
+down_revision = "c3d4e5f6a7b8"
+branch_labels = None
+depends_on = None
+
+
+def upgrade() -> None:
+    # Add subscription-related columns to users
+    op.add_column(
+        "users",
+        sa.Column("plan", sa.String(length=20), nullable=False, server_default=sa.text("'free'")),
+    )
+    op.add_column("users", sa.Column("stripe_customer_id", sa.String(length=255), nullable=True))
+    op.add_column("users", sa.Column("stripe_subscription_id", sa.String(length=255), nullable=True))
+    op.add_column("users", sa.Column("monthly_credits_granted_at", sa.DateTime(timezone=True), nullable=True))
+
+
+def downgrade() -> None:
+    # Drop subscription-related columns from users
+    op.drop_column("users", "monthly_credits_granted_at")
+    op.drop_column("users", "stripe_subscription_id")
+    op.drop_column("users", "stripe_customer_id")
+    op.drop_column("users", "plan")
+

file update
M /Users/mayijie/Projects/Code/010_DocTalk/backend/app/models/tables.py
@@ -165,2 +165,6 @@
     signup_bonus_granted_at: Mapped[Optional[datetime]] = mapped_column(sa.DateTime(timezone=True))
+    plan: Mapped[str] = mapped_column(sa.String(20), nullable=False, server_default=sa.text("'free'"))
+    stripe_customer_id: Mapped[Optional[str]] = mapped_column(sa.String(255))
+    stripe_subscription_id: Mapped[Optional[str]] = mapped_column(sa.String(255))
+    monthly_credits_granted_at: Mapped[Optional[datetime]] = mapped_column(sa.DateTime(timezone=True))
     created_at: Mapped[datetime] = mapped_column(sa.DateTime(timezone=True), server_default=sa.text("now()"))
apply_patch(auto_approved=true) exited 0 in 35ms:
Success. Updated the following files:
M backend/app/models/tables.py
file update:
diff --git a/backend/alembic/versions/20260206_0004_add_subscription_fields.py b/backend/alembic/versions/20260206_0004_add_subscription_fields.py
new file mode 100644
index 0000000000000000000000000000000000000000..f84be09226785ea3dbc1b413b3cfd2cb07dff81e
--- /dev/null
+++ b/backend/alembic/versions/20260206_0004_add_subscription_fields.py
@@ -0,0 +1,38 @@
+"""add subscription fields to users
+
+Revision ID: d4e5f6a7b8c9
+Revises: c3d4e5f6a7b8
+Create Date: 2026-02-06 00:40:00
+
+"""
+from __future__ import annotations
+
+from alembic import op
+import sqlalchemy as sa
+
+
+# revision identifiers, used by Alembic.
+revision = "d4e5f6a7b8c9"
+down_revision = "c3d4e5f6a7b8"
+branch_labels = None
+depends_on = None
+
+
+def upgrade() -> None:
+    # Add subscription-related columns to users
+    op.add_column(
+        "users",
+        sa.Column("plan", sa.String(length=20), nullable=False, server_default=sa.text("'free'")),
+    )
+    op.add_column("users", sa.Column("stripe_customer_id", sa.String(length=255), nullable=True))
+    op.add_column("users", sa.Column("stripe_subscription_id", sa.String(length=255), nullable=True))
+    op.add_column("users", sa.Column("monthly_credits_granted_at", sa.DateTime(timezone=True), nullable=True))
+
+
+def downgrade() -> None:
+    # Drop subscription-related columns from users
+    op.drop_column("users", "monthly_credits_granted_at")
+    op.drop_column("users", "stripe_subscription_id")
+    op.drop_column("users", "stripe_customer_id")
+    op.drop_column("users", "plan")
+
diff --git a/backend/app/models/tables.py b/backend/app/models/tables.py
index 2eb9239abb3f01f8a4103944db02efcb27f20149..9caeafd2d73fb05604695d962f9a0dc191da0bf2
--- a/backend/app/models/tables.py
+++ b/backend/app/models/tables.py
@@ -163,6 +163,10 @@
     email_verified: Mapped[Optional[datetime]] = mapped_column(sa.DateTime(timezone=True))
     credits_balance: Mapped[int] = mapped_column(sa.Integer, nullable=False, server_default=sa.text("0"))
     signup_bonus_granted_at: Mapped[Optional[datetime]] = mapped_column(sa.DateTime(timezone=True))
+    plan: Mapped[str] = mapped_column(sa.String(20), nullable=False, server_default=sa.text("'free'"))
+    stripe_customer_id: Mapped[Optional[str]] = mapped_column(sa.String(255))
+    stripe_subscription_id: Mapped[Optional[str]] = mapped_column(sa.String(255))
+    monthly_credits_granted_at: Mapped[Optional[datetime]] = mapped_column(sa.DateTime(timezone=True))
     created_at: Mapped[datetime] = mapped_column(sa.DateTime(timezone=True), server_default=sa.text("now()"))
     updated_at: Mapped[datetime] = mapped_column(
         sa.DateTime(timezone=True), server_default=sa.text("now()"), onupdate=sa.func.now()

file update:
diff --git a/backend/alembic/versions/20260206_0004_add_subscription_fields.py b/backend/alembic/versions/20260206_0004_add_subscription_fields.py
new file mode 100644
index 0000000000000000000000000000000000000000..f84be09226785ea3dbc1b413b3cfd2cb07dff81e
--- /dev/null
+++ b/backend/alembic/versions/20260206_0004_add_subscription_fields.py
@@ -0,0 +1,38 @@
+"""add subscription fields to users
+
+Revision ID: d4e5f6a7b8c9
+Revises: c3d4e5f6a7b8
+Create Date: 2026-02-06 00:40:00
+
+"""
+from __future__ import annotations
+
+from alembic import op
+import sqlalchemy as sa
+
+
+# revision identifiers, used by Alembic.
+revision = "d4e5f6a7b8c9"
+down_revision = "c3d4e5f6a7b8"
+branch_labels = None
+depends_on = None
+
+
+def upgrade() -> None:
+    # Add subscription-related columns to users
+    op.add_column(
+        "users",
+        sa.Column("plan", sa.String(length=20), nullable=False, server_default=sa.text("'free'")),
+    )
+    op.add_column("users", sa.Column("stripe_customer_id", sa.String(length=255), nullable=True))
+    op.add_column("users", sa.Column("stripe_subscription_id", sa.String(length=255), nullable=True))
+    op.add_column("users", sa.Column("monthly_credits_granted_at", sa.DateTime(timezone=True), nullable=True))
+
+
+def downgrade() -> None:
+    # Drop subscription-related columns from users
+    op.drop_column("users", "monthly_credits_granted_at")
+    op.drop_column("users", "stripe_subscription_id")
+    op.drop_column("users", "stripe_customer_id")
+    op.drop_column("users", "plan")
+
diff --git a/backend/app/models/tables.py b/backend/app/models/tables.py
index 2eb9239abb3f01f8a4103944db02efcb27f20149..9caeafd2d73fb05604695d962f9a0dc191da0bf2
--- a/backend/app/models/tables.py
+++ b/backend/app/models/tables.py
@@ -163,6 +163,10 @@
     email_verified: Mapped[Optional[datetime]] = mapped_column(sa.DateTime(timezone=True))
     credits_balance: Mapped[int] = mapped_column(sa.Integer, nullable=False, server_default=sa.text("0"))
     signup_bonus_granted_at: Mapped[Optional[datetime]] = mapped_column(sa.DateTime(timezone=True))
+    plan: Mapped[str] = mapped_column(sa.String(20), nullable=False, server_default=sa.text("'free'"))
+    stripe_customer_id: Mapped[Optional[str]] = mapped_column(sa.String(255))
+    stripe_subscription_id: Mapped[Optional[str]] = mapped_column(sa.String(255))
+    monthly_credits_granted_at: Mapped[Optional[datetime]] = mapped_column(sa.DateTime(timezone=True))
     created_at: Mapped[datetime] = mapped_column(sa.DateTime(timezone=True), server_default=sa.text("now()"))
     updated_at: Mapped[datetime] = mapped_column(
         sa.DateTime(timezone=True), server_default=sa.text("now()"), onupdate=sa.func.now()

file update
M /Users/mayijie/Projects/Code/010_DocTalk/backend/app/core/config.py
@@ -77,2 +77,6 @@
     SIGNUP_BONUS_CREDITS: int = 10000
+    # Subscription tiers
+    PLAN_FREE_MONTHLY_CREDITS: int = 10000
+    PLAN_PRO_MONTHLY_CREDITS: int = 100000
+    STRIPE_PRICE_PRO_MONTHLY: str = ''
 
apply_patch(auto_approved=true) exited 0 in 41ms:
Success. Updated the following files:
M backend/app/core/config.py
file update:
diff --git a/backend/alembic/versions/20260206_0004_add_subscription_fields.py b/backend/alembic/versions/20260206_0004_add_subscription_fields.py
new file mode 100644
index 0000000000000000000000000000000000000000..f84be09226785ea3dbc1b413b3cfd2cb07dff81e
--- /dev/null
+++ b/backend/alembic/versions/20260206_0004_add_subscription_fields.py
@@ -0,0 +1,38 @@
+"""add subscription fields to users
+
+Revision ID: d4e5f6a7b8c9
+Revises: c3d4e5f6a7b8
+Create Date: 2026-02-06 00:40:00
+
+"""
+from __future__ import annotations
+
+from alembic import op
+import sqlalchemy as sa
+
+
+# revision identifiers, used by Alembic.
+revision = "d4e5f6a7b8c9"
+down_revision = "c3d4e5f6a7b8"
+branch_labels = None
+depends_on = None
+
+
+def upgrade() -> None:
+    # Add subscription-related columns to users
+    op.add_column(
+        "users",
+        sa.Column("plan", sa.String(length=20), nullable=False, server_default=sa.text("'free'")),
+    )
+    op.add_column("users", sa.Column("stripe_customer_id", sa.String(length=255), nullable=True))
+    op.add_column("users", sa.Column("stripe_subscription_id", sa.String(length=255), nullable=True))
+    op.add_column("users", sa.Column("monthly_credits_granted_at", sa.DateTime(timezone=True), nullable=True))
+
+
+def downgrade() -> None:
+    # Drop subscription-related columns from users
+    op.drop_column("users", "monthly_credits_granted_at")
+    op.drop_column("users", "stripe_subscription_id")
+    op.drop_column("users", "stripe_customer_id")
+    op.drop_column("users", "plan")
+
diff --git a/backend/app/core/config.py b/backend/app/core/config.py
index 830f599a7b1ff02463684a9e84e90adfd6318cc1..a8eef6c5b4145c3710d46395bf26465dec42b4a7
--- a/backend/app/core/config.py
+++ b/backend/app/core/config.py
@@ -75,6 +75,10 @@
     CREDITS_PRO: int = 200000
     CREDITS_ENTERPRISE: int = 1000000
     SIGNUP_BONUS_CREDITS: int = 10000
+    # Subscription tiers
+    PLAN_FREE_MONTHLY_CREDITS: int = 10000
+    PLAN_PRO_MONTHLY_CREDITS: int = 100000
+    STRIPE_PRICE_PRO_MONTHLY: str = ''
 
     model_config = SettingsConfigDict(env_file=".env", env_file_encoding="utf-8", case_sensitive=False)
 
diff --git a/backend/app/models/tables.py b/backend/app/models/tables.py
index 2eb9239abb3f01f8a4103944db02efcb27f20149..9caeafd2d73fb05604695d962f9a0dc191da0bf2
--- a/backend/app/models/tables.py
+++ b/backend/app/models/tables.py
@@ -163,6 +163,10 @@
     email_verified: Mapped[Optional[datetime]] = mapped_column(sa.DateTime(timezone=True))
     credits_balance: Mapped[int] = mapped_column(sa.Integer, nullable=False, server_default=sa.text("0"))
     signup_bonus_granted_at: Mapped[Optional[datetime]] = mapped_column(sa.DateTime(timezone=True))
+    plan: Mapped[str] = mapped_column(sa.String(20), nullable=False, server_default=sa.text("'free'"))
+    stripe_customer_id: Mapped[Optional[str]] = mapped_column(sa.String(255))
+    stripe_subscription_id: Mapped[Optional[str]] = mapped_column(sa.String(255))
+    monthly_credits_granted_at: Mapped[Optional[datetime]] = mapped_column(sa.DateTime(timezone=True))
     created_at: Mapped[datetime] = mapped_column(sa.DateTime(timezone=True), server_default=sa.text("now()"))
     updated_at: Mapped[datetime] = mapped_column(
         sa.DateTime(timezone=True), server_default=sa.text("now()"), onupdate=sa.func.now()

file update:
diff --git a/backend/alembic/versions/20260206_0004_add_subscription_fields.py b/backend/alembic/versions/20260206_0004_add_subscription_fields.py
new file mode 100644
index 0000000000000000000000000000000000000000..f84be09226785ea3dbc1b413b3cfd2cb07dff81e
--- /dev/null
+++ b/backend/alembic/versions/20260206_0004_add_subscription_fields.py
@@ -0,0 +1,38 @@
+"""add subscription fields to users
+
+Revision ID: d4e5f6a7b8c9
+Revises: c3d4e5f6a7b8
+Create Date: 2026-02-06 00:40:00
+
+"""
+from __future__ import annotations
+
+from alembic import op
+import sqlalchemy as sa
+
+
+# revision identifiers, used by Alembic.
+revision = "d4e5f6a7b8c9"
+down_revision = "c3d4e5f6a7b8"
+branch_labels = None
+depends_on = None
+
+
+def upgrade() -> None:
+    # Add subscription-related columns to users
+    op.add_column(
+        "users",
+        sa.Column("plan", sa.String(length=20), nullable=False, server_default=sa.text("'free'")),
+    )
+    op.add_column("users", sa.Column("stripe_customer_id", sa.String(length=255), nullable=True))
+    op.add_column("users", sa.Column("stripe_subscription_id", sa.String(length=255), nullable=True))
+    op.add_column("users", sa.Column("monthly_credits_granted_at", sa.DateTime(timezone=True), nullable=True))
+
+
+def downgrade() -> None:
+    # Drop subscription-related columns from users
+    op.drop_column("users", "monthly_credits_granted_at")
+    op.drop_column("users", "stripe_subscription_id")
+    op.drop_column("users", "stripe_customer_id")
+    op.drop_column("users", "plan")
+
diff --git a/backend/app/core/config.py b/backend/app/core/config.py
index 830f599a7b1ff02463684a9e84e90adfd6318cc1..a8eef6c5b4145c3710d46395bf26465dec42b4a7
--- a/backend/app/core/config.py
+++ b/backend/app/core/config.py
@@ -75,6 +75,10 @@
     CREDITS_PRO: int = 200000
     CREDITS_ENTERPRISE: int = 1000000
     SIGNUP_BONUS_CREDITS: int = 10000
+    # Subscription tiers
+    PLAN_FREE_MONTHLY_CREDITS: int = 10000
+    PLAN_PRO_MONTHLY_CREDITS: int = 100000
+    STRIPE_PRICE_PRO_MONTHLY: str = ''
 
     model_config = SettingsConfigDict(env_file=".env", env_file_encoding="utf-8", case_sensitive=False)
 
diff --git a/backend/app/models/tables.py b/backend/app/models/tables.py
index 2eb9239abb3f01f8a4103944db02efcb27f20149..9caeafd2d73fb05604695d962f9a0dc191da0bf2
--- a/backend/app/models/tables.py
+++ b/backend/app/models/tables.py
@@ -163,6 +163,10 @@
     email_verified: Mapped[Optional[datetime]] = mapped_column(sa.DateTime(timezone=True))
     credits_balance: Mapped[int] = mapped_column(sa.Integer, nullable=False, server_default=sa.text("0"))
     signup_bonus_granted_at: Mapped[Optional[datetime]] = mapped_column(sa.DateTime(timezone=True))
+    plan: Mapped[str] = mapped_column(sa.String(20), nullable=False, server_default=sa.text("'free'"))
+    stripe_customer_id: Mapped[Optional[str]] = mapped_column(sa.String(255))
+    stripe_subscription_id: Mapped[Optional[str]] = mapped_column(sa.String(255))
+    monthly_credits_granted_at: Mapped[Optional[datetime]] = mapped_column(sa.DateTime(timezone=True))
     created_at: Mapped[datetime] = mapped_column(sa.DateTime(timezone=True), server_default=sa.text("now()"))
     updated_at: Mapped[datetime] = mapped_column(
         sa.DateTime(timezone=True), server_default=sa.text("now()"), onupdate=sa.func.now()


thinking
**Adding monthly credits functionality**

I’m thinking about adding a feature to the credit service that ensures monthly credits are processed correctly. It's essential to make sure the system correctly allocates credits each month so that users receive what they're entitled to. I'll have to think carefully about how to implement this to ensure it's efficient and error-free. I wonder if there are any existing functions that I can leverage to streamline this process.
file update
M /Users/mayijie/Projects/Code/010_DocTalk/backend/app/services/credit_service.py
@@ -9,2 +9,3 @@
 from app.models.tables import CreditLedger, UsageRecord, User
+from app.core.config import settings
 
@@ -146 +147,54 @@
 
+
+async def ensure_monthly_credits(db: AsyncSession, user: User) -> None:
+    """Grant monthly credits if last grant was over 30 days ago.
+
+    Idempotency: checks CreditLedger for any recent 'monthly_allowance' within 30 days.
+    """
+    from datetime import datetime, timedelta, timezone
+
+    # Determine if grant needed based on timestamp
+    now = datetime.now(timezone.utc)
+    last = user.monthly_credits_granted_at
+    needs_grant = last is None or (now - last) >= timedelta(days=30)
+    if not needs_grant:
+        return
+
+    # Check ledger for idempotency within last 30 days
+    cutoff = now - timedelta(days=30)
+    existing = await db.scalar(
+        sa.select(CreditLedger)
+        .where(CreditLedger.user_id == user.id)
+        .where(CreditLedger.reason == "monthly_allowance")
+        .where(CreditLedger.created_at >= cutoff)
+    )
+    if existing:
+        # Still update marker to avoid repeatedly checking in future requests
+        user.monthly_credits_granted_at = now
+        await db.flush()
+        return
+
+    # Determine allowance by plan
+    plan = (user.plan or "free").lower()
+    if plan == "pro":
+        allowance = int(settings.PLAN_PRO_MONTHLY_CREDITS or 0)
+    else:
+        allowance = int(settings.PLAN_FREE_MONTHLY_CREDITS or 0)
+
+    if allowance <= 0:
+        # Nothing to grant
+        user.monthly_credits_granted_at = now
+        await db.flush()
+        return
+
+    # Grant credits and update marker
+    await credit_credits(
+        db,
+        user_id=user.id,
+        amount=allowance,
+        reason="monthly_allowance",
+        ref_type=None,
+        ref_id=None,
+    )
+    user.monthly_credits_granted_at = now
+    await db.flush()
apply_patch(auto_approved=true) exited 0 in 50ms:
Success. Updated the following files:
M backend/app/services/credit_service.py
file update:
diff --git a/backend/alembic/versions/20260206_0004_add_subscription_fields.py b/backend/alembic/versions/20260206_0004_add_subscription_fields.py
new file mode 100644
index 0000000000000000000000000000000000000000..f84be09226785ea3dbc1b413b3cfd2cb07dff81e
--- /dev/null
+++ b/backend/alembic/versions/20260206_0004_add_subscription_fields.py
@@ -0,0 +1,38 @@
+"""add subscription fields to users
+
+Revision ID: d4e5f6a7b8c9
+Revises: c3d4e5f6a7b8
+Create Date: 2026-02-06 00:40:00
+
+"""
+from __future__ import annotations
+
+from alembic import op
+import sqlalchemy as sa
+
+
+# revision identifiers, used by Alembic.
+revision = "d4e5f6a7b8c9"
+down_revision = "c3d4e5f6a7b8"
+branch_labels = None
+depends_on = None
+
+
+def upgrade() -> None:
+    # Add subscription-related columns to users
+    op.add_column(
+        "users",
+        sa.Column("plan", sa.String(length=20), nullable=False, server_default=sa.text("'free'")),
+    )
+    op.add_column("users", sa.Column("stripe_customer_id", sa.String(length=255), nullable=True))
+    op.add_column("users", sa.Column("stripe_subscription_id", sa.String(length=255), nullable=True))
+    op.add_column("users", sa.Column("monthly_credits_granted_at", sa.DateTime(timezone=True), nullable=True))
+
+
+def downgrade() -> None:
+    # Drop subscription-related columns from users
+    op.drop_column("users", "monthly_credits_granted_at")
+    op.drop_column("users", "stripe_subscription_id")
+    op.drop_column("users", "stripe_customer_id")
+    op.drop_column("users", "plan")
+
diff --git a/backend/app/core/config.py b/backend/app/core/config.py
index 830f599a7b1ff02463684a9e84e90adfd6318cc1..a8eef6c5b4145c3710d46395bf26465dec42b4a7
--- a/backend/app/core/config.py
+++ b/backend/app/core/config.py
@@ -75,6 +75,10 @@
     CREDITS_PRO: int = 200000
     CREDITS_ENTERPRISE: int = 1000000
     SIGNUP_BONUS_CREDITS: int = 10000
+    # Subscription tiers
+    PLAN_FREE_MONTHLY_CREDITS: int = 10000
+    PLAN_PRO_MONTHLY_CREDITS: int = 100000
+    STRIPE_PRICE_PRO_MONTHLY: str = ''
 
     model_config = SettingsConfigDict(env_file=".env", env_file_encoding="utf-8", case_sensitive=False)
 
diff --git a/backend/app/models/tables.py b/backend/app/models/tables.py
index 2eb9239abb3f01f8a4103944db02efcb27f20149..9caeafd2d73fb05604695d962f9a0dc191da0bf2
--- a/backend/app/models/tables.py
+++ b/backend/app/models/tables.py
@@ -163,6 +163,10 @@
     email_verified: Mapped[Optional[datetime]] = mapped_column(sa.DateTime(timezone=True))
     credits_balance: Mapped[int] = mapped_column(sa.Integer, nullable=False, server_default=sa.text("0"))
     signup_bonus_granted_at: Mapped[Optional[datetime]] = mapped_column(sa.DateTime(timezone=True))
+    plan: Mapped[str] = mapped_column(sa.String(20), nullable=False, server_default=sa.text("'free'"))
+    stripe_customer_id: Mapped[Optional[str]] = mapped_column(sa.String(255))
+    stripe_subscription_id: Mapped[Optional[str]] = mapped_column(sa.String(255))
+    monthly_credits_granted_at: Mapped[Optional[datetime]] = mapped_column(sa.DateTime(timezone=True))
     created_at: Mapped[datetime] = mapped_column(sa.DateTime(timezone=True), server_default=sa.text("now()"))
     updated_at: Mapped[datetime] = mapped_column(
         sa.DateTime(timezone=True), server_default=sa.text("now()"), onupdate=sa.func.now()
diff --git a/backend/app/services/credit_service.py b/backend/app/services/credit_service.py
index d89772b0418d1ebe1a79bba3de65f0112a550adb..a599453a961fb9222db98928201795c4fa4e574b
--- a/backend/app/services/credit_service.py
+++ b/backend/app/services/credit_service.py
@@ -7,6 +7,7 @@
 from sqlalchemy.ext.asyncio import AsyncSession
 
 from app.models.tables import CreditLedger, UsageRecord, User
+from app.core.config import settings
 
 
 # Token-to-credit rates by model tier
@@ -144,3 +145,56 @@
     db.add(usage)
     return usage
 
+
+async def ensure_monthly_credits(db: AsyncSession, user: User) -> None:
+    """Grant monthly credits if last grant was over 30 days ago.
+
+    Idempotency: checks CreditLedger for any recent 'monthly_allowance' within 30 days.
+    """
+    from datetime import datetime, timedelta, timezone
+
+    # Determine if grant needed based on timestamp
+    now = datetime.now(timezone.utc)
+    last = user.monthly_credits_granted_at
+    needs_grant = last is None or (now - last) >= timedelta(days=30)
+    if not needs_grant:
+        return
+
+    # Check ledger for idempotency within last 30 days
+    cutoff = now - timedelta(days=30)
+    existing = await db.scalar(
+        sa.select(CreditLedger)
+        .where(CreditLedger.user_id == user.id)
+        .where(CreditLedger.reason == "monthly_allowance")
+        .where(CreditLedger.created_at >= cutoff)
+    )
+    if existing:
+        # Still update marker to avoid repeatedly checking in future requests
+        user.monthly_credits_granted_at = now
+        await db.flush()
+        return
+
+    # Determine allowance by plan
+    plan = (user.plan or "free").lower()
+    if plan == "pro":
+        allowance = int(settings.PLAN_PRO_MONTHLY_CREDITS or 0)
+    else:
+        allowance = int(settings.PLAN_FREE_MONTHLY_CREDITS or 0)
+
+    if allowance <= 0:
+        # Nothing to grant
+        user.monthly_credits_granted_at = now
+        await db.flush()
+        return
+
+    # Grant credits and update marker
+    await credit_credits(
+        db,
+        user_id=user.id,
+        amount=allowance,
+        reason="monthly_allowance",
+        ref_type=None,
+        ref_id=None,
+    )
+    user.monthly_credits_granted_at = now
+    await db.flush()

file update:
diff --git a/backend/alembic/versions/20260206_0004_add_subscription_fields.py b/backend/alembic/versions/20260206_0004_add_subscription_fields.py
new file mode 100644
index 0000000000000000000000000000000000000000..f84be09226785ea3dbc1b413b3cfd2cb07dff81e
--- /dev/null
+++ b/backend/alembic/versions/20260206_0004_add_subscription_fields.py
@@ -0,0 +1,38 @@
+"""add subscription fields to users
+
+Revision ID: d4e5f6a7b8c9
+Revises: c3d4e5f6a7b8
+Create Date: 2026-02-06 00:40:00
+
+"""
+from __future__ import annotations
+
+from alembic import op
+import sqlalchemy as sa
+
+
+# revision identifiers, used by Alembic.
+revision = "d4e5f6a7b8c9"
+down_revision = "c3d4e5f6a7b8"
+branch_labels = None
+depends_on = None
+
+
+def upgrade() -> None:
+    # Add subscription-related columns to users
+    op.add_column(
+        "users",
+        sa.Column("plan", sa.String(length=20), nullable=False, server_default=sa.text("'free'")),
+    )
+    op.add_column("users", sa.Column("stripe_customer_id", sa.String(length=255), nullable=True))
+    op.add_column("users", sa.Column("stripe_subscription_id", sa.String(length=255), nullable=True))
+    op.add_column("users", sa.Column("monthly_credits_granted_at", sa.DateTime(timezone=True), nullable=True))
+
+
+def downgrade() -> None:
+    # Drop subscription-related columns from users
+    op.drop_column("users", "monthly_credits_granted_at")
+    op.drop_column("users", "stripe_subscription_id")
+    op.drop_column("users", "stripe_customer_id")
+    op.drop_column("users", "plan")
+
diff --git a/backend/app/core/config.py b/backend/app/core/config.py
index 830f599a7b1ff02463684a9e84e90adfd6318cc1..a8eef6c5b4145c3710d46395bf26465dec42b4a7
--- a/backend/app/core/config.py
+++ b/backend/app/core/config.py
@@ -75,6 +75,10 @@
     CREDITS_PRO: int = 200000
     CREDITS_ENTERPRISE: int = 1000000
     SIGNUP_BONUS_CREDITS: int = 10000
+    # Subscription tiers
+    PLAN_FREE_MONTHLY_CREDITS: int = 10000
+    PLAN_PRO_MONTHLY_CREDITS: int = 100000
+    STRIPE_PRICE_PRO_MONTHLY: str = ''
 
     model_config = SettingsConfigDict(env_file=".env", env_file_encoding="utf-8", case_sensitive=False)
 
diff --git a/backend/app/models/tables.py b/backend/app/models/tables.py
index 2eb9239abb3f01f8a4103944db02efcb27f20149..9caeafd2d73fb05604695d962f9a0dc191da0bf2
--- a/backend/app/models/tables.py
+++ b/backend/app/models/tables.py
@@ -163,6 +163,10 @@
     email_verified: Mapped[Optional[datetime]] = mapped_column(sa.DateTime(timezone=True))
     credits_balance: Mapped[int] = mapped_column(sa.Integer, nullable=False, server_default=sa.text("0"))
     signup_bonus_granted_at: Mapped[Optional[datetime]] = mapped_column(sa.DateTime(timezone=True))
+    plan: Mapped[str] = mapped_column(sa.String(20), nullable=False, server_default=sa.text("'free'"))
+    stripe_customer_id: Mapped[Optional[str]] = mapped_column(sa.String(255))
+    stripe_subscription_id: Mapped[Optional[str]] = mapped_column(sa.String(255))
+    monthly_credits_granted_at: Mapped[Optional[datetime]] = mapped_column(sa.DateTime(timezone=True))
     created_at: Mapped[datetime] = mapped_column(sa.DateTime(timezone=True), server_default=sa.text("now()"))
     updated_at: Mapped[datetime] = mapped_column(
         sa.DateTime(timezone=True), server_default=sa.text("now()"), onupdate=sa.func.now()
diff --git a/backend/app/services/credit_service.py b/backend/app/services/credit_service.py
index d89772b0418d1ebe1a79bba3de65f0112a550adb..a599453a961fb9222db98928201795c4fa4e574b
--- a/backend/app/services/credit_service.py
+++ b/backend/app/services/credit_service.py
@@ -7,6 +7,7 @@
 from sqlalchemy.ext.asyncio import AsyncSession
 
 from app.models.tables import CreditLedger, UsageRecord, User
+from app.core.config import settings
 
 
 # Token-to-credit rates by model tier
@@ -144,3 +145,56 @@
     db.add(usage)
     return usage
 
+
+async def ensure_monthly_credits(db: AsyncSession, user: User) -> None:
+    """Grant monthly credits if last grant was over 30 days ago.
+
+    Idempotency: checks CreditLedger for any recent 'monthly_allowance' within 30 days.
+    """
+    from datetime import datetime, timedelta, timezone
+
+    # Determine if grant needed based on timestamp
+    now = datetime.now(timezone.utc)
+    last = user.monthly_credits_granted_at
+    needs_grant = last is None or (now - last) >= timedelta(days=30)
+    if not needs_grant:
+        return
+
+    # Check ledger for idempotency within last 30 days
+    cutoff = now - timedelta(days=30)
+    existing = await db.scalar(
+        sa.select(CreditLedger)
+        .where(CreditLedger.user_id == user.id)
+        .where(CreditLedger.reason == "monthly_allowance")
+        .where(CreditLedger.created_at >= cutoff)
+    )
+    if existing:
+        # Still update marker to avoid repeatedly checking in future requests
+        user.monthly_credits_granted_at = now
+        await db.flush()
+        return
+
+    # Determine allowance by plan
+    plan = (user.plan or "free").lower()
+    if plan == "pro":
+        allowance = int(settings.PLAN_PRO_MONTHLY_CREDITS or 0)
+    else:
+        allowance = int(settings.PLAN_FREE_MONTHLY_CREDITS or 0)
+
+    if allowance <= 0:
+        # Nothing to grant
+        user.monthly_credits_granted_at = now
+        await db.flush()
+        return
+
+    # Grant credits and update marker
+    await credit_credits(
+        db,
+        user_id=user.id,
+        amount=allowance,
+        reason="monthly_allowance",
+        ref_type=None,
+        ref_id=None,
+    )
+    user.monthly_credits_granted_at = now
+    await db.flush()


thinking
**Modifying function calls**

I'm considering how to modify chat.py effectively. After verifying session access, I'll need to add a call to ensure_monthly_credits and then handle the credit check afterward. It looks like I should import the necessary components within the function as specified. I’m also going to remember to include the db.commit call afterward. This way, I can ensure everything aligns properly! Let’s make sure we get this right.
file update
M /Users/mayijie/Projects/Code/010_DocTalk/backend/app/api/chat.py
@@ -135,2 +135,5 @@
     if user is not None:
+        from app.services.credit_service import ensure_monthly_credits
+        await ensure_monthly_credits(db, user)
+        await db.commit()
         balance = await credit_service.get_user_credits(db, user.id)
apply_patch(auto_approved=true) exited 0 in 55ms:
Success. Updated the following files:
M backend/app/api/chat.py
file update:
diff --git a/backend/alembic/versions/20260206_0004_add_subscription_fields.py b/backend/alembic/versions/20260206_0004_add_subscription_fields.py
new file mode 100644
index 0000000000000000000000000000000000000000..f84be09226785ea3dbc1b413b3cfd2cb07dff81e
--- /dev/null
+++ b/backend/alembic/versions/20260206_0004_add_subscription_fields.py
@@ -0,0 +1,38 @@
+"""add subscription fields to users
+
+Revision ID: d4e5f6a7b8c9
+Revises: c3d4e5f6a7b8
+Create Date: 2026-02-06 00:40:00
+
+"""
+from __future__ import annotations
+
+from alembic import op
+import sqlalchemy as sa
+
+
+# revision identifiers, used by Alembic.
+revision = "d4e5f6a7b8c9"
+down_revision = "c3d4e5f6a7b8"
+branch_labels = None
+depends_on = None
+
+
+def upgrade() -> None:
+    # Add subscription-related columns to users
+    op.add_column(
+        "users",
+        sa.Column("plan", sa.String(length=20), nullable=False, server_default=sa.text("'free'")),
+    )
+    op.add_column("users", sa.Column("stripe_customer_id", sa.String(length=255), nullable=True))
+    op.add_column("users", sa.Column("stripe_subscription_id", sa.String(length=255), nullable=True))
+    op.add_column("users", sa.Column("monthly_credits_granted_at", sa.DateTime(timezone=True), nullable=True))
+
+
+def downgrade() -> None:
+    # Drop subscription-related columns from users
+    op.drop_column("users", "monthly_credits_granted_at")
+    op.drop_column("users", "stripe_subscription_id")
+    op.drop_column("users", "stripe_customer_id")
+    op.drop_column("users", "plan")
+
diff --git a/backend/app/api/chat.py b/backend/app/api/chat.py
index 71fc751fa90239dfe90bf76e3b30a7aa686d0c3f..d52dc47026e109df283984196581d417a4fea1dc
--- a/backend/app/api/chat.py
+++ b/backend/app/api/chat.py
@@ -133,6 +133,9 @@
 
     # If authenticated, ensure sufficient credits before opening stream
     if user is not None:
+        from app.services.credit_service import ensure_monthly_credits
+        await ensure_monthly_credits(db, user)
+        await db.commit()
         balance = await credit_service.get_user_credits(db, user.id)
         if balance < credit_service.MIN_CREDITS_FOR_CHAT:
             return JSONResponse(
diff --git a/backend/app/core/config.py b/backend/app/core/config.py
index 830f599a7b1ff02463684a9e84e90adfd6318cc1..a8eef6c5b4145c3710d46395bf26465dec42b4a7
--- a/backend/app/core/config.py
+++ b/backend/app/core/config.py
@@ -75,6 +75,10 @@
     CREDITS_PRO: int = 200000
     CREDITS_ENTERPRISE: int = 1000000
     SIGNUP_BONUS_CREDITS: int = 10000
+    # Subscription tiers
+    PLAN_FREE_MONTHLY_CREDITS: int = 10000
+    PLAN_PRO_MONTHLY_CREDITS: int = 100000
+    STRIPE_PRICE_PRO_MONTHLY: str = ''
 
     model_config = SettingsConfigDict(env_file=".env", env_file_encoding="utf-8", case_sensitive=False)
 
diff --git a/backend/app/models/tables.py b/backend/app/models/tables.py
index 2eb9239abb3f01f8a4103944db02efcb27f20149..9caeafd2d73fb05604695d962f9a0dc191da0bf2
--- a/backend/app/models/tables.py
+++ b/backend/app/models/tables.py
@@ -163,6 +163,10 @@
     email_verified: Mapped[Optional[datetime]] = mapped_column(sa.DateTime(timezone=True))
     credits_balance: Mapped[int] = mapped_column(sa.Integer, nullable=False, server_default=sa.text("0"))
     signup_bonus_granted_at: Mapped[Optional[datetime]] = mapped_column(sa.DateTime(timezone=True))
+    plan: Mapped[str] = mapped_column(sa.String(20), nullable=False, server_default=sa.text("'free'"))
+    stripe_customer_id: Mapped[Optional[str]] = mapped_column(sa.String(255))
+    stripe_subscription_id: Mapped[Optional[str]] = mapped_column(sa.String(255))
+    monthly_credits_granted_at: Mapped[Optional[datetime]] = mapped_column(sa.DateTime(timezone=True))
     created_at: Mapped[datetime] = mapped_column(sa.DateTime(timezone=True), server_default=sa.text("now()"))
     updated_at: Mapped[datetime] = mapped_column(
         sa.DateTime(timezone=True), server_default=sa.text("now()"), onupdate=sa.func.now()
diff --git a/backend/app/services/credit_service.py b/backend/app/services/credit_service.py
index d89772b0418d1ebe1a79bba3de65f0112a550adb..a599453a961fb9222db98928201795c4fa4e574b
--- a/backend/app/services/credit_service.py
+++ b/backend/app/services/credit_service.py
@@ -7,6 +7,7 @@
 from sqlalchemy.ext.asyncio import AsyncSession
 
 from app.models.tables import CreditLedger, UsageRecord, User
+from app.core.config import settings
 
 
 # Token-to-credit rates by model tier
@@ -144,3 +145,56 @@
     db.add(usage)
     return usage
 
+
+async def ensure_monthly_credits(db: AsyncSession, user: User) -> None:
+    """Grant monthly credits if last grant was over 30 days ago.
+
+    Idempotency: checks CreditLedger for any recent 'monthly_allowance' within 30 days.
+    """
+    from datetime import datetime, timedelta, timezone
+
+    # Determine if grant needed based on timestamp
+    now = datetime.now(timezone.utc)
+    last = user.monthly_credits_granted_at
+    needs_grant = last is None or (now - last) >= timedelta(days=30)
+    if not needs_grant:
+        return
+
+    # Check ledger for idempotency within last 30 days
+    cutoff = now - timedelta(days=30)
+    existing = await db.scalar(
+        sa.select(CreditLedger)
+        .where(CreditLedger.user_id == user.id)
+        .where(CreditLedger.reason == "monthly_allowance")
+        .where(CreditLedger.created_at >= cutoff)
+    )
+    if existing:
+        # Still update marker to avoid repeatedly checking in future requests
+        user.monthly_credits_granted_at = now
+        await db.flush()
+        return
+
+    # Determine allowance by plan
+    plan = (user.plan or "free").lower()
+    if plan == "pro":
+        allowance = int(settings.PLAN_PRO_MONTHLY_CREDITS or 0)
+    else:
+        allowance = int(settings.PLAN_FREE_MONTHLY_CREDITS or 0)
+
+    if allowance <= 0:
+        # Nothing to grant
+        user.monthly_credits_granted_at = now
+        await db.flush()
+        return
+
+    # Grant credits and update marker
+    await credit_credits(
+        db,
+        user_id=user.id,
+        amount=allowance,
+        reason="monthly_allowance",
+        ref_type=None,
+        ref_id=None,
+    )
+    user.monthly_credits_granted_at = now
+    await db.flush()

file update:
diff --git a/backend/alembic/versions/20260206_0004_add_subscription_fields.py b/backend/alembic/versions/20260206_0004_add_subscription_fields.py
new file mode 100644
index 0000000000000000000000000000000000000000..f84be09226785ea3dbc1b413b3cfd2cb07dff81e
--- /dev/null
+++ b/backend/alembic/versions/20260206_0004_add_subscription_fields.py
@@ -0,0 +1,38 @@
+"""add subscription fields to users
+
+Revision ID: d4e5f6a7b8c9
+Revises: c3d4e5f6a7b8
+Create Date: 2026-02-06 00:40:00
+
+"""
+from __future__ import annotations
+
+from alembic import op
+import sqlalchemy as sa
+
+
+# revision identifiers, used by Alembic.
+revision = "d4e5f6a7b8c9"
+down_revision = "c3d4e5f6a7b8"
+branch_labels = None
+depends_on = None
+
+
+def upgrade() -> None:
+    # Add subscription-related columns to users
+    op.add_column(
+        "users",
+        sa.Column("plan", sa.String(length=20), nullable=False, server_default=sa.text("'free'")),
+    )
+    op.add_column("users", sa.Column("stripe_customer_id", sa.String(length=255), nullable=True))
+    op.add_column("users", sa.Column("stripe_subscription_id", sa.String(length=255), nullable=True))
+    op.add_column("users", sa.Column("monthly_credits_granted_at", sa.DateTime(timezone=True), nullable=True))
+
+
+def downgrade() -> None:
+    # Drop subscription-related columns from users
+    op.drop_column("users", "monthly_credits_granted_at")
+    op.drop_column("users", "stripe_subscription_id")
+    op.drop_column("users", "stripe_customer_id")
+    op.drop_column("users", "plan")
+
diff --git a/backend/app/api/chat.py b/backend/app/api/chat.py
index 71fc751fa90239dfe90bf76e3b30a7aa686d0c3f..d52dc47026e109df283984196581d417a4fea1dc
--- a/backend/app/api/chat.py
+++ b/backend/app/api/chat.py
@@ -133,6 +133,9 @@
 
     # If authenticated, ensure sufficient credits before opening stream
     if user is not None:
+        from app.services.credit_service import ensure_monthly_credits
+        await ensure_monthly_credits(db, user)
+        await db.commit()
         balance = await credit_service.get_user_credits(db, user.id)
         if balance < credit_service.MIN_CREDITS_FOR_CHAT:
             return JSONResponse(
diff --git a/backend/app/core/config.py b/backend/app/core/config.py
index 830f599a7b1ff02463684a9e84e90adfd6318cc1..a8eef6c5b4145c3710d46395bf26465dec42b4a7
--- a/backend/app/core/config.py
+++ b/backend/app/core/config.py
@@ -75,6 +75,10 @@
     CREDITS_PRO: int = 200000
     CREDITS_ENTERPRISE: int = 1000000
     SIGNUP_BONUS_CREDITS: int = 10000
+    # Subscription tiers
+    PLAN_FREE_MONTHLY_CREDITS: int = 10000
+    PLAN_PRO_MONTHLY_CREDITS: int = 100000
+    STRIPE_PRICE_PRO_MONTHLY: str = ''
 
     model_config = SettingsConfigDict(env_file=".env", env_file_encoding="utf-8", case_sensitive=False)
 
diff --git a/backend/app/models/tables.py b/backend/app/models/tables.py
index 2eb9239abb3f01f8a4103944db02efcb27f20149..9caeafd2d73fb05604695d962f9a0dc191da0bf2
--- a/backend/app/models/tables.py
+++ b/backend/app/models/tables.py
@@ -163,6 +163,10 @@
     email_verified: Mapped[Optional[datetime]] = mapped_column(sa.DateTime(timezone=True))
     credits_balance: Mapped[int] = mapped_column(sa.Integer, nullable=False, server_default=sa.text("0"))
     signup_bonus_granted_at: Mapped[Optional[datetime]] = mapped_column(sa.DateTime(timezone=True))
+    plan: Mapped[str] = mapped_column(sa.String(20), nullable=False, server_default=sa.text("'free'"))
+    stripe_customer_id: Mapped[Optional[str]] = mapped_column(sa.String(255))
+    stripe_subscription_id: Mapped[Optional[str]] = mapped_column(sa.String(255))
+    monthly_credits_granted_at: Mapped[Optional[datetime]] = mapped_column(sa.DateTime(timezone=True))
     created_at: Mapped[datetime] = mapped_column(sa.DateTime(timezone=True), server_default=sa.text("now()"))
     updated_at: Mapped[datetime] = mapped_column(
         sa.DateTime(timezone=True), server_default=sa.text("now()"), onupdate=sa.func.now()
diff --git a/backend/app/services/credit_service.py b/backend/app/services/credit_service.py
index d89772b0418d1ebe1a79bba3de65f0112a550adb..a599453a961fb9222db98928201795c4fa4e574b
--- a/backend/app/services/credit_service.py
+++ b/backend/app/services/credit_service.py
@@ -7,6 +7,7 @@
 from sqlalchemy.ext.asyncio import AsyncSession
 
 from app.models.tables import CreditLedger, UsageRecord, User
+from app.core.config import settings
 
 
 # Token-to-credit rates by model tier
@@ -144,3 +145,56 @@
     db.add(usage)
     return usage
 
+
+async def ensure_monthly_credits(db: AsyncSession, user: User) -> None:
+    """Grant monthly credits if last grant was over 30 days ago.
+
+    Idempotency: checks CreditLedger for any recent 'monthly_allowance' within 30 days.
+    """
+    from datetime import datetime, timedelta, timezone
+
+    # Determine if grant needed based on timestamp
+    now = datetime.now(timezone.utc)
+    last = user.monthly_credits_granted_at
+    needs_grant = last is None or (now - last) >= timedelta(days=30)
+    if not needs_grant:
+        return
+
+    # Check ledger for idempotency within last 30 days
+    cutoff = now - timedelta(days=30)
+    existing = await db.scalar(
+        sa.select(CreditLedger)
+        .where(CreditLedger.user_id == user.id)
+        .where(CreditLedger.reason == "monthly_allowance")
+        .where(CreditLedger.created_at >= cutoff)
+    )
+    if existing:
+        # Still update marker to avoid repeatedly checking in future requests
+        user.monthly_credits_granted_at = now
+        await db.flush()
+        return
+
+    # Determine allowance by plan
+    plan = (user.plan or "free").lower()
+    if plan == "pro":
+        allowance = int(settings.PLAN_PRO_MONTHLY_CREDITS or 0)
+    else:
+        allowance = int(settings.PLAN_FREE_MONTHLY_CREDITS or 0)
+
+    if allowance <= 0:
+        # Nothing to grant
+        user.monthly_credits_granted_at = now
+        await db.flush()
+        return
+
+    # Grant credits and update marker
+    await credit_credits(
+        db,
+        user_id=user.id,
+        amount=allowance,
+        reason="monthly_allowance",
+        ref_type=None,
+        ref_id=None,
+    )
+    user.monthly_credits_granted_at = now
+    await db.flush()




thinking
**Refining checkout session processing**

I’m working on code that handles when an event with `type` == `checkout.session.completed` is triggered. It tries to parse metadata for credits and payment intents. For subscriptions, credits won’t be present, so I’ll start by checking the mode. If it’s a subscription, I’ll extract the client reference ID as the user ID and get the subscription ID. It’s important to ensure the user exists, set their plan, and handle idempotency checks for credits. I need to clarify the reason for granting credits as well.
thinking
**Structuring credit grants**

I'm working on the logic for "Monthly Credit Grant," which automatically manages monthly allowances through the chat function. However, I need to ensure that the initial immediate grant is separate. I’ve decided to use the reason 'monthly_allowance' for consistent idempotency with the credit checks. If I grant an initial 100K with this reason, it will prevent re-grants for 30 days, which is helpful. I also need to keep existing logic for payments intact and implement early mode detection for parsing credits.
thinking
**Updating subscription handling**

I’m working on handling the event 'customer.subscription.deleted.' I need to get the subscription object, find the user by the `stripe_customer_id`, and then update their plan to free, clearing the `stripe_subscription_id`. I also need to manage the 'invoice.payment_succeeded' event, ensuring it’s linked to subscriptions. We’ll grant credits based on the 'invoice.id' since there might be cases of one-time invoices. However, the requirement only mentions granting 100K for subscription renewals, so keeping it simple is best. I'll also add necessary imports and modify the fields accordingly.
file update
M /Users/mayijie/Projects/Code/010_DocTalk/backend/app/api/billing.py
@@ -60,2 +60,52 @@
 
+# Subscriptions
+@router.post("/subscribe")
+async def subscribe(user: User = Depends(require_auth)):
+    if not settings.STRIPE_SECRET_KEY or not settings.STRIPE_PRICE_PRO_MONTHLY:
+        raise HTTPException(503, "Stripe not configured")
+
+    # Ensure customer exists
+    if not user.stripe_customer_id:
+        cust = stripe.Customer.create(email=user.email, name=user.name or None)
+        user.stripe_customer_id = cust.id
+        # Persist customer id
+        # Use a quick update via SQLAlchemy session on dependency side
+        from app.core.deps import get_db_session  # avoid circular import
+        # FastAPI won't let us depend here; defer to webhook to persist if necessary
+        # However, in typical dependency injection, User is attached to a session and flush works
+        try:
+            # Try to flush via bound session if available
+            # This attribute exists when loaded via SQLAlchemy session
+            object_session = getattr(user, "_sa_instance_state", None)
+            if object_session is not None and object_session.session is not None:
+                await object_session.session.flush()
+        except Exception:
+            pass
+
+    # Create Checkout Session for subscription
+    session = stripe.checkout.Session.create(
+        mode="subscription",
+        line_items=[{"price": settings.STRIPE_PRICE_PRO_MONTHLY, "quantity": 1}],
+        success_url=f"{settings.FRONTEND_URL}/billing",
+        cancel_url=f"{settings.FRONTEND_URL}/billing",
+        customer=user.stripe_customer_id,
+        client_reference_id=str(user.id),
+    )
+    return {"checkout_url": session.url}
+
+
+@router.post("/portal")
+async def customer_portal(user: User = Depends(require_auth)):
+    if not settings.STRIPE_SECRET_KEY:
+        raise HTTPException(503, "Stripe not configured")
+    if not user.stripe_customer_id:
+        raise HTTPException(400, "No Stripe customer for user")
+
+    portal = stripe.billing_portal.Session.create(
+        customer=user.stripe_customer_id,
+        return_url=f"{settings.FRONTEND_URL}/billing",
+    )
+    return {"portal_url": portal.url}
+
+
 @router.post("/webhook")
@@ -87,48 +137,159 @@
 
-        # Parse and validate client_reference_id (user_id)
-        try:
-            client_ref = session.get("client_reference_id")
-            if not client_ref:
-                logger.error("Missing client_reference_id in checkout session")
+        mode = session.get("mode")
+
+        # Handle subscription checkout
+        if mode == "subscription":
+            try:
+                client_ref = session.get("client_reference_id")
+                if not client_ref:
+                    logger.error("Missing client_reference_id in subscription session")
+                    return {"received": True}
+                user_id = uuid.UUID(client_ref)
+            except (ValueError, TypeError) as e:
+                logger.error("Invalid client_reference_id: %s", e)
+                return {"received": True}
+
+            user = await db.get(User, user_id)
+            if not user:
+                logger.warning("Subscription completed for non-existent user %s", user_id)
                 return {"received": True}
-            user_id = uuid.UUID(client_ref)
-        except (ValueError, TypeError) as e:
-            logger.error("Invalid client_reference_id: %s", e)
+
+            subscription_id = session.get("subscription")
+            customer_id = session.get("customer")
+
+            # Update user plan and subscription/customer ids
+            user.plan = "pro"
+            if subscription_id:
+                user.stripe_subscription_id = subscription_id
+            if customer_id and not user.stripe_customer_id:
+                user.stripe_customer_id = customer_id
+
+            # Idempotency: only one monthly grant per subscription id at start
+            existing = await db.scalar(
+                select(CreditLedger).where(
+                    CreditLedger.ref_type == "stripe_subscription",
+                    CreditLedger.ref_id == (subscription_id or ""),
+                )
+            )
+
+            if not existing:
+                try:
+                    await credit_credits(
+                        db,
+                        user_id=user.id,
+                        amount=int(settings.PLAN_PRO_MONTHLY_CREDITS or 0),
+                        reason="monthly_allowance",
+                        ref_type="stripe_subscription",
+                        ref_id=subscription_id or "",
+                    )
+                    await db.commit()
+                    logger.info(
+                        "Subscription start credits granted: user_id=%s, subscription=%s",
+                        user.id,
+                        subscription_id,
+                    )
+                except Exception as e:
+                    await db.rollback()
+                    logger.error("Failed to grant subscription start credits: %s", e)
+                    raise HTTPException(500, "Database error")
+            else:
+                await db.commit()
+
             return {"received": True}
 
-        # Parse and validate credits amount
-        try:
-            metadata = session.get("metadata", {})
-            credits_str = metadata.get("credits")
-            if not credits_str:
-                logger.error("Missing credits in session metadata")
+        # Handle one-time credit pack checkout
+        if mode == "payment":
+            # Parse and validate client_reference_id (user_id)
+            try:
+                client_ref = session.get("client_reference_id")
+                if not client_ref:
+                    logger.error("Missing client_reference_id in checkout session")
+                    return {"received": True}
+                user_id = uuid.UUID(client_ref)
+            except (ValueError, TypeError) as e:
+                logger.error("Invalid client_reference_id: %s", e)
+                return {"received": True}
+
+            # Parse and validate credits amount
+            try:
+                metadata = session.get("metadata", {})
+                credits_str = metadata.get("credits")
+                if not credits_str:
+                    logger.error("Missing credits in session metadata")
+                    return {"received": True}
+                credits = int(credits_str)
+                if credits <= 0:
+                    logger.error("Invalid credits amount: %d", credits)
+                    return {"received": True}
+            except (ValueError, TypeError) as e:
+                logger.error("Cannot parse credits from metadata: %s", e)
+                return {"received": True}
+
+            # Get payment_intent for idempotency
+            payment_intent = session.get("payment_intent")
+            if not payment_intent:
+                logger.warning("Checkout session has no payment_intent, skipping for safety")
                 return {"received": True}
-            credits = int(credits_str)
-            if credits <= 0:
-                logger.error("Invalid credits amount: %d", credits)
+
+            # Verify user exists
+            user = await db.get(User, user_id)
+            if not user:
+                logger.warning("Webhook for non-existent user %s", user_id)
                 return {"received": True}
-        except (ValueError, TypeError) as e:
-            logger.error("Cannot parse credits from metadata: %s", e)
+
+            # Idempotency check
+            existing = await db.scalar(
+                select(CreditLedger).where(
+                    CreditLedger.ref_type == "stripe_payment",
+                    CreditLedger.ref_id == payment_intent,
+                )
+            )
+
+            if not existing:
+                try:
+                    await credit_credits(
+                        db,
+                        user_id,
+                        credits,
+                        reason="purchase",
+                        ref_type="stripe_payment",
+                        ref_id=payment_intent,
+                    )
+                    await db.commit()
+                    logger.info(
+                        "Credits granted: user_id=%s, credits=%d, payment_intent=%s",
+                        user_id,
+                        credits,
+                        payment_intent,
+                    )
+                except Exception as e:
+                    await db.rollback()
+                    logger.error("Failed to grant credits: %s", e)
+                    # Return 5xx so Stripe retries
+                    raise HTTPException(500, "Database error")
+            return {"received": True}
+
+    elif event["type"] == "invoice.payment_succeeded":
+    
+        obj = event.get("data", {}).get("object")
+        if not obj or not isinstance(obj, dict):
             return {"received": True}
 
-        # Get payment_intent for idempotency
-        payment_intent = session.get("payment_intent")
-        if not payment_intent:
-            logger.warning("Checkout session has no payment_intent, skipping for safety")
+        invoice_id = obj.get("id")
+        customer_id = obj.get("customer")
+        if not invoice_id or not customer_id:
             return {"received": True}
 
-        # Verify user exists
-        user = await db.get(User, user_id)
+        # Find user by customer id
+        user = await db.scalar(select(User).where(User.stripe_customer_id == customer_id))
         if not user:
-            logger.warning("Webhook for non-existent user %s", user_id)
             return {"received": True}
 
-        # Idempotency check
+        # Idempotency: ensure we haven't granted for this invoice
         existing = await db.scalar(
             select(CreditLedger).where(
-                CreditLedger.ref_type == "stripe_payment",
-                CreditLedger.ref_id == payment_intent,
+                CreditLedger.ref_type == "stripe_invoice",
+                CreditLedger.ref_id == invoice_id,
             )
         )
-
         if not existing:
@@ -137,18 +298,33 @@
                     db,
-                    user_id,
-                    credits,
-                    reason="purchase",
-                    ref_type="stripe_payment",
-                    ref_id=payment_intent,
+                    user_id=user.id,
+                    amount=int(settings.PLAN_PRO_MONTHLY_CREDITS or 0),
+                    reason="monthly_allowance",
+                    ref_type="stripe_invoice",
+                    ref_id=invoice_id,
                 )
                 await db.commit()
-                logger.info("Credits granted: user_id=%s, credits=%d, payment_intent=%s",
-                           user_id, credits, payment_intent)
             except Exception as e:
                 await db.rollback()
-                logger.error("Failed to grant credits: %s", e)
-                # Return 5xx so Stripe retries
+                logger.error("Failed to grant monthly credits on invoice: %s", e)
                 raise HTTPException(500, "Database error")
+        return {"received": True}
+
+    elif event["type"] == "customer.subscription.deleted":
+        obj = event.get("data", {}).get("object")
+        if not obj or not isinstance(obj, dict):
+            return {"received": True}
+
+        customer_id = obj.get("customer")
+        if not customer_id:
+            return {"received": True}
+
+        user = await db.scalar(select(User).where(User.stripe_customer_id == customer_id))
+        if not user:
+            return {"received": True}
+
+        user.plan = "free"
+        user.stripe_subscription_id = None
+        await db.commit()
+        return {"received": True}
 
     return {"received": True}
-
apply_patch(auto_approved=true) exited 0 in 65ms:
Success. Updated the following files:
M backend/app/api/billing.py
file update:
diff --git a/backend/alembic/versions/20260206_0004_add_subscription_fields.py b/backend/alembic/versions/20260206_0004_add_subscription_fields.py
new file mode 100644
index 0000000000000000000000000000000000000000..f84be09226785ea3dbc1b413b3cfd2cb07dff81e
--- /dev/null
+++ b/backend/alembic/versions/20260206_0004_add_subscription_fields.py
@@ -0,0 +1,38 @@
+"""add subscription fields to users
+
+Revision ID: d4e5f6a7b8c9
+Revises: c3d4e5f6a7b8
+Create Date: 2026-02-06 00:40:00
+
+"""
+from __future__ import annotations
+
+from alembic import op
+import sqlalchemy as sa
+
+
+# revision identifiers, used by Alembic.
+revision = "d4e5f6a7b8c9"
+down_revision = "c3d4e5f6a7b8"
+branch_labels = None
+depends_on = None
+
+
+def upgrade() -> None:
+    # Add subscription-related columns to users
+    op.add_column(
+        "users",
+        sa.Column("plan", sa.String(length=20), nullable=False, server_default=sa.text("'free'")),
+    )
+    op.add_column("users", sa.Column("stripe_customer_id", sa.String(length=255), nullable=True))
+    op.add_column("users", sa.Column("stripe_subscription_id", sa.String(length=255), nullable=True))
+    op.add_column("users", sa.Column("monthly_credits_granted_at", sa.DateTime(timezone=True), nullable=True))
+
+
+def downgrade() -> None:
+    # Drop subscription-related columns from users
+    op.drop_column("users", "monthly_credits_granted_at")
+    op.drop_column("users", "stripe_subscription_id")
+    op.drop_column("users", "stripe_customer_id")
+    op.drop_column("users", "plan")
+
diff --git a/backend/app/api/billing.py b/backend/app/api/billing.py
index 851620df69f9c62fb3cab15feeedcafff44cc6bb..a1514308469dd90e936d1c2495aca396bc122ea2
--- a/backend/app/api/billing.py
+++ b/backend/app/api/billing.py
@@ -58,6 +58,56 @@
     return {"checkout_url": session.url}
 
 
+# Subscriptions
+@router.post("/subscribe")
+async def subscribe(user: User = Depends(require_auth)):
+    if not settings.STRIPE_SECRET_KEY or not settings.STRIPE_PRICE_PRO_MONTHLY:
+        raise HTTPException(503, "Stripe not configured")
+
+    # Ensure customer exists
+    if not user.stripe_customer_id:
+        cust = stripe.Customer.create(email=user.email, name=user.name or None)
+        user.stripe_customer_id = cust.id
+        # Persist customer id
+        # Use a quick update via SQLAlchemy session on dependency side
+        from app.core.deps import get_db_session  # avoid circular import
+        # FastAPI won't let us depend here; defer to webhook to persist if necessary
+        # However, in typical dependency injection, User is attached to a session and flush works
+        try:
+            # Try to flush via bound session if available
+            # This attribute exists when loaded via SQLAlchemy session
+            object_session = getattr(user, "_sa_instance_state", None)
+            if object_session is not None and object_session.session is not None:
+                await object_session.session.flush()
+        except Exception:
+            pass
+
+    # Create Checkout Session for subscription
+    session = stripe.checkout.Session.create(
+        mode="subscription",
+        line_items=[{"price": settings.STRIPE_PRICE_PRO_MONTHLY, "quantity": 1}],
+        success_url=f"{settings.FRONTEND_URL}/billing",
+        cancel_url=f"{settings.FRONTEND_URL}/billing",
+        customer=user.stripe_customer_id,
+        client_reference_id=str(user.id),
+    )
+    return {"checkout_url": session.url}
+
+
+@router.post("/portal")
+async def customer_portal(user: User = Depends(require_auth)):
+    if not settings.STRIPE_SECRET_KEY:
+        raise HTTPException(503, "Stripe not configured")
+    if not user.stripe_customer_id:
+        raise HTTPException(400, "No Stripe customer for user")
+
+    portal = stripe.billing_portal.Session.create(
+        customer=user.stripe_customer_id,
+        return_url=f"{settings.FRONTEND_URL}/billing",
+    )
+    return {"portal_url": portal.url}
+
+
 @router.post("/webhook")
 async def stripe_webhook(request: Request, db: AsyncSession = Depends(get_db_session)):
     payload = await request.body()
@@ -85,70 +135,196 @@
             logger.error("Invalid event structure: missing data.object")
             return {"received": True}
 
-        # Parse and validate client_reference_id (user_id)
-        try:
-            client_ref = session.get("client_reference_id")
-            if not client_ref:
-                logger.error("Missing client_reference_id in checkout session")
+        mode = session.get("mode")
+
+        # Handle subscription checkout
+        if mode == "subscription":
+            try:
+                client_ref = session.get("client_reference_id")
+                if not client_ref:
+                    logger.error("Missing client_reference_id in subscription session")
+                    return {"received": True}
+                user_id = uuid.UUID(client_ref)
+            except (ValueError, TypeError) as e:
+                logger.error("Invalid client_reference_id: %s", e)
+                return {"received": True}
+
+            user = await db.get(User, user_id)
+            if not user:
+                logger.warning("Subscription completed for non-existent user %s", user_id)
                 return {"received": True}
-            user_id = uuid.UUID(client_ref)
-        except (ValueError, TypeError) as e:
-            logger.error("Invalid client_reference_id: %s", e)
+
+            subscription_id = session.get("subscription")
+            customer_id = session.get("customer")
+
+            # Update user plan and subscription/customer ids
+            user.plan = "pro"
+            if subscription_id:
+                user.stripe_subscription_id = subscription_id
+            if customer_id and not user.stripe_customer_id:
+                user.stripe_customer_id = customer_id
+
+            # Idempotency: only one monthly grant per subscription id at start
+            existing = await db.scalar(
+                select(CreditLedger).where(
+                    CreditLedger.ref_type == "stripe_subscription",
+                    CreditLedger.ref_id == (subscription_id or ""),
+                )
+            )
+
+            if not existing:
+                try:
+                    await credit_credits(
+                        db,
+                        user_id=user.id,
+                        amount=int(settings.PLAN_PRO_MONTHLY_CREDITS or 0),
+                        reason="monthly_allowance",
+                        ref_type="stripe_subscription",
+                        ref_id=subscription_id or "",
+                    )
+                    await db.commit()
+                    logger.info(
+                        "Subscription start credits granted: user_id=%s, subscription=%s",
+                        user.id,
+                        subscription_id,
+                    )
+                except Exception as e:
+                    await db.rollback()
+                    logger.error("Failed to grant subscription start credits: %s", e)
+                    raise HTTPException(500, "Database error")
+            else:
+                await db.commit()
+
             return {"received": True}
 
-        # Parse and validate credits amount
-        try:
-            metadata = session.get("metadata", {})
-            credits_str = metadata.get("credits")
-            if not credits_str:
-                logger.error("Missing credits in session metadata")
+        # Handle one-time credit pack checkout
+        if mode == "payment":
+            # Parse and validate client_reference_id (user_id)
+            try:
+                client_ref = session.get("client_reference_id")
+                if not client_ref:
+                    logger.error("Missing client_reference_id in checkout session")
+                    return {"received": True}
+                user_id = uuid.UUID(client_ref)
+            except (ValueError, TypeError) as e:
+                logger.error("Invalid client_reference_id: %s", e)
+                return {"received": True}
+
+            # Parse and validate credits amount
+            try:
+                metadata = session.get("metadata", {})
+                credits_str = metadata.get("credits")
+                if not credits_str:
+                    logger.error("Missing credits in session metadata")
+                    return {"received": True}
+                credits = int(credits_str)
+                if credits <= 0:
+                    logger.error("Invalid credits amount: %d", credits)
+                    return {"received": True}
+            except (ValueError, TypeError) as e:
+                logger.error("Cannot parse credits from metadata: %s", e)
+                return {"received": True}
+
+            # Get payment_intent for idempotency
+            payment_intent = session.get("payment_intent")
+            if not payment_intent:
+                logger.warning("Checkout session has no payment_intent, skipping for safety")
                 return {"received": True}
-            credits = int(credits_str)
-            if credits <= 0:
-                logger.error("Invalid credits amount: %d", credits)
+
+            # Verify user exists
+            user = await db.get(User, user_id)
+            if not user:
+                logger.warning("Webhook for non-existent user %s", user_id)
                 return {"received": True}
-        except (ValueError, TypeError) as e:
-            logger.error("Cannot parse credits from metadata: %s", e)
+
+            # Idempotency check
+            existing = await db.scalar(
+                select(CreditLedger).where(
+                    CreditLedger.ref_type == "stripe_payment",
+                    CreditLedger.ref_id == payment_intent,
+                )
+            )
+
+            if not existing:
+                try:
+                    await credit_credits(
+                        db,
+                        user_id,
+                        credits,
+                        reason="purchase",
+                        ref_type="stripe_payment",
+                        ref_id=payment_intent,
+                    )
+                    await db.commit()
+                    logger.info(
+                        "Credits granted: user_id=%s, credits=%d, payment_intent=%s",
+                        user_id,
+                        credits,
+                        payment_intent,
+                    )
+                except Exception as e:
+                    await db.rollback()
+                    logger.error("Failed to grant credits: %s", e)
+                    # Return 5xx so Stripe retries
+                    raise HTTPException(500, "Database error")
+            return {"received": True}
+
+    elif event["type"] == "invoice.payment_succeeded":
+    
+        obj = event.get("data", {}).get("object")
+        if not obj or not isinstance(obj, dict):
             return {"received": True}
 
-        # Get payment_intent for idempotency
-        payment_intent = session.get("payment_intent")
-        if not payment_intent:
-            logger.warning("Checkout session has no payment_intent, skipping for safety")
+        invoice_id = obj.get("id")
+        customer_id = obj.get("customer")
+        if not invoice_id or not customer_id:
             return {"received": True}
 
-        # Verify user exists
-        user = await db.get(User, user_id)
+        # Find user by customer id
+        user = await db.scalar(select(User).where(User.stripe_customer_id == customer_id))
         if not user:
-            logger.warning("Webhook for non-existent user %s", user_id)
             return {"received": True}
 
-        # Idempotency check
+        # Idempotency: ensure we haven't granted for this invoice
         existing = await db.scalar(
             select(CreditLedger).where(
-                CreditLedger.ref_type == "stripe_payment",
-                CreditLedger.ref_id == payment_intent,
+                CreditLedger.ref_type == "stripe_invoice",
+                CreditLedger.ref_id == invoice_id,
             )
         )
-
         if not existing:
             try:
                 await credit_credits(
                     db,
-                    user_id,
-                    credits,
-                    reason="purchase",
-                    ref_type="stripe_payment",
-                    ref_id=payment_intent,
+                    user_id=user.id,
+                    amount=int(settings.PLAN_PRO_MONTHLY_CREDITS or 0),
+                    reason="monthly_allowance",
+                    ref_type="stripe_invoice",
+                    ref_id=invoice_id,
                 )
                 await db.commit()
-                logger.info("Credits granted: user_id=%s, credits=%d, payment_intent=%s",
-                           user_id, credits, payment_intent)
             except Exception as e:
                 await db.rollback()
-                logger.error("Failed to grant credits: %s", e)
-                # Return 5xx so Stripe retries
+                logger.error("Failed to grant monthly credits on invoice: %s", e)
                 raise HTTPException(500, "Database error")
+        return {"received": True}
+
+    elif event["type"] == "customer.subscription.deleted":
+        obj = event.get("data", {}).get("object")
+        if not obj or not isinstance(obj, dict):
+            return {"received": True}
+
+        customer_id = obj.get("customer")
+        if not customer_id:
+            return {"received": True}
+
+        user = await db.scalar(select(User).where(User.stripe_customer_id == customer_id))
+        if not user:
+            return {"received": True}
+
+        user.plan = "free"
+        user.stripe_subscription_id = None
+        await db.commit()
+        return {"received": True}
 
     return {"received": True}
-
diff --git a/backend/app/api/chat.py b/backend/app/api/chat.py
index 71fc751fa90239dfe90bf76e3b30a7aa686d0c3f..d52dc47026e109df283984196581d417a4fea1dc
--- a/backend/app/api/chat.py
+++ b/backend/app/api/chat.py
@@ -133,6 +133,9 @@
 
     # If authenticated, ensure sufficient credits before opening stream
     if user is not None:
+        from app.services.credit_service import ensure_monthly_credits
+        await ensure_monthly_credits(db, user)
+        await db.commit()
         balance = await credit_service.get_user_credits(db, user.id)
         if balance < credit_service.MIN_CREDITS_FOR_CHAT:
             return JSONResponse(
diff --git a/backend/app/core/config.py b/backend/app/core/config.py
index 830f599a7b1ff02463684a9e84e90adfd6318cc1..a8eef6c5b4145c3710d46395bf26465dec42b4a7
--- a/backend/app/core/config.py
+++ b/backend/app/core/config.py
@@ -75,6 +75,10 @@
     CREDITS_PRO: int = 200000
     CREDITS_ENTERPRISE: int = 1000000
     SIGNUP_BONUS_CREDITS: int = 10000
+    # Subscription tiers
+    PLAN_FREE_MONTHLY_CREDITS: int = 10000
+    PLAN_PRO_MONTHLY_CREDITS: int = 100000
+    STRIPE_PRICE_PRO_MONTHLY: str = ''
 
     model_config = SettingsConfigDict(env_file=".env", env_file_encoding="utf-8", case_sensitive=False)
 
diff --git a/backend/app/models/tables.py b/backend/app/models/tables.py
index 2eb9239abb3f01f8a4103944db02efcb27f20149..9caeafd2d73fb05604695d962f9a0dc191da0bf2
--- a/backend/app/models/tables.py
+++ b/backend/app/models/tables.py
@@ -163,6 +163,10 @@
     email_verified: Mapped[Optional[datetime]] = mapped_column(sa.DateTime(timezone=True))
     credits_balance: Mapped[int] = mapped_column(sa.Integer, nullable=False, server_default=sa.text("0"))
     signup_bonus_granted_at: Mapped[Optional[datetime]] = mapped_column(sa.DateTime(timezone=True))
+    plan: Mapped[str] = mapped_column(sa.String(20), nullable=False, server_default=sa.text("'free'"))
+    stripe_customer_id: Mapped[Optional[str]] = mapped_column(sa.String(255))
+    stripe_subscription_id: Mapped[Optional[str]] = mapped_column(sa.String(255))
+    monthly_credits_granted_at: Mapped[Optional[datetime]] = mapped_column(sa.DateTime(timezone=True))
     created_at: Mapped[datetime] = mapped_column(sa.DateTime(timezone=True), server_default=sa.text("now()"))
     updated_at: Mapped[datetime] = mapped_column(
         sa.DateTime(timezone=True), server_default=sa.text("now()"), onupdate=sa.func.now()
diff --git a/backend/app/services/credit_service.py b/backend/app/services/credit_service.py
index d89772b0418d1ebe1a79bba3de65f0112a550adb..a599453a961fb9222db98928201795c4fa4e574b
--- a/backend/app/services/credit_service.py
+++ b/backend/app/services/credit_service.py
@@ -7,6 +7,7 @@
 from sqlalchemy.ext.asyncio import AsyncSession
 
 from app.models.tables import CreditLedger, UsageRecord, User
+from app.core.config import settings
 
 
 # Token-to-credit rates by model tier
@@ -144,3 +145,56 @@
     db.add(usage)
     return usage
 
+
+async def ensure_monthly_credits(db: AsyncSession, user: User) -> None:
+    """Grant monthly credits if last grant was over 30 days ago.
+
+    Idempotency: checks CreditLedger for any recent 'monthly_allowance' within 30 days.
+    """
+    from datetime import datetime, timedelta, timezone
+
+    # Determine if grant needed based on timestamp
+    now = datetime.now(timezone.utc)
+    last = user.monthly_credits_granted_at
+    needs_grant = last is None or (now - last) >= timedelta(days=30)
+    if not needs_grant:
+        return
+
+    # Check ledger for idempotency within last 30 days
+    cutoff = now - timedelta(days=30)
+    existing = await db.scalar(
+        sa.select(CreditLedger)
+        .where(CreditLedger.user_id == user.id)
+        .where(CreditLedger.reason == "monthly_allowance")
+        .where(CreditLedger.created_at >= cutoff)
+    )
+    if existing:
+        # Still update marker to avoid repeatedly checking in future requests
+        user.monthly_credits_granted_at = now
+        await db.flush()
+        return
+
+    # Determine allowance by plan
+    plan = (user.plan or "free").lower()
+    if plan == "pro":
+        allowance = int(settings.PLAN_PRO_MONTHLY_CREDITS or 0)
+    else:
+        allowance = int(settings.PLAN_FREE_MONTHLY_CREDITS or 0)
+
+    if allowance <= 0:
+        # Nothing to grant
+        user.monthly_credits_granted_at = now
+        await db.flush()
+        return
+
+    # Grant credits and update marker
+    await credit_credits(
+        db,
+        user_id=user.id,
+        amount=allowance,
+        reason="monthly_allowance",
+        ref_type=None,
+        ref_id=None,
+    )
+    user.monthly_credits_granted_at = now
+    await db.flush()

file update:
diff --git a/backend/alembic/versions/20260206_0004_add_subscription_fields.py b/backend/alembic/versions/20260206_0004_add_subscription_fields.py
new file mode 100644
index 0000000000000000000000000000000000000000..f84be09226785ea3dbc1b413b3cfd2cb07dff81e
--- /dev/null
+++ b/backend/alembic/versions/20260206_0004_add_subscription_fields.py
@@ -0,0 +1,38 @@
+"""add subscription fields to users
+
+Revision ID: d4e5f6a7b8c9
+Revises: c3d4e5f6a7b8
+Create Date: 2026-02-06 00:40:00
+
+"""
+from __future__ import annotations
+
+from alembic import op
+import sqlalchemy as sa
+
+
+# revision identifiers, used by Alembic.
+revision = "d4e5f6a7b8c9"
+down_revision = "c3d4e5f6a7b8"
+branch_labels = None
+depends_on = None
+
+
+def upgrade() -> None:
+    # Add subscription-related columns to users
+    op.add_column(
+        "users",
+        sa.Column("plan", sa.String(length=20), nullable=False, server_default=sa.text("'free'")),
+    )
+    op.add_column("users", sa.Column("stripe_customer_id", sa.String(length=255), nullable=True))
+    op.add_column("users", sa.Column("stripe_subscription_id", sa.String(length=255), nullable=True))
+    op.add_column("users", sa.Column("monthly_credits_granted_at", sa.DateTime(timezone=True), nullable=True))
+
+
+def downgrade() -> None:
+    # Drop subscription-related columns from users
+    op.drop_column("users", "monthly_credits_granted_at")
+    op.drop_column("users", "stripe_subscription_id")
+    op.drop_column("users", "stripe_customer_id")
+    op.drop_column("users", "plan")
+
diff --git a/backend/app/api/billing.py b/backend/app/api/billing.py
index 851620df69f9c62fb3cab15feeedcafff44cc6bb..a1514308469dd90e936d1c2495aca396bc122ea2
--- a/backend/app/api/billing.py
+++ b/backend/app/api/billing.py
@@ -58,6 +58,56 @@
     return {"checkout_url": session.url}
 
 
+# Subscriptions
+@router.post("/subscribe")
+async def subscribe(user: User = Depends(require_auth)):
+    if not settings.STRIPE_SECRET_KEY or not settings.STRIPE_PRICE_PRO_MONTHLY:
+        raise HTTPException(503, "Stripe not configured")
+
+    # Ensure customer exists
+    if not user.stripe_customer_id:
+        cust = stripe.Customer.create(email=user.email, name=user.name or None)
+        user.stripe_customer_id = cust.id
+        # Persist customer id
+        # Use a quick update via SQLAlchemy session on dependency side
+        from app.core.deps import get_db_session  # avoid circular import
+        # FastAPI won't let us depend here; defer to webhook to persist if necessary
+        # However, in typical dependency injection, User is attached to a session and flush works
+        try:
+            # Try to flush via bound session if available
+            # This attribute exists when loaded via SQLAlchemy session
+            object_session = getattr(user, "_sa_instance_state", None)
+            if object_session is not None and object_session.session is not None:
+                await object_session.session.flush()
+        except Exception:
+            pass
+
+    # Create Checkout Session for subscription
+    session = stripe.checkout.Session.create(
+        mode="subscription",
+        line_items=[{"price": settings.STRIPE_PRICE_PRO_MONTHLY, "quantity": 1}],
+        success_url=f"{settings.FRONTEND_URL}/billing",
+        cancel_url=f"{settings.FRONTEND_URL}/billing",
+        customer=user.stripe_customer_id,
+        client_reference_id=str(user.id),
+    )
+    return {"checkout_url": session.url}
+
+
+@router.post("/portal")
+async def customer_portal(user: User = Depends(require_auth)):
+    if not settings.STRIPE_SECRET_KEY:
+        raise HTTPException(503, "Stripe not configured")
+    if not user.stripe_customer_id:
+        raise HTTPException(400, "No Stripe customer for user")
+
+    portal = stripe.billing_portal.Session.create(
+        customer=user.stripe_customer_id,
+        return_url=f"{settings.FRONTEND_URL}/billing",
+    )
+    return {"portal_url": portal.url}
+
+
 @router.post("/webhook")
 async def stripe_webhook(request: Request, db: AsyncSession = Depends(get_db_session)):
     payload = await request.body()
@@ -85,70 +135,196 @@
             logger.error("Invalid event structure: missing data.object")
             return {"received": True}
 
-        # Parse and validate client_reference_id (user_id)
-        try:
-            client_ref = session.get("client_reference_id")
-            if not client_ref:
-                logger.error("Missing client_reference_id in checkout session")
+        mode = session.get("mode")
+
+        # Handle subscription checkout
+        if mode == "subscription":
+            try:
+                client_ref = session.get("client_reference_id")
+                if not client_ref:
+                    logger.error("Missing client_reference_id in subscription session")
+                    return {"received": True}
+                user_id = uuid.UUID(client_ref)
+            except (ValueError, TypeError) as e:
+                logger.error("Invalid client_reference_id: %s", e)
+                return {"received": True}
+
+            user = await db.get(User, user_id)
+            if not user:
+                logger.warning("Subscription completed for non-existent user %s", user_id)
                 return {"received": True}
-            user_id = uuid.UUID(client_ref)
-        except (ValueError, TypeError) as e:
-            logger.error("Invalid client_reference_id: %s", e)
+
+            subscription_id = session.get("subscription")
+            customer_id = session.get("customer")
+
+            # Update user plan and subscription/customer ids
+            user.plan = "pro"
+            if subscription_id:
+                user.stripe_subscription_id = subscription_id
+            if customer_id and not user.stripe_customer_id:
+                user.stripe_customer_id = customer_id
+
+            # Idempotency: only one monthly grant per subscription id at start
+            existing = await db.scalar(
+                select(CreditLedger).where(
+                    CreditLedger.ref_type == "stripe_subscription",
+                    CreditLedger.ref_id == (subscription_id or ""),
+                )
+            )
+
+            if not existing:
+                try:
+                    await credit_credits(
+                        db,
+                        user_id=user.id,
+                        amount=int(settings.PLAN_PRO_MONTHLY_CREDITS or 0),
+                        reason="monthly_allowance",
+                        ref_type="stripe_subscription",
+                        ref_id=subscription_id or "",
+                    )
+                    await db.commit()
+                    logger.info(
+                        "Subscription start credits granted: user_id=%s, subscription=%s",
+                        user.id,
+                        subscription_id,
+                    )
+                except Exception as e:
+                    await db.rollback()
+                    logger.error("Failed to grant subscription start credits: %s", e)
+                    raise HTTPException(500, "Database error")
+            else:
+                await db.commit()
+
             return {"received": True}
 
-        # Parse and validate credits amount
-        try:
-            metadata = session.get("metadata", {})
-            credits_str = metadata.get("credits")
-            if not credits_str:
-                logger.error("Missing credits in session metadata")
+        # Handle one-time credit pack checkout
+        if mode == "payment":
+            # Parse and validate client_reference_id (user_id)
+            try:
+                client_ref = session.get("client_reference_id")
+                if not client_ref:
+                    logger.error("Missing client_reference_id in checkout session")
+                    return {"received": True}
+                user_id = uuid.UUID(client_ref)
+            except (ValueError, TypeError) as e:
+                logger.error("Invalid client_reference_id: %s", e)
+                return {"received": True}
+
+            # Parse and validate credits amount
+            try:
+                metadata = session.get("metadata", {})
+                credits_str = metadata.get("credits")
+                if not credits_str:
+                    logger.error("Missing credits in session metadata")
+                    return {"received": True}
+                credits = int(credits_str)
+                if credits <= 0:
+                    logger.error("Invalid credits amount: %d", credits)
+                    return {"received": True}
+            except (ValueError, TypeError) as e:
+                logger.error("Cannot parse credits from metadata: %s", e)
+                return {"received": True}
+
+            # Get payment_intent for idempotency
+            payment_intent = session.get("payment_intent")
+            if not payment_intent:
+                logger.warning("Checkout session has no payment_intent, skipping for safety")
                 return {"received": True}
-            credits = int(credits_str)
-            if credits <= 0:
-                logger.error("Invalid credits amount: %d", credits)
+
+            # Verify user exists
+            user = await db.get(User, user_id)
+            if not user:
+                logger.warning("Webhook for non-existent user %s", user_id)
                 return {"received": True}
-        except (ValueError, TypeError) as e:
-            logger.error("Cannot parse credits from metadata: %s", e)
+
+            # Idempotency check
+            existing = await db.scalar(
+                select(CreditLedger).where(
+                    CreditLedger.ref_type == "stripe_payment",
+                    CreditLedger.ref_id == payment_intent,
+                )
+            )
+
+            if not existing:
+                try:
+                    await credit_credits(
+                        db,
+                        user_id,
+                        credits,
+                        reason="purchase",
+                        ref_type="stripe_payment",
+                        ref_id=payment_intent,
+                    )
+                    await db.commit()
+                    logger.info(
+                        "Credits granted: user_id=%s, credits=%d, payment_intent=%s",
+                        user_id,
+                        credits,
+                        payment_intent,
+                    )
+                except Exception as e:
+                    await db.rollback()
+                    logger.error("Failed to grant credits: %s", e)
+                    # Return 5xx so Stripe retries
+                    raise HTTPException(500, "Database error")
+            return {"received": True}
+
+    elif event["type"] == "invoice.payment_succeeded":
+    
+        obj = event.get("data", {}).get("object")
+        if not obj or not isinstance(obj, dict):
             return {"received": True}
 
-        # Get payment_intent for idempotency
-        payment_intent = session.get("payment_intent")
-        if not payment_intent:
-            logger.warning("Checkout session has no payment_intent, skipping for safety")
+        invoice_id = obj.get("id")
+        customer_id = obj.get("customer")
+        if not invoice_id or not customer_id:
             return {"received": True}
 
-        # Verify user exists
-        user = await db.get(User, user_id)
+        # Find user by customer id
+        user = await db.scalar(select(User).where(User.stripe_customer_id == customer_id))
         if not user:
-            logger.warning("Webhook for non-existent user %s", user_id)
             return {"received": True}
 
-        # Idempotency check
+        # Idempotency: ensure we haven't granted for this invoice
         existing = await db.scalar(
             select(CreditLedger).where(
-                CreditLedger.ref_type == "stripe_payment",
-                CreditLedger.ref_id == payment_intent,
+                CreditLedger.ref_type == "stripe_invoice",
+                CreditLedger.ref_id == invoice_id,
             )
         )
-
         if not existing:
             try:
                 await credit_credits(
                     db,
-                    user_id,
-                    credits,
-                    reason="purchase",
-                    ref_type="stripe_payment",
-                    ref_id=payment_intent,
+                    user_id=user.id,
+                    amount=int(settings.PLAN_PRO_MONTHLY_CREDITS or 0),
+                    reason="monthly_allowance",
+                    ref_type="stripe_invoice",
+                    ref_id=invoice_id,
                 )
                 await db.commit()
-                logger.info("Credits granted: user_id=%s, credits=%d, payment_intent=%s",
-                           user_id, credits, payment_intent)
             except Exception as e:
                 await db.rollback()
-                logger.error("Failed to grant credits: %s", e)
-                # Return 5xx so Stripe retries
+                logger.error("Failed to grant monthly credits on invoice: %s", e)
                 raise HTTPException(500, "Database error")
+        return {"received": True}
+
+    elif event["type"] == "customer.subscription.deleted":
+        obj = event.get("data", {}).get("object")
+        if not obj or not isinstance(obj, dict):
+            return {"received": True}
+
+        customer_id = obj.get("customer")
+        if not customer_id:
+            return {"received": True}
+
+        user = await db.scalar(select(User).where(User.stripe_customer_id == customer_id))
+        if not user:
+            return {"received": True}
+
+        user.plan = "free"
+        user.stripe_subscription_id = None
+        await db.commit()
+        return {"received": True}
 
     return {"received": True}
-
diff --git a/backend/app/api/chat.py b/backend/app/api/chat.py
index 71fc751fa90239dfe90bf76e3b30a7aa686d0c3f..d52dc47026e109df283984196581d417a4fea1dc
--- a/backend/app/api/chat.py
+++ b/backend/app/api/chat.py
@@ -133,6 +133,9 @@
 
     # If authenticated, ensure sufficient credits before opening stream
     if user is not None:
+        from app.services.credit_service import ensure_monthly_credits
+        await ensure_monthly_credits(db, user)
+        await db.commit()
         balance = await credit_service.get_user_credits(db, user.id)
         if balance < credit_service.MIN_CREDITS_FOR_CHAT:
             return JSONResponse(
diff --git a/backend/app/core/config.py b/backend/app/core/config.py
index 830f599a7b1ff02463684a9e84e90adfd6318cc1..a8eef6c5b4145c3710d46395bf26465dec42b4a7
--- a/backend/app/core/config.py
+++ b/backend/app/core/config.py
@@ -75,6 +75,10 @@
     CREDITS_PRO: int = 200000
     CREDITS_ENTERPRISE: int = 1000000
     SIGNUP_BONUS_CREDITS: int = 10000
+    # Subscription tiers
+    PLAN_FREE_MONTHLY_CREDITS: int = 10000
+    PLAN_PRO_MONTHLY_CREDITS: int = 100000
+    STRIPE_PRICE_PRO_MONTHLY: str = ''
 
     model_config = SettingsConfigDict(env_file=".env", env_file_encoding="utf-8", case_sensitive=False)
 
diff --git a/backend/app/models/tables.py b/backend/app/models/tables.py
index 2eb9239abb3f01f8a4103944db02efcb27f20149..9caeafd2d73fb05604695d962f9a0dc191da0bf2
--- a/backend/app/models/tables.py
+++ b/backend/app/models/tables.py
@@ -163,6 +163,10 @@
     email_verified: Mapped[Optional[datetime]] = mapped_column(sa.DateTime(timezone=True))
     credits_balance: Mapped[int] = mapped_column(sa.Integer, nullable=False, server_default=sa.text("0"))
     signup_bonus_granted_at: Mapped[Optional[datetime]] = mapped_column(sa.DateTime(timezone=True))
+    plan: Mapped[str] = mapped_column(sa.String(20), nullable=False, server_default=sa.text("'free'"))
+    stripe_customer_id: Mapped[Optional[str]] = mapped_column(sa.String(255))
+    stripe_subscription_id: Mapped[Optional[str]] = mapped_column(sa.String(255))
+    monthly_credits_granted_at: Mapped[Optional[datetime]] = mapped_column(sa.DateTime(timezone=True))
     created_at: Mapped[datetime] = mapped_column(sa.DateTime(timezone=True), server_default=sa.text("now()"))
     updated_at: Mapped[datetime] = mapped_column(
         sa.DateTime(timezone=True), server_default=sa.text("now()"), onupdate=sa.func.now()
diff --git a/backend/app/services/credit_service.py b/backend/app/services/credit_service.py
index d89772b0418d1ebe1a79bba3de65f0112a550adb..a599453a961fb9222db98928201795c4fa4e574b
--- a/backend/app/services/credit_service.py
+++ b/backend/app/services/credit_service.py
@@ -7,6 +7,7 @@
 from sqlalchemy.ext.asyncio import AsyncSession
 
 from app.models.tables import CreditLedger, UsageRecord, User
+from app.core.config import settings
 
 
 # Token-to-credit rates by model tier
@@ -144,3 +145,56 @@
     db.add(usage)
     return usage
 
+
+async def ensure_monthly_credits(db: AsyncSession, user: User) -> None:
+    """Grant monthly credits if last grant was over 30 days ago.
+
+    Idempotency: checks CreditLedger for any recent 'monthly_allowance' within 30 days.
+    """
+    from datetime import datetime, timedelta, timezone
+
+    # Determine if grant needed based on timestamp
+    now = datetime.now(timezone.utc)
+    last = user.monthly_credits_granted_at
+    needs_grant = last is None or (now - last) >= timedelta(days=30)
+    if not needs_grant:
+        return
+
+    # Check ledger for idempotency within last 30 days
+    cutoff = now - timedelta(days=30)
+    existing = await db.scalar(
+        sa.select(CreditLedger)
+        .where(CreditLedger.user_id == user.id)
+        .where(CreditLedger.reason == "monthly_allowance")
+        .where(CreditLedger.created_at >= cutoff)
+    )
+    if existing:
+        # Still update marker to avoid repeatedly checking in future requests
+        user.monthly_credits_granted_at = now
+        await db.flush()
+        return
+
+    # Determine allowance by plan
+    plan = (user.plan or "free").lower()
+    if plan == "pro":
+        allowance = int(settings.PLAN_PRO_MONTHLY_CREDITS or 0)
+    else:
+        allowance = int(settings.PLAN_FREE_MONTHLY_CREDITS or 0)
+
+    if allowance <= 0:
+        # Nothing to grant
+        user.monthly_credits_granted_at = now
+        await db.flush()
+        return
+
+    # Grant credits and update marker
+    await credit_credits(
+        db,
+        user_id=user.id,
+        amount=allowance,
+        reason="monthly_allowance",
+        ref_type=None,
+        ref_id=None,
+    )
+    user.monthly_credits_granted_at = now
+    await db.flush()


thinking
**Fixing the portal endpoint**

I see that the /portal endpoint doesn’t update the database, which means there’s no need for a database in this case. However, requiring the session isn’t necessarily a problem either. Keeping it simple sounds like a good approach. I'll just look into patching it again to make sure everything runs smoothly. It's always nice to simplify wherever possible, isn’t it? Let's get it done!
file update
M /Users/mayijie/Projects/Code/010_DocTalk/backend/app/api/billing.py
@@ -62,3 +62,6 @@
 @router.post("/subscribe")
-async def subscribe(user: User = Depends(require_auth)):
+async def subscribe(
+    user: User = Depends(require_auth),
+    db: AsyncSession = Depends(get_db_session),
+):
     if not settings.STRIPE_SECRET_KEY or not settings.STRIPE_PRICE_PRO_MONTHLY:
@@ -70,15 +73,3 @@
         user.stripe_customer_id = cust.id
-        # Persist customer id
-        # Use a quick update via SQLAlchemy session on dependency side
-        from app.core.deps import get_db_session  # avoid circular import
-        # FastAPI won't let us depend here; defer to webhook to persist if necessary
-        # However, in typical dependency injection, User is attached to a session and flush works
-        try:
-            # Try to flush via bound session if available
-            # This attribute exists when loaded via SQLAlchemy session
-            object_session = getattr(user, "_sa_instance_state", None)
-            if object_session is not None and object_session.session is not None:
-                await object_session.session.flush()
-        except Exception:
-            pass
+        await db.flush()
 
apply_patch(auto_approved=true) exited 0 in 79ms:
Success. Updated the following files:
M backend/app/api/billing.py
file update:
diff --git a/backend/alembic/versions/20260206_0004_add_subscription_fields.py b/backend/alembic/versions/20260206_0004_add_subscription_fields.py
new file mode 100644
index 0000000000000000000000000000000000000000..f84be09226785ea3dbc1b413b3cfd2cb07dff81e
--- /dev/null
+++ b/backend/alembic/versions/20260206_0004_add_subscription_fields.py
@@ -0,0 +1,38 @@
+"""add subscription fields to users
+
+Revision ID: d4e5f6a7b8c9
+Revises: c3d4e5f6a7b8
+Create Date: 2026-02-06 00:40:00
+
+"""
+from __future__ import annotations
+
+from alembic import op
+import sqlalchemy as sa
+
+
+# revision identifiers, used by Alembic.
+revision = "d4e5f6a7b8c9"
+down_revision = "c3d4e5f6a7b8"
+branch_labels = None
+depends_on = None
+
+
+def upgrade() -> None:
+    # Add subscription-related columns to users
+    op.add_column(
+        "users",
+        sa.Column("plan", sa.String(length=20), nullable=False, server_default=sa.text("'free'")),
+    )
+    op.add_column("users", sa.Column("stripe_customer_id", sa.String(length=255), nullable=True))
+    op.add_column("users", sa.Column("stripe_subscription_id", sa.String(length=255), nullable=True))
+    op.add_column("users", sa.Column("monthly_credits_granted_at", sa.DateTime(timezone=True), nullable=True))
+
+
+def downgrade() -> None:
+    # Drop subscription-related columns from users
+    op.drop_column("users", "monthly_credits_granted_at")
+    op.drop_column("users", "stripe_subscription_id")
+    op.drop_column("users", "stripe_customer_id")
+    op.drop_column("users", "plan")
+
diff --git a/backend/app/api/billing.py b/backend/app/api/billing.py
index 851620df69f9c62fb3cab15feeedcafff44cc6bb..75dba29075fddfea6e7cd69d46e92d923d861ebb
--- a/backend/app/api/billing.py
+++ b/backend/app/api/billing.py
@@ -58,6 +58,47 @@
     return {"checkout_url": session.url}
 
 
+# Subscriptions
+@router.post("/subscribe")
+async def subscribe(
+    user: User = Depends(require_auth),
+    db: AsyncSession = Depends(get_db_session),
+):
+    if not settings.STRIPE_SECRET_KEY or not settings.STRIPE_PRICE_PRO_MONTHLY:
+        raise HTTPException(503, "Stripe not configured")
+
+    # Ensure customer exists
+    if not user.stripe_customer_id:
+        cust = stripe.Customer.create(email=user.email, name=user.name or None)
+        user.stripe_customer_id = cust.id
+        await db.flush()
+
+    # Create Checkout Session for subscription
+    session = stripe.checkout.Session.create(
+        mode="subscription",
+        line_items=[{"price": settings.STRIPE_PRICE_PRO_MONTHLY, "quantity": 1}],
+        success_url=f"{settings.FRONTEND_URL}/billing",
+        cancel_url=f"{settings.FRONTEND_URL}/billing",
+        customer=user.stripe_customer_id,
+        client_reference_id=str(user.id),
+    )
+    return {"checkout_url": session.url}
+
+
+@router.post("/portal")
+async def customer_portal(user: User = Depends(require_auth)):
+    if not settings.STRIPE_SECRET_KEY:
+        raise HTTPException(503, "Stripe not configured")
+    if not user.stripe_customer_id:
+        raise HTTPException(400, "No Stripe customer for user")
+
+    portal = stripe.billing_portal.Session.create(
+        customer=user.stripe_customer_id,
+        return_url=f"{settings.FRONTEND_URL}/billing",
+    )
+    return {"portal_url": portal.url}
+
+
 @router.post("/webhook")
 async def stripe_webhook(request: Request, db: AsyncSession = Depends(get_db_session)):
     payload = await request.body()
@@ -85,70 +126,196 @@
             logger.error("Invalid event structure: missing data.object")
             return {"received": True}
 
-        # Parse and validate client_reference_id (user_id)
-        try:
-            client_ref = session.get("client_reference_id")
-            if not client_ref:
-                logger.error("Missing client_reference_id in checkout session")
+        mode = session.get("mode")
+
+        # Handle subscription checkout
+        if mode == "subscription":
+            try:
+                client_ref = session.get("client_reference_id")
+                if not client_ref:
+                    logger.error("Missing client_reference_id in subscription session")
+                    return {"received": True}
+                user_id = uuid.UUID(client_ref)
+            except (ValueError, TypeError) as e:
+                logger.error("Invalid client_reference_id: %s", e)
+                return {"received": True}
+
+            user = await db.get(User, user_id)
+            if not user:
+                logger.warning("Subscription completed for non-existent user %s", user_id)
                 return {"received": True}
-            user_id = uuid.UUID(client_ref)
-        except (ValueError, TypeError) as e:
-            logger.error("Invalid client_reference_id: %s", e)
+
+            subscription_id = session.get("subscription")
+            customer_id = session.get("customer")
+
+            # Update user plan and subscription/customer ids
+            user.plan = "pro"
+            if subscription_id:
+                user.stripe_subscription_id = subscription_id
+            if customer_id and not user.stripe_customer_id:
+                user.stripe_customer_id = customer_id
+
+            # Idempotency: only one monthly grant per subscription id at start
+            existing = await db.scalar(
+                select(CreditLedger).where(
+                    CreditLedger.ref_type == "stripe_subscription",
+                    CreditLedger.ref_id == (subscription_id or ""),
+                )
+            )
+
+            if not existing:
+                try:
+                    await credit_credits(
+                        db,
+                        user_id=user.id,
+                        amount=int(settings.PLAN_PRO_MONTHLY_CREDITS or 0),
+                        reason="monthly_allowance",
+                        ref_type="stripe_subscription",
+                        ref_id=subscription_id or "",
+                    )
+                    await db.commit()
+                    logger.info(
+                        "Subscription start credits granted: user_id=%s, subscription=%s",
+                        user.id,
+                        subscription_id,
+                    )
+                except Exception as e:
+                    await db.rollback()
+                    logger.error("Failed to grant subscription start credits: %s", e)
+                    raise HTTPException(500, "Database error")
+            else:
+                await db.commit()
+
             return {"received": True}
 
-        # Parse and validate credits amount
-        try:
-            metadata = session.get("metadata", {})
-            credits_str = metadata.get("credits")
-            if not credits_str:
-                logger.error("Missing credits in session metadata")
+        # Handle one-time credit pack checkout
+        if mode == "payment":
+            # Parse and validate client_reference_id (user_id)
+            try:
+                client_ref = session.get("client_reference_id")
+                if not client_ref:
+                    logger.error("Missing client_reference_id in checkout session")
+                    return {"received": True}
+                user_id = uuid.UUID(client_ref)
+            except (ValueError, TypeError) as e:
+                logger.error("Invalid client_reference_id: %s", e)
                 return {"received": True}
-            credits = int(credits_str)
-            if credits <= 0:
-                logger.error("Invalid credits amount: %d", credits)
+
+            # Parse and validate credits amount
+            try:
+                metadata = session.get("metadata", {})
+                credits_str = metadata.get("credits")
+                if not credits_str:
+                    logger.error("Missing credits in session metadata")
+                    return {"received": True}
+                credits = int(credits_str)
+                if credits <= 0:
+                    logger.error("Invalid credits amount: %d", credits)
+                    return {"received": True}
+            except (ValueError, TypeError) as e:
+                logger.error("Cannot parse credits from metadata: %s", e)
+                return {"received": True}
+
+            # Get payment_intent for idempotency
+            payment_intent = session.get("payment_intent")
+            if not payment_intent:
+                logger.warning("Checkout session has no payment_intent, skipping for safety")
                 return {"received": True}
-        except (ValueError, TypeError) as e:
-            logger.error("Cannot parse credits from metadata: %s", e)
+
+            # Verify user exists
+            user = await db.get(User, user_id)
+            if not user:
+                logger.warning("Webhook for non-existent user %s", user_id)
+                return {"received": True}
+
+            # Idempotency check
+            existing = await db.scalar(
+                select(CreditLedger).where(
+                    CreditLedger.ref_type == "stripe_payment",
+                    CreditLedger.ref_id == payment_intent,
+                )
+            )
+
+            if not existing:
+                try:
+                    await credit_credits(
+                        db,
+                        user_id,
+                        credits,
+                        reason="purchase",
+                        ref_type="stripe_payment",
+                        ref_id=payment_intent,
+                    )
+                    await db.commit()
+                    logger.info(
+                        "Credits granted: user_id=%s, credits=%d, payment_intent=%s",
+                        user_id,
+                        credits,
+                        payment_intent,
+                    )
+                except Exception as e:
+                    await db.rollback()
+                    logger.error("Failed to grant credits: %s", e)
+                    # Return 5xx so Stripe retries
+                    raise HTTPException(500, "Database error")
+            return {"received": True}
+
+    elif event["type"] == "invoice.payment_succeeded":
+    
+        obj = event.get("data", {}).get("object")
+        if not obj or not isinstance(obj, dict):
             return {"received": True}
 
-        # Get payment_intent for idempotency
-        payment_intent = session.get("payment_intent")
-        if not payment_intent:
-            logger.warning("Checkout session has no payment_intent, skipping for safety")
+        invoice_id = obj.get("id")
+        customer_id = obj.get("customer")
+        if not invoice_id or not customer_id:
             return {"received": True}
 
-        # Verify user exists
-        user = await db.get(User, user_id)
+        # Find user by customer id
+        user = await db.scalar(select(User).where(User.stripe_customer_id == customer_id))
         if not user:
-            logger.warning("Webhook for non-existent user %s", user_id)
             return {"received": True}
 
-        # Idempotency check
+        # Idempotency: ensure we haven't granted for this invoice
         existing = await db.scalar(
             select(CreditLedger).where(
-                CreditLedger.ref_type == "stripe_payment",
-                CreditLedger.ref_id == payment_intent,
+                CreditLedger.ref_type == "stripe_invoice",
+                CreditLedger.ref_id == invoice_id,
             )
         )
-
         if not existing:
             try:
                 await credit_credits(
                     db,
-                    user_id,
-                    credits,
-                    reason="purchase",
-                    ref_type="stripe_payment",
-                    ref_id=payment_intent,
+                    user_id=user.id,
+                    amount=int(settings.PLAN_PRO_MONTHLY_CREDITS or 0),
+                    reason="monthly_allowance",
+                    ref_type="stripe_invoice",
+                    ref_id=invoice_id,
                 )
                 await db.commit()
-                logger.info("Credits granted: user_id=%s, credits=%d, payment_intent=%s",
-                           user_id, credits, payment_intent)
             except Exception as e:
                 await db.rollback()
-                logger.error("Failed to grant credits: %s", e)
-                # Return 5xx so Stripe retries
+                logger.error("Failed to grant monthly credits on invoice: %s", e)
                 raise HTTPException(500, "Database error")
+        return {"received": True}
+
+    elif event["type"] == "customer.subscription.deleted":
+        obj = event.get("data", {}).get("object")
+        if not obj or not isinstance(obj, dict):
+            return {"received": True}
 
-    return {"received": True}
+        customer_id = obj.get("customer")
+        if not customer_id:
+            return {"received": True}
 
+        user = await db.scalar(select(User).where(User.stripe_customer_id == customer_id))
+        if not user:
+            return {"received": True}
+
+        user.plan = "free"
+        user.stripe_subscription_id = None
+        await db.commit()
+        return {"received": True}
+
+    return {"received": True}
diff --git a/backend/app/api/chat.py b/backend/app/api/chat.py
index 71fc751fa90239dfe90bf76e3b30a7aa686d0c3f..d52dc47026e109df283984196581d417a4fea1dc
--- a/backend/app/api/chat.py
+++ b/backend/app/api/chat.py
@@ -133,6 +133,9 @@
 
     # If authenticated, ensure sufficient credits before opening stream
     if user is not None:
+        from app.services.credit_service import ensure_monthly_credits
+        await ensure_monthly_credits(db, user)
+        await db.commit()
         balance = await credit_service.get_user_credits(db, user.id)
         if balance < credit_service.MIN_CREDITS_FOR_CHAT:
             return JSONResponse(
diff --git a/backend/app/core/config.py b/backend/app/core/config.py
index 830f599a7b1ff02463684a9e84e90adfd6318cc1..a8eef6c5b4145c3710d46395bf26465dec42b4a7
--- a/backend/app/core/config.py
+++ b/backend/app/core/config.py
@@ -75,6 +75,10 @@
     CREDITS_PRO: int = 200000
     CREDITS_ENTERPRISE: int = 1000000
     SIGNUP_BONUS_CREDITS: int = 10000
+    # Subscription tiers
+    PLAN_FREE_MONTHLY_CREDITS: int = 10000
+    PLAN_PRO_MONTHLY_CREDITS: int = 100000
+    STRIPE_PRICE_PRO_MONTHLY: str = ''
 
     model_config = SettingsConfigDict(env_file=".env", env_file_encoding="utf-8", case_sensitive=False)
 
diff --git a/backend/app/models/tables.py b/backend/app/models/tables.py
index 2eb9239abb3f01f8a4103944db02efcb27f20149..9caeafd2d73fb05604695d962f9a0dc191da0bf2
--- a/backend/app/models/tables.py
+++ b/backend/app/models/tables.py
@@ -163,6 +163,10 @@
     email_verified: Mapped[Optional[datetime]] = mapped_column(sa.DateTime(timezone=True))
     credits_balance: Mapped[int] = mapped_column(sa.Integer, nullable=False, server_default=sa.text("0"))
     signup_bonus_granted_at: Mapped[Optional[datetime]] = mapped_column(sa.DateTime(timezone=True))
+    plan: Mapped[str] = mapped_column(sa.String(20), nullable=False, server_default=sa.text("'free'"))
+    stripe_customer_id: Mapped[Optional[str]] = mapped_column(sa.String(255))
+    stripe_subscription_id: Mapped[Optional[str]] = mapped_column(sa.String(255))
+    monthly_credits_granted_at: Mapped[Optional[datetime]] = mapped_column(sa.DateTime(timezone=True))
     created_at: Mapped[datetime] = mapped_column(sa.DateTime(timezone=True), server_default=sa.text("now()"))
     updated_at: Mapped[datetime] = mapped_column(
         sa.DateTime(timezone=True), server_default=sa.text("now()"), onupdate=sa.func.now()
diff --git a/backend/app/services/credit_service.py b/backend/app/services/credit_service.py
index d89772b0418d1ebe1a79bba3de65f0112a550adb..a599453a961fb9222db98928201795c4fa4e574b
--- a/backend/app/services/credit_service.py
+++ b/backend/app/services/credit_service.py
@@ -7,6 +7,7 @@
 from sqlalchemy.ext.asyncio import AsyncSession
 
 from app.models.tables import CreditLedger, UsageRecord, User
+from app.core.config import settings
 
 
 # Token-to-credit rates by model tier
@@ -144,3 +145,56 @@
     db.add(usage)
     return usage
 
+
+async def ensure_monthly_credits(db: AsyncSession, user: User) -> None:
+    """Grant monthly credits if last grant was over 30 days ago.
+
+    Idempotency: checks CreditLedger for any recent 'monthly_allowance' within 30 days.
+    """
+    from datetime import datetime, timedelta, timezone
+
+    # Determine if grant needed based on timestamp
+    now = datetime.now(timezone.utc)
+    last = user.monthly_credits_granted_at
+    needs_grant = last is None or (now - last) >= timedelta(days=30)
+    if not needs_grant:
+        return
+
+    # Check ledger for idempotency within last 30 days
+    cutoff = now - timedelta(days=30)
+    existing = await db.scalar(
+        sa.select(CreditLedger)
+        .where(CreditLedger.user_id == user.id)
+        .where(CreditLedger.reason == "monthly_allowance")
+        .where(CreditLedger.created_at >= cutoff)
+    )
+    if existing:
+        # Still update marker to avoid repeatedly checking in future requests
+        user.monthly_credits_granted_at = now
+        await db.flush()
+        return
+
+    # Determine allowance by plan
+    plan = (user.plan or "free").lower()
+    if plan == "pro":
+        allowance = int(settings.PLAN_PRO_MONTHLY_CREDITS or 0)
+    else:
+        allowance = int(settings.PLAN_FREE_MONTHLY_CREDITS or 0)
+
+    if allowance <= 0:
+        # Nothing to grant
+        user.monthly_credits_granted_at = now
+        await db.flush()
+        return
+
+    # Grant credits and update marker
+    await credit_credits(
+        db,
+        user_id=user.id,
+        amount=allowance,
+        reason="monthly_allowance",
+        ref_type=None,
+        ref_id=None,
+    )
+    user.monthly_credits_granted_at = now
+    await db.flush()

file update:
diff --git a/backend/alembic/versions/20260206_0004_add_subscription_fields.py b/backend/alembic/versions/20260206_0004_add_subscription_fields.py
new file mode 100644
index 0000000000000000000000000000000000000000..f84be09226785ea3dbc1b413b3cfd2cb07dff81e
--- /dev/null
+++ b/backend/alembic/versions/20260206_0004_add_subscription_fields.py
@@ -0,0 +1,38 @@
+"""add subscription fields to users
+
+Revision ID: d4e5f6a7b8c9
+Revises: c3d4e5f6a7b8
+Create Date: 2026-02-06 00:40:00
+
+"""
+from __future__ import annotations
+
+from alembic import op
+import sqlalchemy as sa
+
+
+# revision identifiers, used by Alembic.
+revision = "d4e5f6a7b8c9"
+down_revision = "c3d4e5f6a7b8"
+branch_labels = None
+depends_on = None
+
+
+def upgrade() -> None:
+    # Add subscription-related columns to users
+    op.add_column(
+        "users",
+        sa.Column("plan", sa.String(length=20), nullable=False, server_default=sa.text("'free'")),
+    )
+    op.add_column("users", sa.Column("stripe_customer_id", sa.String(length=255), nullable=True))
+    op.add_column("users", sa.Column("stripe_subscription_id", sa.String(length=255), nullable=True))
+    op.add_column("users", sa.Column("monthly_credits_granted_at", sa.DateTime(timezone=True), nullable=True))
+
+
+def downgrade() -> None:
+    # Drop subscription-related columns from users
+    op.drop_column("users", "monthly_credits_granted_at")
+    op.drop_column("users", "stripe_subscription_id")
+    op.drop_column("users", "stripe_customer_id")
+    op.drop_column("users", "plan")
+
diff --git a/backend/app/api/billing.py b/backend/app/api/billing.py
index 851620df69f9c62fb3cab15feeedcafff44cc6bb..75dba29075fddfea6e7cd69d46e92d923d861ebb
--- a/backend/app/api/billing.py
+++ b/backend/app/api/billing.py
@@ -58,6 +58,47 @@
     return {"checkout_url": session.url}
 
 
+# Subscriptions
+@router.post("/subscribe")
+async def subscribe(
+    user: User = Depends(require_auth),
+    db: AsyncSession = Depends(get_db_session),
+):
+    if not settings.STRIPE_SECRET_KEY or not settings.STRIPE_PRICE_PRO_MONTHLY:
+        raise HTTPException(503, "Stripe not configured")
+
+    # Ensure customer exists
+    if not user.stripe_customer_id:
+        cust = stripe.Customer.create(email=user.email, name=user.name or None)
+        user.stripe_customer_id = cust.id
+        await db.flush()
+
+    # Create Checkout Session for subscription
+    session = stripe.checkout.Session.create(
+        mode="subscription",
+        line_items=[{"price": settings.STRIPE_PRICE_PRO_MONTHLY, "quantity": 1}],
+        success_url=f"{settings.FRONTEND_URL}/billing",
+        cancel_url=f"{settings.FRONTEND_URL}/billing",
+        customer=user.stripe_customer_id,
+        client_reference_id=str(user.id),
+    )
+    return {"checkout_url": session.url}
+
+
+@router.post("/portal")
+async def customer_portal(user: User = Depends(require_auth)):
+    if not settings.STRIPE_SECRET_KEY:
+        raise HTTPException(503, "Stripe not configured")
+    if not user.stripe_customer_id:
+        raise HTTPException(400, "No Stripe customer for user")
+
+    portal = stripe.billing_portal.Session.create(
+        customer=user.stripe_customer_id,
+        return_url=f"{settings.FRONTEND_URL}/billing",
+    )
+    return {"portal_url": portal.url}
+
+
 @router.post("/webhook")
 async def stripe_webhook(request: Request, db: AsyncSession = Depends(get_db_session)):
     payload = await request.body()
@@ -85,70 +126,196 @@
             logger.error("Invalid event structure: missing data.object")
             return {"received": True}
 
-        # Parse and validate client_reference_id (user_id)
-        try:
-            client_ref = session.get("client_reference_id")
-            if not client_ref:
-                logger.error("Missing client_reference_id in checkout session")
+        mode = session.get("mode")
+
+        # Handle subscription checkout
+        if mode == "subscription":
+            try:
+                client_ref = session.get("client_reference_id")
+                if not client_ref:
+                    logger.error("Missing client_reference_id in subscription session")
+                    return {"received": True}
+                user_id = uuid.UUID(client_ref)
+            except (ValueError, TypeError) as e:
+                logger.error("Invalid client_reference_id: %s", e)
+                return {"received": True}
+
+            user = await db.get(User, user_id)
+            if not user:
+                logger.warning("Subscription completed for non-existent user %s", user_id)
                 return {"received": True}
-            user_id = uuid.UUID(client_ref)
-        except (ValueError, TypeError) as e:
-            logger.error("Invalid client_reference_id: %s", e)
+
+            subscription_id = session.get("subscription")
+            customer_id = session.get("customer")
+
+            # Update user plan and subscription/customer ids
+            user.plan = "pro"
+            if subscription_id:
+                user.stripe_subscription_id = subscription_id
+            if customer_id and not user.stripe_customer_id:
+                user.stripe_customer_id = customer_id
+
+            # Idempotency: only one monthly grant per subscription id at start
+            existing = await db.scalar(
+                select(CreditLedger).where(
+                    CreditLedger.ref_type == "stripe_subscription",
+                    CreditLedger.ref_id == (subscription_id or ""),
+                )
+            )
+
+            if not existing:
+                try:
+                    await credit_credits(
+                        db,
+                        user_id=user.id,
+                        amount=int(settings.PLAN_PRO_MONTHLY_CREDITS or 0),
+                        reason="monthly_allowance",
+                        ref_type="stripe_subscription",
+                        ref_id=subscription_id or "",
+                    )
+                    await db.commit()
+                    logger.info(
+                        "Subscription start credits granted: user_id=%s, subscription=%s",
+                        user.id,
+                        subscription_id,
+                    )
+                except Exception as e:
+                    await db.rollback()
+                    logger.error("Failed to grant subscription start credits: %s", e)
+                    raise HTTPException(500, "Database error")
+            else:
+                await db.commit()
+
             return {"received": True}
 
-        # Parse and validate credits amount
-        try:
-            metadata = session.get("metadata", {})
-            credits_str = metadata.get("credits")
-            if not credits_str:
-                logger.error("Missing credits in session metadata")
+        # Handle one-time credit pack checkout
+        if mode == "payment":
+            # Parse and validate client_reference_id (user_id)
+            try:
+                client_ref = session.get("client_reference_id")
+                if not client_ref:
+                    logger.error("Missing client_reference_id in checkout session")
+                    return {"received": True}
+                user_id = uuid.UUID(client_ref)
+            except (ValueError, TypeError) as e:
+                logger.error("Invalid client_reference_id: %s", e)
                 return {"received": True}
-            credits = int(credits_str)
-            if credits <= 0:
-                logger.error("Invalid credits amount: %d", credits)
+
+            # Parse and validate credits amount
+            try:
+                metadata = session.get("metadata", {})
+                credits_str = metadata.get("credits")
+                if not credits_str:
+                    logger.error("Missing credits in session metadata")
+                    return {"received": True}
+                credits = int(credits_str)
+                if credits <= 0:
+                    logger.error("Invalid credits amount: %d", credits)
+                    return {"received": True}
+            except (ValueError, TypeError) as e:
+                logger.error("Cannot parse credits from metadata: %s", e)
+                return {"received": True}
+
+            # Get payment_intent for idempotency
+            payment_intent = session.get("payment_intent")
+            if not payment_intent:
+                logger.warning("Checkout session has no payment_intent, skipping for safety")
                 return {"received": True}
-        except (ValueError, TypeError) as e:
-            logger.error("Cannot parse credits from metadata: %s", e)
+
+            # Verify user exists
+            user = await db.get(User, user_id)
+            if not user:
+                logger.warning("Webhook for non-existent user %s", user_id)
+                return {"received": True}
+
+            # Idempotency check
+            existing = await db.scalar(
+                select(CreditLedger).where(
+                    CreditLedger.ref_type == "stripe_payment",
+                    CreditLedger.ref_id == payment_intent,
+                )
+            )
+
+            if not existing:
+                try:
+                    await credit_credits(
+                        db,
+                        user_id,
+                        credits,
+                        reason="purchase",
+                        ref_type="stripe_payment",
+                        ref_id=payment_intent,
+                    )
+                    await db.commit()
+                    logger.info(
+                        "Credits granted: user_id=%s, credits=%d, payment_intent=%s",
+                        user_id,
+                        credits,
+                        payment_intent,
+                    )
+                except Exception as e:
+                    await db.rollback()
+                    logger.error("Failed to grant credits: %s", e)
+                    # Return 5xx so Stripe retries
+                    raise HTTPException(500, "Database error")
+            return {"received": True}
+
+    elif event["type"] == "invoice.payment_succeeded":
+    
+        obj = event.get("data", {}).get("object")
+        if not obj or not isinstance(obj, dict):
             return {"received": True}
 
-        # Get payment_intent for idempotency
-        payment_intent = session.get("payment_intent")
-        if not payment_intent:
-            logger.warning("Checkout session has no payment_intent, skipping for safety")
+        invoice_id = obj.get("id")
+        customer_id = obj.get("customer")
+        if not invoice_id or not customer_id:
             return {"received": True}
 
-        # Verify user exists
-        user = await db.get(User, user_id)
+        # Find user by customer id
+        user = await db.scalar(select(User).where(User.stripe_customer_id == customer_id))
         if not user:
-            logger.warning("Webhook for non-existent user %s", user_id)
             return {"received": True}
 
-        # Idempotency check
+        # Idempotency: ensure we haven't granted for this invoice
         existing = await db.scalar(
             select(CreditLedger).where(
-                CreditLedger.ref_type == "stripe_payment",
-                CreditLedger.ref_id == payment_intent,
+                CreditLedger.ref_type == "stripe_invoice",
+                CreditLedger.ref_id == invoice_id,
             )
         )
-
         if not existing:
             try:
                 await credit_credits(
                     db,
-                    user_id,
-                    credits,
-                    reason="purchase",
-                    ref_type="stripe_payment",
-                    ref_id=payment_intent,
+                    user_id=user.id,
+                    amount=int(settings.PLAN_PRO_MONTHLY_CREDITS or 0),
+                    reason="monthly_allowance",
+                    ref_type="stripe_invoice",
+                    ref_id=invoice_id,
                 )
                 await db.commit()
-                logger.info("Credits granted: user_id=%s, credits=%d, payment_intent=%s",
-                           user_id, credits, payment_intent)
             except Exception as e:
                 await db.rollback()
-                logger.error("Failed to grant credits: %s", e)
-                # Return 5xx so Stripe retries
+                logger.error("Failed to grant monthly credits on invoice: %s", e)
                 raise HTTPException(500, "Database error")
+        return {"received": True}
+
+    elif event["type"] == "customer.subscription.deleted":
+        obj = event.get("data", {}).get("object")
+        if not obj or not isinstance(obj, dict):
+            return {"received": True}
 
-    return {"received": True}
+        customer_id = obj.get("customer")
+        if not customer_id:
+            return {"received": True}
 
+        user = await db.scalar(select(User).where(User.stripe_customer_id == customer_id))
+        if not user:
+            return {"received": True}
+
+        user.plan = "free"
+        user.stripe_subscription_id = None
+        await db.commit()
+        return {"received": True}
+
+    return {"received": True}
diff --git a/backend/app/api/chat.py b/backend/app/api/chat.py
index 71fc751fa90239dfe90bf76e3b30a7aa686d0c3f..d52dc47026e109df283984196581d417a4fea1dc
--- a/backend/app/api/chat.py
+++ b/backend/app/api/chat.py
@@ -133,6 +133,9 @@
 
     # If authenticated, ensure sufficient credits before opening stream
     if user is not None:
+        from app.services.credit_service import ensure_monthly_credits
+        await ensure_monthly_credits(db, user)
+        await db.commit()
         balance = await credit_service.get_user_credits(db, user.id)
         if balance < credit_service.MIN_CREDITS_FOR_CHAT:
             return JSONResponse(
diff --git a/backend/app/core/config.py b/backend/app/core/config.py
index 830f599a7b1ff02463684a9e84e90adfd6318cc1..a8eef6c5b4145c3710d46395bf26465dec42b4a7
--- a/backend/app/core/config.py
+++ b/backend/app/core/config.py
@@ -75,6 +75,10 @@
     CREDITS_PRO: int = 200000
     CREDITS_ENTERPRISE: int = 1000000
     SIGNUP_BONUS_CREDITS: int = 10000
+    # Subscription tiers
+    PLAN_FREE_MONTHLY_CREDITS: int = 10000
+    PLAN_PRO_MONTHLY_CREDITS: int = 100000
+    STRIPE_PRICE_PRO_MONTHLY: str = ''
 
     model_config = SettingsConfigDict(env_file=".env", env_file_encoding="utf-8", case_sensitive=False)
 
diff --git a/backend/app/models/tables.py b/backend/app/models/tables.py
index 2eb9239abb3f01f8a4103944db02efcb27f20149..9caeafd2d73fb05604695d962f9a0dc191da0bf2
--- a/backend/app/models/tables.py
+++ b/backend/app/models/tables.py
@@ -163,6 +163,10 @@
     email_verified: Mapped[Optional[datetime]] = mapped_column(sa.DateTime(timezone=True))
     credits_balance: Mapped[int] = mapped_column(sa.Integer, nullable=False, server_default=sa.text("0"))
     signup_bonus_granted_at: Mapped[Optional[datetime]] = mapped_column(sa.DateTime(timezone=True))
+    plan: Mapped[str] = mapped_column(sa.String(20), nullable=False, server_default=sa.text("'free'"))
+    stripe_customer_id: Mapped[Optional[str]] = mapped_column(sa.String(255))
+    stripe_subscription_id: Mapped[Optional[str]] = mapped_column(sa.String(255))
+    monthly_credits_granted_at: Mapped[Optional[datetime]] = mapped_column(sa.DateTime(timezone=True))
     created_at: Mapped[datetime] = mapped_column(sa.DateTime(timezone=True), server_default=sa.text("now()"))
     updated_at: Mapped[datetime] = mapped_column(
         sa.DateTime(timezone=True), server_default=sa.text("now()"), onupdate=sa.func.now()
diff --git a/backend/app/services/credit_service.py b/backend/app/services/credit_service.py
index d89772b0418d1ebe1a79bba3de65f0112a550adb..a599453a961fb9222db98928201795c4fa4e574b
--- a/backend/app/services/credit_service.py
+++ b/backend/app/services/credit_service.py
@@ -7,6 +7,7 @@
 from sqlalchemy.ext.asyncio import AsyncSession
 
 from app.models.tables import CreditLedger, UsageRecord, User
+from app.core.config import settings
 
 
 # Token-to-credit rates by model tier
@@ -144,3 +145,56 @@
     db.add(usage)
     return usage
 
+
+async def ensure_monthly_credits(db: AsyncSession, user: User) -> None:
+    """Grant monthly credits if last grant was over 30 days ago.
+
+    Idempotency: checks CreditLedger for any recent 'monthly_allowance' within 30 days.
+    """
+    from datetime import datetime, timedelta, timezone
+
+    # Determine if grant needed based on timestamp
+    now = datetime.now(timezone.utc)
+    last = user.monthly_credits_granted_at
+    needs_grant = last is None or (now - last) >= timedelta(days=30)
+    if not needs_grant:
+        return
+
+    # Check ledger for idempotency within last 30 days
+    cutoff = now - timedelta(days=30)
+    existing = await db.scalar(
+        sa.select(CreditLedger)
+        .where(CreditLedger.user_id == user.id)
+        .where(CreditLedger.reason == "monthly_allowance")
+        .where(CreditLedger.created_at >= cutoff)
+    )
+    if existing:
+        # Still update marker to avoid repeatedly checking in future requests
+        user.monthly_credits_granted_at = now
+        await db.flush()
+        return
+
+    # Determine allowance by plan
+    plan = (user.plan or "free").lower()
+    if plan == "pro":
+        allowance = int(settings.PLAN_PRO_MONTHLY_CREDITS or 0)
+    else:
+        allowance = int(settings.PLAN_FREE_MONTHLY_CREDITS or 0)
+
+    if allowance <= 0:
+        # Nothing to grant
+        user.monthly_credits_granted_at = now
+        await db.flush()
+        return
+
+    # Grant credits and update marker
+    await credit_credits(
+        db,
+        user_id=user.id,
+        amount=allowance,
+        reason="monthly_allowance",
+        ref_type=None,
+        ref_id=None,
+    )
+    user.monthly_credits_granted_at = now
+    await db.flush()


thinking
**Considering database commits**

I'm thinking about whether we should commit after the changes or if flushing is enough. In earlier endpoints, a session object was created, and they committed afterward. For non-critical updates, flushing could suffice, but I'd prefer to commit to ensure everything is saved correctly. There’s no default commit, so I definitely should call `await db.commit()` after creating the checkout session to make sure the `stripe_customer_id` is saved in the database. Let's go ahead and add that commit!
file update
M /Users/mayijie/Projects/Code/010_DocTalk/backend/app/api/billing.py
@@ -73,3 +73,3 @@
         user.stripe_customer_id = cust.id
-        await db.flush()
+        await db.commit()
 
apply_patch(auto_approved=true) exited 0 in 80ms:
Success. Updated the following files:
M backend/app/api/billing.py
file update:
diff --git a/backend/alembic/versions/20260206_0004_add_subscription_fields.py b/backend/alembic/versions/20260206_0004_add_subscription_fields.py
new file mode 100644
index 0000000000000000000000000000000000000000..f84be09226785ea3dbc1b413b3cfd2cb07dff81e
--- /dev/null
+++ b/backend/alembic/versions/20260206_0004_add_subscription_fields.py
@@ -0,0 +1,38 @@
+"""add subscription fields to users
+
+Revision ID: d4e5f6a7b8c9
+Revises: c3d4e5f6a7b8
+Create Date: 2026-02-06 00:40:00
+
+"""
+from __future__ import annotations
+
+from alembic import op
+import sqlalchemy as sa
+
+
+# revision identifiers, used by Alembic.
+revision = "d4e5f6a7b8c9"
+down_revision = "c3d4e5f6a7b8"
+branch_labels = None
+depends_on = None
+
+
+def upgrade() -> None:
+    # Add subscription-related columns to users
+    op.add_column(
+        "users",
+        sa.Column("plan", sa.String(length=20), nullable=False, server_default=sa.text("'free'")),
+    )
+    op.add_column("users", sa.Column("stripe_customer_id", sa.String(length=255), nullable=True))
+    op.add_column("users", sa.Column("stripe_subscription_id", sa.String(length=255), nullable=True))
+    op.add_column("users", sa.Column("monthly_credits_granted_at", sa.DateTime(timezone=True), nullable=True))
+
+
+def downgrade() -> None:
+    # Drop subscription-related columns from users
+    op.drop_column("users", "monthly_credits_granted_at")
+    op.drop_column("users", "stripe_subscription_id")
+    op.drop_column("users", "stripe_customer_id")
+    op.drop_column("users", "plan")
+
diff --git a/backend/app/api/billing.py b/backend/app/api/billing.py
index 851620df69f9c62fb3cab15feeedcafff44cc6bb..f99355cf848497a82c150ed57c5c5b2c20aa5e2e
--- a/backend/app/api/billing.py
+++ b/backend/app/api/billing.py
@@ -58,6 +58,47 @@
     return {"checkout_url": session.url}
 
 
+# Subscriptions
+@router.post("/subscribe")
+async def subscribe(
+    user: User = Depends(require_auth),
+    db: AsyncSession = Depends(get_db_session),
+):
+    if not settings.STRIPE_SECRET_KEY or not settings.STRIPE_PRICE_PRO_MONTHLY:
+        raise HTTPException(503, "Stripe not configured")
+
+    # Ensure customer exists
+    if not user.stripe_customer_id:
+        cust = stripe.Customer.create(email=user.email, name=user.name or None)
+        user.stripe_customer_id = cust.id
+        await db.commit()
+
+    # Create Checkout Session for subscription
+    session = stripe.checkout.Session.create(
+        mode="subscription",
+        line_items=[{"price": settings.STRIPE_PRICE_PRO_MONTHLY, "quantity": 1}],
+        success_url=f"{settings.FRONTEND_URL}/billing",
+        cancel_url=f"{settings.FRONTEND_URL}/billing",
+        customer=user.stripe_customer_id,
+        client_reference_id=str(user.id),
+    )
+    return {"checkout_url": session.url}
+
+
+@router.post("/portal")
+async def customer_portal(user: User = Depends(require_auth)):
+    if not settings.STRIPE_SECRET_KEY:
+        raise HTTPException(503, "Stripe not configured")
+    if not user.stripe_customer_id:
+        raise HTTPException(400, "No Stripe customer for user")
+
+    portal = stripe.billing_portal.Session.create(
+        customer=user.stripe_customer_id,
+        return_url=f"{settings.FRONTEND_URL}/billing",
+    )
+    return {"portal_url": portal.url}
+
+
 @router.post("/webhook")
 async def stripe_webhook(request: Request, db: AsyncSession = Depends(get_db_session)):
     payload = await request.body()
@@ -85,70 +126,196 @@
             logger.error("Invalid event structure: missing data.object")
             return {"received": True}
 
-        # Parse and validate client_reference_id (user_id)
-        try:
-            client_ref = session.get("client_reference_id")
-            if not client_ref:
-                logger.error("Missing client_reference_id in checkout session")
+        mode = session.get("mode")
+
+        # Handle subscription checkout
+        if mode == "subscription":
+            try:
+                client_ref = session.get("client_reference_id")
+                if not client_ref:
+                    logger.error("Missing client_reference_id in subscription session")
+                    return {"received": True}
+                user_id = uuid.UUID(client_ref)
+            except (ValueError, TypeError) as e:
+                logger.error("Invalid client_reference_id: %s", e)
+                return {"received": True}
+
+            user = await db.get(User, user_id)
+            if not user:
+                logger.warning("Subscription completed for non-existent user %s", user_id)
                 return {"received": True}
-            user_id = uuid.UUID(client_ref)
-        except (ValueError, TypeError) as e:
-            logger.error("Invalid client_reference_id: %s", e)
+
+            subscription_id = session.get("subscription")
+            customer_id = session.get("customer")
+
+            # Update user plan and subscription/customer ids
+            user.plan = "pro"
+            if subscription_id:
+                user.stripe_subscription_id = subscription_id
+            if customer_id and not user.stripe_customer_id:
+                user.stripe_customer_id = customer_id
+
+            # Idempotency: only one monthly grant per subscription id at start
+            existing = await db.scalar(
+                select(CreditLedger).where(
+                    CreditLedger.ref_type == "stripe_subscription",
+                    CreditLedger.ref_id == (subscription_id or ""),
+                )
+            )
+
+            if not existing:
+                try:
+                    await credit_credits(
+                        db,
+                        user_id=user.id,
+                        amount=int(settings.PLAN_PRO_MONTHLY_CREDITS or 0),
+                        reason="monthly_allowance",
+                        ref_type="stripe_subscription",
+                        ref_id=subscription_id or "",
+                    )
+                    await db.commit()
+                    logger.info(
+                        "Subscription start credits granted: user_id=%s, subscription=%s",
+                        user.id,
+                        subscription_id,
+                    )
+                except Exception as e:
+                    await db.rollback()
+                    logger.error("Failed to grant subscription start credits: %s", e)
+                    raise HTTPException(500, "Database error")
+            else:
+                await db.commit()
+
             return {"received": True}
 
-        # Parse and validate credits amount
-        try:
-            metadata = session.get("metadata", {})
-            credits_str = metadata.get("credits")
-            if not credits_str:
-                logger.error("Missing credits in session metadata")
+        # Handle one-time credit pack checkout
+        if mode == "payment":
+            # Parse and validate client_reference_id (user_id)
+            try:
+                client_ref = session.get("client_reference_id")
+                if not client_ref:
+                    logger.error("Missing client_reference_id in checkout session")
+                    return {"received": True}
+                user_id = uuid.UUID(client_ref)
+            except (ValueError, TypeError) as e:
+                logger.error("Invalid client_reference_id: %s", e)
                 return {"received": True}
-            credits = int(credits_str)
-            if credits <= 0:
-                logger.error("Invalid credits amount: %d", credits)
+
+            # Parse and validate credits amount
+            try:
+                metadata = session.get("metadata", {})
+                credits_str = metadata.get("credits")
+                if not credits_str:
+                    logger.error("Missing credits in session metadata")
+                    return {"received": True}
+                credits = int(credits_str)
+                if credits <= 0:
+                    logger.error("Invalid credits amount: %d", credits)
+                    return {"received": True}
+            except (ValueError, TypeError) as e:
+                logger.error("Cannot parse credits from metadata: %s", e)
+                return {"received": True}
+
+            # Get payment_intent for idempotency
+            payment_intent = session.get("payment_intent")
+            if not payment_intent:
+                logger.warning("Checkout session has no payment_intent, skipping for safety")
                 return {"received": True}
-        except (ValueError, TypeError) as e:
-            logger.error("Cannot parse credits from metadata: %s", e)
+
+            # Verify user exists
+            user = await db.get(User, user_id)
+            if not user:
+                logger.warning("Webhook for non-existent user %s", user_id)
+                return {"received": True}
+
+            # Idempotency check
+            existing = await db.scalar(
+                select(CreditLedger).where(
+                    CreditLedger.ref_type == "stripe_payment",
+                    CreditLedger.ref_id == payment_intent,
+                )
+            )
+
+            if not existing:
+                try:
+                    await credit_credits(
+                        db,
+                        user_id,
+                        credits,
+                        reason="purchase",
+                        ref_type="stripe_payment",
+                        ref_id=payment_intent,
+                    )
+                    await db.commit()
+                    logger.info(
+                        "Credits granted: user_id=%s, credits=%d, payment_intent=%s",
+                        user_id,
+                        credits,
+                        payment_intent,
+                    )
+                except Exception as e:
+                    await db.rollback()
+                    logger.error("Failed to grant credits: %s", e)
+                    # Return 5xx so Stripe retries
+                    raise HTTPException(500, "Database error")
+            return {"received": True}
+
+    elif event["type"] == "invoice.payment_succeeded":
+    
+        obj = event.get("data", {}).get("object")
+        if not obj or not isinstance(obj, dict):
             return {"received": True}
 
-        # Get payment_intent for idempotency
-        payment_intent = session.get("payment_intent")
-        if not payment_intent:
-            logger.warning("Checkout session has no payment_intent, skipping for safety")
+        invoice_id = obj.get("id")
+        customer_id = obj.get("customer")
+        if not invoice_id or not customer_id:
             return {"received": True}
 
-        # Verify user exists
-        user = await db.get(User, user_id)
+        # Find user by customer id
+        user = await db.scalar(select(User).where(User.stripe_customer_id == customer_id))
         if not user:
-            logger.warning("Webhook for non-existent user %s", user_id)
             return {"received": True}
 
-        # Idempotency check
+        # Idempotency: ensure we haven't granted for this invoice
         existing = await db.scalar(
             select(CreditLedger).where(
-                CreditLedger.ref_type == "stripe_payment",
-                CreditLedger.ref_id == payment_intent,
+                CreditLedger.ref_type == "stripe_invoice",
+                CreditLedger.ref_id == invoice_id,
             )
         )
-
         if not existing:
             try:
                 await credit_credits(
                     db,
-                    user_id,
-                    credits,
-                    reason="purchase",
-                    ref_type="stripe_payment",
-                    ref_id=payment_intent,
+                    user_id=user.id,
+                    amount=int(settings.PLAN_PRO_MONTHLY_CREDITS or 0),
+                    reason="monthly_allowance",
+                    ref_type="stripe_invoice",
+                    ref_id=invoice_id,
                 )
                 await db.commit()
-                logger.info("Credits granted: user_id=%s, credits=%d, payment_intent=%s",
-                           user_id, credits, payment_intent)
             except Exception as e:
                 await db.rollback()
-                logger.error("Failed to grant credits: %s", e)
-                # Return 5xx so Stripe retries
+                logger.error("Failed to grant monthly credits on invoice: %s", e)
                 raise HTTPException(500, "Database error")
+        return {"received": True}
+
+    elif event["type"] == "customer.subscription.deleted":
+        obj = event.get("data", {}).get("object")
+        if not obj or not isinstance(obj, dict):
+            return {"received": True}
 
-    return {"received": True}
+        customer_id = obj.get("customer")
+        if not customer_id:
+            return {"received": True}
 
+        user = await db.scalar(select(User).where(User.stripe_customer_id == customer_id))
+        if not user:
+            return {"received": True}
+
+        user.plan = "free"
+        user.stripe_subscription_id = None
+        await db.commit()
+        return {"received": True}
+
+    return {"received": True}
diff --git a/backend/app/api/chat.py b/backend/app/api/chat.py
index 71fc751fa90239dfe90bf76e3b30a7aa686d0c3f..d52dc47026e109df283984196581d417a4fea1dc
--- a/backend/app/api/chat.py
+++ b/backend/app/api/chat.py
@@ -133,6 +133,9 @@
 
     # If authenticated, ensure sufficient credits before opening stream
     if user is not None:
+        from app.services.credit_service import ensure_monthly_credits
+        await ensure_monthly_credits(db, user)
+        await db.commit()
         balance = await credit_service.get_user_credits(db, user.id)
         if balance < credit_service.MIN_CREDITS_FOR_CHAT:
             return JSONResponse(
diff --git a/backend/app/core/config.py b/backend/app/core/config.py
index 830f599a7b1ff02463684a9e84e90adfd6318cc1..a8eef6c5b4145c3710d46395bf26465dec42b4a7
--- a/backend/app/core/config.py
+++ b/backend/app/core/config.py
@@ -75,6 +75,10 @@
     CREDITS_PRO: int = 200000
     CREDITS_ENTERPRISE: int = 1000000
     SIGNUP_BONUS_CREDITS: int = 10000
+    # Subscription tiers
+    PLAN_FREE_MONTHLY_CREDITS: int = 10000
+    PLAN_PRO_MONTHLY_CREDITS: int = 100000
+    STRIPE_PRICE_PRO_MONTHLY: str = ''
 
     model_config = SettingsConfigDict(env_file=".env", env_file_encoding="utf-8", case_sensitive=False)
 
diff --git a/backend/app/models/tables.py b/backend/app/models/tables.py
index 2eb9239abb3f01f8a4103944db02efcb27f20149..9caeafd2d73fb05604695d962f9a0dc191da0bf2
--- a/backend/app/models/tables.py
+++ b/backend/app/models/tables.py
@@ -163,6 +163,10 @@
     email_verified: Mapped[Optional[datetime]] = mapped_column(sa.DateTime(timezone=True))
     credits_balance: Mapped[int] = mapped_column(sa.Integer, nullable=False, server_default=sa.text("0"))
     signup_bonus_granted_at: Mapped[Optional[datetime]] = mapped_column(sa.DateTime(timezone=True))
+    plan: Mapped[str] = mapped_column(sa.String(20), nullable=False, server_default=sa.text("'free'"))
+    stripe_customer_id: Mapped[Optional[str]] = mapped_column(sa.String(255))
+    stripe_subscription_id: Mapped[Optional[str]] = mapped_column(sa.String(255))
+    monthly_credits_granted_at: Mapped[Optional[datetime]] = mapped_column(sa.DateTime(timezone=True))
     created_at: Mapped[datetime] = mapped_column(sa.DateTime(timezone=True), server_default=sa.text("now()"))
     updated_at: Mapped[datetime] = mapped_column(
         sa.DateTime(timezone=True), server_default=sa.text("now()"), onupdate=sa.func.now()
diff --git a/backend/app/services/credit_service.py b/backend/app/services/credit_service.py
index d89772b0418d1ebe1a79bba3de65f0112a550adb..a599453a961fb9222db98928201795c4fa4e574b
--- a/backend/app/services/credit_service.py
+++ b/backend/app/services/credit_service.py
@@ -7,6 +7,7 @@
 from sqlalchemy.ext.asyncio import AsyncSession
 
 from app.models.tables import CreditLedger, UsageRecord, User
+from app.core.config import settings
 
 
 # Token-to-credit rates by model tier
@@ -144,3 +145,56 @@
     db.add(usage)
     return usage
 
+
+async def ensure_monthly_credits(db: AsyncSession, user: User) -> None:
+    """Grant monthly credits if last grant was over 30 days ago.
+
+    Idempotency: checks CreditLedger for any recent 'monthly_allowance' within 30 days.
+    """
+    from datetime import datetime, timedelta, timezone
+
+    # Determine if grant needed based on timestamp
+    now = datetime.now(timezone.utc)
+    last = user.monthly_credits_granted_at
+    needs_grant = last is None or (now - last) >= timedelta(days=30)
+    if not needs_grant:
+        return
+
+    # Check ledger for idempotency within last 30 days
+    cutoff = now - timedelta(days=30)
+    existing = await db.scalar(
+        sa.select(CreditLedger)
+        .where(CreditLedger.user_id == user.id)
+        .where(CreditLedger.reason == "monthly_allowance")
+        .where(CreditLedger.created_at >= cutoff)
+    )
+    if existing:
+        # Still update marker to avoid repeatedly checking in future requests
+        user.monthly_credits_granted_at = now
+        await db.flush()
+        return
+
+    # Determine allowance by plan
+    plan = (user.plan or "free").lower()
+    if plan == "pro":
+        allowance = int(settings.PLAN_PRO_MONTHLY_CREDITS or 0)
+    else:
+        allowance = int(settings.PLAN_FREE_MONTHLY_CREDITS or 0)
+
+    if allowance <= 0:
+        # Nothing to grant
+        user.monthly_credits_granted_at = now
+        await db.flush()
+        return
+
+    # Grant credits and update marker
+    await credit_credits(
+        db,
+        user_id=user.id,
+        amount=allowance,
+        reason="monthly_allowance",
+        ref_type=None,
+        ref_id=None,
+    )
+    user.monthly_credits_granted_at = now
+    await db.flush()

file update:
diff --git a/backend/alembic/versions/20260206_0004_add_subscription_fields.py b/backend/alembic/versions/20260206_0004_add_subscription_fields.py
new file mode 100644
index 0000000000000000000000000000000000000000..f84be09226785ea3dbc1b413b3cfd2cb07dff81e
--- /dev/null
+++ b/backend/alembic/versions/20260206_0004_add_subscription_fields.py
@@ -0,0 +1,38 @@
+"""add subscription fields to users
+
+Revision ID: d4e5f6a7b8c9
+Revises: c3d4e5f6a7b8
+Create Date: 2026-02-06 00:40:00
+
+"""
+from __future__ import annotations
+
+from alembic import op
+import sqlalchemy as sa
+
+
+# revision identifiers, used by Alembic.
+revision = "d4e5f6a7b8c9"
+down_revision = "c3d4e5f6a7b8"
+branch_labels = None
+depends_on = None
+
+
+def upgrade() -> None:
+    # Add subscription-related columns to users
+    op.add_column(
+        "users",
+        sa.Column("plan", sa.String(length=20), nullable=False, server_default=sa.text("'free'")),
+    )
+    op.add_column("users", sa.Column("stripe_customer_id", sa.String(length=255), nullable=True))
+    op.add_column("users", sa.Column("stripe_subscription_id", sa.String(length=255), nullable=True))
+    op.add_column("users", sa.Column("monthly_credits_granted_at", sa.DateTime(timezone=True), nullable=True))
+
+
+def downgrade() -> None:
+    # Drop subscription-related columns from users
+    op.drop_column("users", "monthly_credits_granted_at")
+    op.drop_column("users", "stripe_subscription_id")
+    op.drop_column("users", "stripe_customer_id")
+    op.drop_column("users", "plan")
+
diff --git a/backend/app/api/billing.py b/backend/app/api/billing.py
index 851620df69f9c62fb3cab15feeedcafff44cc6bb..f99355cf848497a82c150ed57c5c5b2c20aa5e2e
--- a/backend/app/api/billing.py
+++ b/backend/app/api/billing.py
@@ -58,6 +58,47 @@
     return {"checkout_url": session.url}
 
 
+# Subscriptions
+@router.post("/subscribe")
+async def subscribe(
+    user: User = Depends(require_auth),
+    db: AsyncSession = Depends(get_db_session),
+):
+    if not settings.STRIPE_SECRET_KEY or not settings.STRIPE_PRICE_PRO_MONTHLY:
+        raise HTTPException(503, "Stripe not configured")
+
+    # Ensure customer exists
+    if not user.stripe_customer_id:
+        cust = stripe.Customer.create(email=user.email, name=user.name or None)
+        user.stripe_customer_id = cust.id
+        await db.commit()
+
+    # Create Checkout Session for subscription
+    session = stripe.checkout.Session.create(
+        mode="subscription",
+        line_items=[{"price": settings.STRIPE_PRICE_PRO_MONTHLY, "quantity": 1}],
+        success_url=f"{settings.FRONTEND_URL}/billing",
+        cancel_url=f"{settings.FRONTEND_URL}/billing",
+        customer=user.stripe_customer_id,
+        client_reference_id=str(user.id),
+    )
+    return {"checkout_url": session.url}
+
+
+@router.post("/portal")
+async def customer_portal(user: User = Depends(require_auth)):
+    if not settings.STRIPE_SECRET_KEY:
+        raise HTTPException(503, "Stripe not configured")
+    if not user.stripe_customer_id:
+        raise HTTPException(400, "No Stripe customer for user")
+
+    portal = stripe.billing_portal.Session.create(
+        customer=user.stripe_customer_id,
+        return_url=f"{settings.FRONTEND_URL}/billing",
+    )
+    return {"portal_url": portal.url}
+
+
 @router.post("/webhook")
 async def stripe_webhook(request: Request, db: AsyncSession = Depends(get_db_session)):
     payload = await request.body()
@@ -85,70 +126,196 @@
             logger.error("Invalid event structure: missing data.object")
             return {"received": True}
 
-        # Parse and validate client_reference_id (user_id)
-        try:
-            client_ref = session.get("client_reference_id")
-            if not client_ref:
-                logger.error("Missing client_reference_id in checkout session")
+        mode = session.get("mode")
+
+        # Handle subscription checkout
+        if mode == "subscription":
+            try:
+                client_ref = session.get("client_reference_id")
+                if not client_ref:
+                    logger.error("Missing client_reference_id in subscription session")
+                    return {"received": True}
+                user_id = uuid.UUID(client_ref)
+            except (ValueError, TypeError) as e:
+                logger.error("Invalid client_reference_id: %s", e)
+                return {"received": True}
+
+            user = await db.get(User, user_id)
+            if not user:
+                logger.warning("Subscription completed for non-existent user %s", user_id)
                 return {"received": True}
-            user_id = uuid.UUID(client_ref)
-        except (ValueError, TypeError) as e:
-            logger.error("Invalid client_reference_id: %s", e)
+
+            subscription_id = session.get("subscription")
+            customer_id = session.get("customer")
+
+            # Update user plan and subscription/customer ids
+            user.plan = "pro"
+            if subscription_id:
+                user.stripe_subscription_id = subscription_id
+            if customer_id and not user.stripe_customer_id:
+                user.stripe_customer_id = customer_id
+
+            # Idempotency: only one monthly grant per subscription id at start
+            existing = await db.scalar(
+                select(CreditLedger).where(
+                    CreditLedger.ref_type == "stripe_subscription",
+                    CreditLedger.ref_id == (subscription_id or ""),
+                )
+            )
+
+            if not existing:
+                try:
+                    await credit_credits(
+                        db,
+                        user_id=user.id,
+                        amount=int(settings.PLAN_PRO_MONTHLY_CREDITS or 0),
+                        reason="monthly_allowance",
+                        ref_type="stripe_subscription",
+                        ref_id=subscription_id or "",
+                    )
+                    await db.commit()
+                    logger.info(
+                        "Subscription start credits granted: user_id=%s, subscription=%s",
+                        user.id,
+                        subscription_id,
+                    )
+                except Exception as e:
+                    await db.rollback()
+                    logger.error("Failed to grant subscription start credits: %s", e)
+                    raise HTTPException(500, "Database error")
+            else:
+                await db.commit()
+
             return {"received": True}
 
-        # Parse and validate credits amount
-        try:
-            metadata = session.get("metadata", {})
-            credits_str = metadata.get("credits")
-            if not credits_str:
-                logger.error("Missing credits in session metadata")
+        # Handle one-time credit pack checkout
+        if mode == "payment":
+            # Parse and validate client_reference_id (user_id)
+            try:
+                client_ref = session.get("client_reference_id")
+                if not client_ref:
+                    logger.error("Missing client_reference_id in checkout session")
+                    return {"received": True}
+                user_id = uuid.UUID(client_ref)
+            except (ValueError, TypeError) as e:
+                logger.error("Invalid client_reference_id: %s", e)
                 return {"received": True}
-            credits = int(credits_str)
-            if credits <= 0:
-                logger.error("Invalid credits amount: %d", credits)
+
+            # Parse and validate credits amount
+            try:
+                metadata = session.get("metadata", {})
+                credits_str = metadata.get("credits")
+                if not credits_str:
+                    logger.error("Missing credits in session metadata")
+                    return {"received": True}
+                credits = int(credits_str)
+                if credits <= 0:
+                    logger.error("Invalid credits amount: %d", credits)
+                    return {"received": True}
+            except (ValueError, TypeError) as e:
+                logger.error("Cannot parse credits from metadata: %s", e)
+                return {"received": True}
+
+            # Get payment_intent for idempotency
+            payment_intent = session.get("payment_intent")
+            if not payment_intent:
+                logger.warning("Checkout session has no payment_intent, skipping for safety")
                 return {"received": True}
-        except (ValueError, TypeError) as e:
-            logger.error("Cannot parse credits from metadata: %s", e)
+
+            # Verify user exists
+            user = await db.get(User, user_id)
+            if not user:
+                logger.warning("Webhook for non-existent user %s", user_id)
+                return {"received": True}
+
+            # Idempotency check
+            existing = await db.scalar(
+                select(CreditLedger).where(
+                    CreditLedger.ref_type == "stripe_payment",
+                    CreditLedger.ref_id == payment_intent,
+                )
+            )
+
+            if not existing:
+                try:
+                    await credit_credits(
+                        db,
+                        user_id,
+                        credits,
+                        reason="purchase",
+                        ref_type="stripe_payment",
+                        ref_id=payment_intent,
+                    )
+                    await db.commit()
+                    logger.info(
+                        "Credits granted: user_id=%s, credits=%d, payment_intent=%s",
+                        user_id,
+                        credits,
+                        payment_intent,
+                    )
+                except Exception as e:
+                    await db.rollback()
+                    logger.error("Failed to grant credits: %s", e)
+                    # Return 5xx so Stripe retries
+                    raise HTTPException(500, "Database error")
+            return {"received": True}
+
+    elif event["type"] == "invoice.payment_succeeded":
+    
+        obj = event.get("data", {}).get("object")
+        if not obj or not isinstance(obj, dict):
             return {"received": True}
 
-        # Get payment_intent for idempotency
-        payment_intent = session.get("payment_intent")
-        if not payment_intent:
-            logger.warning("Checkout session has no payment_intent, skipping for safety")
+        invoice_id = obj.get("id")
+        customer_id = obj.get("customer")
+        if not invoice_id or not customer_id:
             return {"received": True}
 
-        # Verify user exists
-        user = await db.get(User, user_id)
+        # Find user by customer id
+        user = await db.scalar(select(User).where(User.stripe_customer_id == customer_id))
         if not user:
-            logger.warning("Webhook for non-existent user %s", user_id)
             return {"received": True}
 
-        # Idempotency check
+        # Idempotency: ensure we haven't granted for this invoice
         existing = await db.scalar(
             select(CreditLedger).where(
-                CreditLedger.ref_type == "stripe_payment",
-                CreditLedger.ref_id == payment_intent,
+                CreditLedger.ref_type == "stripe_invoice",
+                CreditLedger.ref_id == invoice_id,
             )
         )
-
         if not existing:
             try:
                 await credit_credits(
                     db,
-                    user_id,
-                    credits,
-                    reason="purchase",
-                    ref_type="stripe_payment",
-                    ref_id=payment_intent,
+                    user_id=user.id,
+                    amount=int(settings.PLAN_PRO_MONTHLY_CREDITS or 0),
+                    reason="monthly_allowance",
+                    ref_type="stripe_invoice",
+                    ref_id=invoice_id,
                 )
                 await db.commit()
-                logger.info("Credits granted: user_id=%s, credits=%d, payment_intent=%s",
-                           user_id, credits, payment_intent)
             except Exception as e:
                 await db.rollback()
-                logger.error("Failed to grant credits: %s", e)
-                # Return 5xx so Stripe retries
+                logger.error("Failed to grant monthly credits on invoice: %s", e)
                 raise HTTPException(500, "Database error")
+        return {"received": True}
+
+    elif event["type"] == "customer.subscription.deleted":
+        obj = event.get("data", {}).get("object")
+        if not obj or not isinstance(obj, dict):
+            return {"received": True}
 
-    return {"received": True}
+        customer_id = obj.get("customer")
+        if not customer_id:
+            return {"received": True}
 
+        user = await db.scalar(select(User).where(User.stripe_customer_id == customer_id))
+        if not user:
+            return {"received": True}
+
+        user.plan = "free"
+        user.stripe_subscription_id = None
+        await db.commit()
+        return {"received": True}
+
+    return {"received": True}
diff --git a/backend/app/api/chat.py b/backend/app/api/chat.py
index 71fc751fa90239dfe90bf76e3b30a7aa686d0c3f..d52dc47026e109df283984196581d417a4fea1dc
--- a/backend/app/api/chat.py
+++ b/backend/app/api/chat.py
@@ -133,6 +133,9 @@
 
     # If authenticated, ensure sufficient credits before opening stream
     if user is not None:
+        from app.services.credit_service import ensure_monthly_credits
+        await ensure_monthly_credits(db, user)
+        await db.commit()
         balance = await credit_service.get_user_credits(db, user.id)
         if balance < credit_service.MIN_CREDITS_FOR_CHAT:
             return JSONResponse(
diff --git a/backend/app/core/config.py b/backend/app/core/config.py
index 830f599a7b1ff02463684a9e84e90adfd6318cc1..a8eef6c5b4145c3710d46395bf26465dec42b4a7
--- a/backend/app/core/config.py
+++ b/backend/app/core/config.py
@@ -75,6 +75,10 @@
     CREDITS_PRO: int = 200000
     CREDITS_ENTERPRISE: int = 1000000
     SIGNUP_BONUS_CREDITS: int = 10000
+    # Subscription tiers
+    PLAN_FREE_MONTHLY_CREDITS: int = 10000
+    PLAN_PRO_MONTHLY_CREDITS: int = 100000
+    STRIPE_PRICE_PRO_MONTHLY: str = ''
 
     model_config = SettingsConfigDict(env_file=".env", env_file_encoding="utf-8", case_sensitive=False)
 
diff --git a/backend/app/models/tables.py b/backend/app/models/tables.py
index 2eb9239abb3f01f8a4103944db02efcb27f20149..9caeafd2d73fb05604695d962f9a0dc191da0bf2
--- a/backend/app/models/tables.py
+++ b/backend/app/models/tables.py
@@ -163,6 +163,10 @@
     email_verified: Mapped[Optional[datetime]] = mapped_column(sa.DateTime(timezone=True))
     credits_balance: Mapped[int] = mapped_column(sa.Integer, nullable=False, server_default=sa.text("0"))
     signup_bonus_granted_at: Mapped[Optional[datetime]] = mapped_column(sa.DateTime(timezone=True))
+    plan: Mapped[str] = mapped_column(sa.String(20), nullable=False, server_default=sa.text("'free'"))
+    stripe_customer_id: Mapped[Optional[str]] = mapped_column(sa.String(255))
+    stripe_subscription_id: Mapped[Optional[str]] = mapped_column(sa.String(255))
+    monthly_credits_granted_at: Mapped[Optional[datetime]] = mapped_column(sa.DateTime(timezone=True))
     created_at: Mapped[datetime] = mapped_column(sa.DateTime(timezone=True), server_default=sa.text("now()"))
     updated_at: Mapped[datetime] = mapped_column(
         sa.DateTime(timezone=True), server_default=sa.text("now()"), onupdate=sa.func.now()
diff --git a/backend/app/services/credit_service.py b/backend/app/services/credit_service.py
index d89772b0418d1ebe1a79bba3de65f0112a550adb..a599453a961fb9222db98928201795c4fa4e574b
--- a/backend/app/services/credit_service.py
+++ b/backend/app/services/credit_service.py
@@ -7,6 +7,7 @@
 from sqlalchemy.ext.asyncio import AsyncSession
 
 from app.models.tables import CreditLedger, UsageRecord, User
+from app.core.config import settings
 
 
 # Token-to-credit rates by model tier
@@ -144,3 +145,56 @@
     db.add(usage)
     return usage
 
+
+async def ensure_monthly_credits(db: AsyncSession, user: User) -> None:
+    """Grant monthly credits if last grant was over 30 days ago.
+
+    Idempotency: checks CreditLedger for any recent 'monthly_allowance' within 30 days.
+    """
+    from datetime import datetime, timedelta, timezone
+
+    # Determine if grant needed based on timestamp
+    now = datetime.now(timezone.utc)
+    last = user.monthly_credits_granted_at
+    needs_grant = last is None or (now - last) >= timedelta(days=30)
+    if not needs_grant:
+        return
+
+    # Check ledger for idempotency within last 30 days
+    cutoff = now - timedelta(days=30)
+    existing = await db.scalar(
+        sa.select(CreditLedger)
+        .where(CreditLedger.user_id == user.id)
+        .where(CreditLedger.reason == "monthly_allowance")
+        .where(CreditLedger.created_at >= cutoff)
+    )
+    if existing:
+        # Still update marker to avoid repeatedly checking in future requests
+        user.monthly_credits_granted_at = now
+        await db.flush()
+        return
+
+    # Determine allowance by plan
+    plan = (user.plan or "free").lower()
+    if plan == "pro":
+        allowance = int(settings.PLAN_PRO_MONTHLY_CREDITS or 0)
+    else:
+        allowance = int(settings.PLAN_FREE_MONTHLY_CREDITS or 0)
+
+    if allowance <= 0:
+        # Nothing to grant
+        user.monthly_credits_granted_at = now
+        await db.flush()
+        return
+
+    # Grant credits and update marker
+    await credit_credits(
+        db,
+        user_id=user.id,
+        amount=allowance,
+        reason="monthly_allowance",
+        ref_type=None,
+        ref_id=None,
+    )
+    user.monthly_credits_granted_at = now
+    await db.flush()


thinking
**Updating webhook events**

I’m focusing on updating the webhook event for 'checkout.session.completed'. It’s important to ensure that 'db.commit()' gets triggered after we update the plan. I’m setting the user's plan to 'pro', but I need to make sure we only commit inside the right branch. For the 'existing' ledger branch, I’ll call 'await db.commit()' at the bottom; that seems solid. I'll also commit after granting for 'invoice.payment_succeeded' and 'customer.subscription.deleted'. Next, I'll update the auth_service to include monthly_credits_granted_at. Let’s patch this up!
file update
M /Users/mayijie/Projects/Code/010_DocTalk/backend/app/services/auth_service.py
@@ -54,2 +54,3 @@
         signup_bonus_granted_at=datetime.utcnow(),
+        monthly_credits_granted_at=datetime.utcnow(),
     )
@@ -181,2 +182 @@
     return vt
-
apply_patch(auto_approved=true) exited 0 in 75ms:
Success. Updated the following files:
M backend/app/services/auth_service.py
file update:
diff --git a/backend/alembic/versions/20260206_0004_add_subscription_fields.py b/backend/alembic/versions/20260206_0004_add_subscription_fields.py
new file mode 100644
index 0000000000000000000000000000000000000000..f84be09226785ea3dbc1b413b3cfd2cb07dff81e
--- /dev/null
+++ b/backend/alembic/versions/20260206_0004_add_subscription_fields.py
@@ -0,0 +1,38 @@
+"""add subscription fields to users
+
+Revision ID: d4e5f6a7b8c9
+Revises: c3d4e5f6a7b8
+Create Date: 2026-02-06 00:40:00
+
+"""
+from __future__ import annotations
+
+from alembic import op
+import sqlalchemy as sa
+
+
+# revision identifiers, used by Alembic.
+revision = "d4e5f6a7b8c9"
+down_revision = "c3d4e5f6a7b8"
+branch_labels = None
+depends_on = None
+
+
+def upgrade() -> None:
+    # Add subscription-related columns to users
+    op.add_column(
+        "users",
+        sa.Column("plan", sa.String(length=20), nullable=False, server_default=sa.text("'free'")),
+    )
+    op.add_column("users", sa.Column("stripe_customer_id", sa.String(length=255), nullable=True))
+    op.add_column("users", sa.Column("stripe_subscription_id", sa.String(length=255), nullable=True))
+    op.add_column("users", sa.Column("monthly_credits_granted_at", sa.DateTime(timezone=True), nullable=True))
+
+
+def downgrade() -> None:
+    # Drop subscription-related columns from users
+    op.drop_column("users", "monthly_credits_granted_at")
+    op.drop_column("users", "stripe_subscription_id")
+    op.drop_column("users", "stripe_customer_id")
+    op.drop_column("users", "plan")
+
diff --git a/backend/app/api/billing.py b/backend/app/api/billing.py
index 851620df69f9c62fb3cab15feeedcafff44cc6bb..f99355cf848497a82c150ed57c5c5b2c20aa5e2e
--- a/backend/app/api/billing.py
+++ b/backend/app/api/billing.py
@@ -58,6 +58,47 @@
     return {"checkout_url": session.url}
 
 
+# Subscriptions
+@router.post("/subscribe")
+async def subscribe(
+    user: User = Depends(require_auth),
+    db: AsyncSession = Depends(get_db_session),
+):
+    if not settings.STRIPE_SECRET_KEY or not settings.STRIPE_PRICE_PRO_MONTHLY:
+        raise HTTPException(503, "Stripe not configured")
+
+    # Ensure customer exists
+    if not user.stripe_customer_id:
+        cust = stripe.Customer.create(email=user.email, name=user.name or None)
+        user.stripe_customer_id = cust.id
+        await db.commit()
+
+    # Create Checkout Session for subscription
+    session = stripe.checkout.Session.create(
+        mode="subscription",
+        line_items=[{"price": settings.STRIPE_PRICE_PRO_MONTHLY, "quantity": 1}],
+        success_url=f"{settings.FRONTEND_URL}/billing",
+        cancel_url=f"{settings.FRONTEND_URL}/billing",
+        customer=user.stripe_customer_id,
+        client_reference_id=str(user.id),
+    )
+    return {"checkout_url": session.url}
+
+
+@router.post("/portal")
+async def customer_portal(user: User = Depends(require_auth)):
+    if not settings.STRIPE_SECRET_KEY:
+        raise HTTPException(503, "Stripe not configured")
+    if not user.stripe_customer_id:
+        raise HTTPException(400, "No Stripe customer for user")
+
+    portal = stripe.billing_portal.Session.create(
+        customer=user.stripe_customer_id,
+        return_url=f"{settings.FRONTEND_URL}/billing",
+    )
+    return {"portal_url": portal.url}
+
+
 @router.post("/webhook")
 async def stripe_webhook(request: Request, db: AsyncSession = Depends(get_db_session)):
     payload = await request.body()
@@ -85,70 +126,196 @@
             logger.error("Invalid event structure: missing data.object")
             return {"received": True}
 
-        # Parse and validate client_reference_id (user_id)
-        try:
-            client_ref = session.get("client_reference_id")
-            if not client_ref:
-                logger.error("Missing client_reference_id in checkout session")
+        mode = session.get("mode")
+
+        # Handle subscription checkout
+        if mode == "subscription":
+            try:
+                client_ref = session.get("client_reference_id")
+                if not client_ref:
+                    logger.error("Missing client_reference_id in subscription session")
+                    return {"received": True}
+                user_id = uuid.UUID(client_ref)
+            except (ValueError, TypeError) as e:
+                logger.error("Invalid client_reference_id: %s", e)
+                return {"received": True}
+
+            user = await db.get(User, user_id)
+            if not user:
+                logger.warning("Subscription completed for non-existent user %s", user_id)
                 return {"received": True}
-            user_id = uuid.UUID(client_ref)
-        except (ValueError, TypeError) as e:
-            logger.error("Invalid client_reference_id: %s", e)
+
+            subscription_id = session.get("subscription")
+            customer_id = session.get("customer")
+
+            # Update user plan and subscription/customer ids
+            user.plan = "pro"
+            if subscription_id:
+                user.stripe_subscription_id = subscription_id
+            if customer_id and not user.stripe_customer_id:
+                user.stripe_customer_id = customer_id
+
+            # Idempotency: only one monthly grant per subscription id at start
+            existing = await db.scalar(
+                select(CreditLedger).where(
+                    CreditLedger.ref_type == "stripe_subscription",
+                    CreditLedger.ref_id == (subscription_id or ""),
+                )
+            )
+
+            if not existing:
+                try:
+                    await credit_credits(
+                        db,
+                        user_id=user.id,
+                        amount=int(settings.PLAN_PRO_MONTHLY_CREDITS or 0),
+                        reason="monthly_allowance",
+                        ref_type="stripe_subscription",
+                        ref_id=subscription_id or "",
+                    )
+                    await db.commit()
+                    logger.info(
+                        "Subscription start credits granted: user_id=%s, subscription=%s",
+                        user.id,
+                        subscription_id,
+                    )
+                except Exception as e:
+                    await db.rollback()
+                    logger.error("Failed to grant subscription start credits: %s", e)
+                    raise HTTPException(500, "Database error")
+            else:
+                await db.commit()
+
             return {"received": True}
 
-        # Parse and validate credits amount
-        try:
-            metadata = session.get("metadata", {})
-            credits_str = metadata.get("credits")
-            if not credits_str:
-                logger.error("Missing credits in session metadata")
+        # Handle one-time credit pack checkout
+        if mode == "payment":
+            # Parse and validate client_reference_id (user_id)
+            try:
+                client_ref = session.get("client_reference_id")
+                if not client_ref:
+                    logger.error("Missing client_reference_id in checkout session")
+                    return {"received": True}
+                user_id = uuid.UUID(client_ref)
+            except (ValueError, TypeError) as e:
+                logger.error("Invalid client_reference_id: %s", e)
                 return {"received": True}
-            credits = int(credits_str)
-            if credits <= 0:
-                logger.error("Invalid credits amount: %d", credits)
+
+            # Parse and validate credits amount
+            try:
+                metadata = session.get("metadata", {})
+                credits_str = metadata.get("credits")
+                if not credits_str:
+                    logger.error("Missing credits in session metadata")
+                    return {"received": True}
+                credits = int(credits_str)
+                if credits <= 0:
+                    logger.error("Invalid credits amount: %d", credits)
+                    return {"received": True}
+            except (ValueError, TypeError) as e:
+                logger.error("Cannot parse credits from metadata: %s", e)
+                return {"received": True}
+
+            # Get payment_intent for idempotency
+            payment_intent = session.get("payment_intent")
+            if not payment_intent:
+                logger.warning("Checkout session has no payment_intent, skipping for safety")
                 return {"received": True}
-        except (ValueError, TypeError) as e:
-            logger.error("Cannot parse credits from metadata: %s", e)
+
+            # Verify user exists
+            user = await db.get(User, user_id)
+            if not user:
+                logger.warning("Webhook for non-existent user %s", user_id)
+                return {"received": True}
+
+            # Idempotency check
+            existing = await db.scalar(
+                select(CreditLedger).where(
+                    CreditLedger.ref_type == "stripe_payment",
+                    CreditLedger.ref_id == payment_intent,
+                )
+            )
+
+            if not existing:
+                try:
+                    await credit_credits(
+                        db,
+                        user_id,
+                        credits,
+                        reason="purchase",
+                        ref_type="stripe_payment",
+                        ref_id=payment_intent,
+                    )
+                    await db.commit()
+                    logger.info(
+                        "Credits granted: user_id=%s, credits=%d, payment_intent=%s",
+                        user_id,
+                        credits,
+                        payment_intent,
+                    )
+                except Exception as e:
+                    await db.rollback()
+                    logger.error("Failed to grant credits: %s", e)
+                    # Return 5xx so Stripe retries
+                    raise HTTPException(500, "Database error")
+            return {"received": True}
+
+    elif event["type"] == "invoice.payment_succeeded":
+    
+        obj = event.get("data", {}).get("object")
+        if not obj or not isinstance(obj, dict):
             return {"received": True}
 
-        # Get payment_intent for idempotency
-        payment_intent = session.get("payment_intent")
-        if not payment_intent:
-            logger.warning("Checkout session has no payment_intent, skipping for safety")
+        invoice_id = obj.get("id")
+        customer_id = obj.get("customer")
+        if not invoice_id or not customer_id:
             return {"received": True}
 
-        # Verify user exists
-        user = await db.get(User, user_id)
+        # Find user by customer id
+        user = await db.scalar(select(User).where(User.stripe_customer_id == customer_id))
         if not user:
-            logger.warning("Webhook for non-existent user %s", user_id)
             return {"received": True}
 
-        # Idempotency check
+        # Idempotency: ensure we haven't granted for this invoice
         existing = await db.scalar(
             select(CreditLedger).where(
-                CreditLedger.ref_type == "stripe_payment",
-                CreditLedger.ref_id == payment_intent,
+                CreditLedger.ref_type == "stripe_invoice",
+                CreditLedger.ref_id == invoice_id,
             )
         )
-
         if not existing:
             try:
                 await credit_credits(
                     db,
-                    user_id,
-                    credits,
-                    reason="purchase",
-                    ref_type="stripe_payment",
-                    ref_id=payment_intent,
+                    user_id=user.id,
+                    amount=int(settings.PLAN_PRO_MONTHLY_CREDITS or 0),
+                    reason="monthly_allowance",
+                    ref_type="stripe_invoice",
+                    ref_id=invoice_id,
                 )
                 await db.commit()
-                logger.info("Credits granted: user_id=%s, credits=%d, payment_intent=%s",
-                           user_id, credits, payment_intent)
             except Exception as e:
                 await db.rollback()
-                logger.error("Failed to grant credits: %s", e)
-                # Return 5xx so Stripe retries
+                logger.error("Failed to grant monthly credits on invoice: %s", e)
                 raise HTTPException(500, "Database error")
+        return {"received": True}
+
+    elif event["type"] == "customer.subscription.deleted":
+        obj = event.get("data", {}).get("object")
+        if not obj or not isinstance(obj, dict):
+            return {"received": True}
 
-    return {"received": True}
+        customer_id = obj.get("customer")
+        if not customer_id:
+            return {"received": True}
 
+        user = await db.scalar(select(User).where(User.stripe_customer_id == customer_id))
+        if not user:
+            return {"received": True}
+
+        user.plan = "free"
+        user.stripe_subscription_id = None
+        await db.commit()
+        return {"received": True}
+
+    return {"received": True}
diff --git a/backend/app/api/chat.py b/backend/app/api/chat.py
index 71fc751fa90239dfe90bf76e3b30a7aa686d0c3f..d52dc47026e109df283984196581d417a4fea1dc
--- a/backend/app/api/chat.py
+++ b/backend/app/api/chat.py
@@ -133,6 +133,9 @@
 
     # If authenticated, ensure sufficient credits before opening stream
     if user is not None:
+        from app.services.credit_service import ensure_monthly_credits
+        await ensure_monthly_credits(db, user)
+        await db.commit()
         balance = await credit_service.get_user_credits(db, user.id)
         if balance < credit_service.MIN_CREDITS_FOR_CHAT:
             return JSONResponse(
diff --git a/backend/app/core/config.py b/backend/app/core/config.py
index 830f599a7b1ff02463684a9e84e90adfd6318cc1..a8eef6c5b4145c3710d46395bf26465dec42b4a7
--- a/backend/app/core/config.py
+++ b/backend/app/core/config.py
@@ -75,6 +75,10 @@
     CREDITS_PRO: int = 200000
     CREDITS_ENTERPRISE: int = 1000000
     SIGNUP_BONUS_CREDITS: int = 10000
+    # Subscription tiers
+    PLAN_FREE_MONTHLY_CREDITS: int = 10000
+    PLAN_PRO_MONTHLY_CREDITS: int = 100000
+    STRIPE_PRICE_PRO_MONTHLY: str = ''
 
     model_config = SettingsConfigDict(env_file=".env", env_file_encoding="utf-8", case_sensitive=False)
 
diff --git a/backend/app/models/tables.py b/backend/app/models/tables.py
index 2eb9239abb3f01f8a4103944db02efcb27f20149..9caeafd2d73fb05604695d962f9a0dc191da0bf2
--- a/backend/app/models/tables.py
+++ b/backend/app/models/tables.py
@@ -163,6 +163,10 @@
     email_verified: Mapped[Optional[datetime]] = mapped_column(sa.DateTime(timezone=True))
     credits_balance: Mapped[int] = mapped_column(sa.Integer, nullable=False, server_default=sa.text("0"))
     signup_bonus_granted_at: Mapped[Optional[datetime]] = mapped_column(sa.DateTime(timezone=True))
+    plan: Mapped[str] = mapped_column(sa.String(20), nullable=False, server_default=sa.text("'free'"))
+    stripe_customer_id: Mapped[Optional[str]] = mapped_column(sa.String(255))
+    stripe_subscription_id: Mapped[Optional[str]] = mapped_column(sa.String(255))
+    monthly_credits_granted_at: Mapped[Optional[datetime]] = mapped_column(sa.DateTime(timezone=True))
     created_at: Mapped[datetime] = mapped_column(sa.DateTime(timezone=True), server_default=sa.text("now()"))
     updated_at: Mapped[datetime] = mapped_column(
         sa.DateTime(timezone=True), server_default=sa.text("now()"), onupdate=sa.func.now()
diff --git a/backend/app/services/auth_service.py b/backend/app/services/auth_service.py
index cc72086b50ebd5497e7cdada96a60506fa7d9c05..6b57ee07cdff8f392a533172f8e7507a3e131cc4
--- a/backend/app/services/auth_service.py
+++ b/backend/app/services/auth_service.py
@@ -52,6 +52,7 @@
         email_verified=email_verified,
         credits_balance=SIGNUP_BONUS_CREDITS,
         signup_bonus_granted_at=datetime.utcnow(),
+        monthly_credits_granted_at=datetime.utcnow(),
     )
     db.add(user)
 
@@ -179,4 +180,3 @@
     await db.delete(vt)
     await db.commit()
     return vt
-
diff --git a/backend/app/services/credit_service.py b/backend/app/services/credit_service.py
index d89772b0418d1ebe1a79bba3de65f0112a550adb..a599453a961fb9222db98928201795c4fa4e574b
--- a/backend/app/services/credit_service.py
+++ b/backend/app/services/credit_service.py
@@ -7,6 +7,7 @@
 from sqlalchemy.ext.asyncio import AsyncSession
 
 from app.models.tables import CreditLedger, UsageRecord, User
+from app.core.config import settings
 
 
 # Token-to-credit rates by model tier
@@ -144,3 +145,56 @@
     db.add(usage)
     return usage
 
+
+async def ensure_monthly_credits(db: AsyncSession, user: User) -> None:
+    """Grant monthly credits if last grant was over 30 days ago.
+
+    Idempotency: checks CreditLedger for any recent 'monthly_allowance' within 30 days.
+    """
+    from datetime import datetime, timedelta, timezone
+
+    # Determine if grant needed based on timestamp
+    now = datetime.now(timezone.utc)
+    last = user.monthly_credits_granted_at
+    needs_grant = last is None or (now - last) >= timedelta(days=30)
+    if not needs_grant:
+        return
+
+    # Check ledger for idempotency within last 30 days
+    cutoff = now - timedelta(days=30)
+    existing = await db.scalar(
+        sa.select(CreditLedger)
+        .where(CreditLedger.user_id == user.id)
+        .where(CreditLedger.reason == "monthly_allowance")
+        .where(CreditLedger.created_at >= cutoff)
+    )
+    if existing:
+        # Still update marker to avoid repeatedly checking in future requests
+        user.monthly_credits_granted_at = now
+        await db.flush()
+        return
+
+    # Determine allowance by plan
+    plan = (user.plan or "free").lower()
+    if plan == "pro":
+        allowance = int(settings.PLAN_PRO_MONTHLY_CREDITS or 0)
+    else:
+        allowance = int(settings.PLAN_FREE_MONTHLY_CREDITS or 0)
+
+    if allowance <= 0:
+        # Nothing to grant
+        user.monthly_credits_granted_at = now
+        await db.flush()
+        return
+
+    # Grant credits and update marker
+    await credit_credits(
+        db,
+        user_id=user.id,
+        amount=allowance,
+        reason="monthly_allowance",
+        ref_type=None,
+        ref_id=None,
+    )
+    user.monthly_credits_granted_at = now
+    await db.flush()

file update:
diff --git a/backend/alembic/versions/20260206_0004_add_subscription_fields.py b/backend/alembic/versions/20260206_0004_add_subscription_fields.py
new file mode 100644
index 0000000000000000000000000000000000000000..f84be09226785ea3dbc1b413b3cfd2cb07dff81e
--- /dev/null
+++ b/backend/alembic/versions/20260206_0004_add_subscription_fields.py
@@ -0,0 +1,38 @@
+"""add subscription fields to users
+
+Revision ID: d4e5f6a7b8c9
+Revises: c3d4e5f6a7b8
+Create Date: 2026-02-06 00:40:00
+
+"""
+from __future__ import annotations
+
+from alembic import op
+import sqlalchemy as sa
+
+
+# revision identifiers, used by Alembic.
+revision = "d4e5f6a7b8c9"
+down_revision = "c3d4e5f6a7b8"
+branch_labels = None
+depends_on = None
+
+
+def upgrade() -> None:
+    # Add subscription-related columns to users
+    op.add_column(
+        "users",
+        sa.Column("plan", sa.String(length=20), nullable=False, server_default=sa.text("'free'")),
+    )
+    op.add_column("users", sa.Column("stripe_customer_id", sa.String(length=255), nullable=True))
+    op.add_column("users", sa.Column("stripe_subscription_id", sa.String(length=255), nullable=True))
+    op.add_column("users", sa.Column("monthly_credits_granted_at", sa.DateTime(timezone=True), nullable=True))
+
+
+def downgrade() -> None:
+    # Drop subscription-related columns from users
+    op.drop_column("users", "monthly_credits_granted_at")
+    op.drop_column("users", "stripe_subscription_id")
+    op.drop_column("users", "stripe_customer_id")
+    op.drop_column("users", "plan")
+
diff --git a/backend/app/api/billing.py b/backend/app/api/billing.py
index 851620df69f9c62fb3cab15feeedcafff44cc6bb..f99355cf848497a82c150ed57c5c5b2c20aa5e2e
--- a/backend/app/api/billing.py
+++ b/backend/app/api/billing.py
@@ -58,6 +58,47 @@
     return {"checkout_url": session.url}
 
 
+# Subscriptions
+@router.post("/subscribe")
+async def subscribe(
+    user: User = Depends(require_auth),
+    db: AsyncSession = Depends(get_db_session),
+):
+    if not settings.STRIPE_SECRET_KEY or not settings.STRIPE_PRICE_PRO_MONTHLY:
+        raise HTTPException(503, "Stripe not configured")
+
+    # Ensure customer exists
+    if not user.stripe_customer_id:
+        cust = stripe.Customer.create(email=user.email, name=user.name or None)
+        user.stripe_customer_id = cust.id
+        await db.commit()
+
+    # Create Checkout Session for subscription
+    session = stripe.checkout.Session.create(
+        mode="subscription",
+        line_items=[{"price": settings.STRIPE_PRICE_PRO_MONTHLY, "quantity": 1}],
+        success_url=f"{settings.FRONTEND_URL}/billing",
+        cancel_url=f"{settings.FRONTEND_URL}/billing",
+        customer=user.stripe_customer_id,
+        client_reference_id=str(user.id),
+    )
+    return {"checkout_url": session.url}
+
+
+@router.post("/portal")
+async def customer_portal(user: User = Depends(require_auth)):
+    if not settings.STRIPE_SECRET_KEY:
+        raise HTTPException(503, "Stripe not configured")
+    if not user.stripe_customer_id:
+        raise HTTPException(400, "No Stripe customer for user")
+
+    portal = stripe.billing_portal.Session.create(
+        customer=user.stripe_customer_id,
+        return_url=f"{settings.FRONTEND_URL}/billing",
+    )
+    return {"portal_url": portal.url}
+
+
 @router.post("/webhook")
 async def stripe_webhook(request: Request, db: AsyncSession = Depends(get_db_session)):
     payload = await request.body()
@@ -85,70 +126,196 @@
             logger.error("Invalid event structure: missing data.object")
             return {"received": True}
 
-        # Parse and validate client_reference_id (user_id)
-        try:
-            client_ref = session.get("client_reference_id")
-            if not client_ref:
-                logger.error("Missing client_reference_id in checkout session")
+        mode = session.get("mode")
+
+        # Handle subscription checkout
+        if mode == "subscription":
+            try:
+                client_ref = session.get("client_reference_id")
+                if not client_ref:
+                    logger.error("Missing client_reference_id in subscription session")
+                    return {"received": True}
+                user_id = uuid.UUID(client_ref)
+            except (ValueError, TypeError) as e:
+                logger.error("Invalid client_reference_id: %s", e)
+                return {"received": True}
+
+            user = await db.get(User, user_id)
+            if not user:
+                logger.warning("Subscription completed for non-existent user %s", user_id)
                 return {"received": True}
-            user_id = uuid.UUID(client_ref)
-        except (ValueError, TypeError) as e:
-            logger.error("Invalid client_reference_id: %s", e)
+
+            subscription_id = session.get("subscription")
+            customer_id = session.get("customer")
+
+            # Update user plan and subscription/customer ids
+            user.plan = "pro"
+            if subscription_id:
+                user.stripe_subscription_id = subscription_id
+            if customer_id and not user.stripe_customer_id:
+                user.stripe_customer_id = customer_id
+
+            # Idempotency: only one monthly grant per subscription id at start
+            existing = await db.scalar(
+                select(CreditLedger).where(
+                    CreditLedger.ref_type == "stripe_subscription",
+                    CreditLedger.ref_id == (subscription_id or ""),
+                )
+            )
+
+            if not existing:
+                try:
+                    await credit_credits(
+                        db,
+                        user_id=user.id,
+                        amount=int(settings.PLAN_PRO_MONTHLY_CREDITS or 0),
+                        reason="monthly_allowance",
+                        ref_type="stripe_subscription",
+                        ref_id=subscription_id or "",
+                    )
+                    await db.commit()
+                    logger.info(
+                        "Subscription start credits granted: user_id=%s, subscription=%s",
+                        user.id,
+                        subscription_id,
+                    )
+                except Exception as e:
+                    await db.rollback()
+                    logger.error("Failed to grant subscription start credits: %s", e)
+                    raise HTTPException(500, "Database error")
+            else:
+                await db.commit()
+
             return {"received": True}
 
-        # Parse and validate credits amount
-        try:
-            metadata = session.get("metadata", {})
-            credits_str = metadata.get("credits")
-            if not credits_str:
-                logger.error("Missing credits in session metadata")
+        # Handle one-time credit pack checkout
+        if mode == "payment":
+            # Parse and validate client_reference_id (user_id)
+            try:
+                client_ref = session.get("client_reference_id")
+                if not client_ref:
+                    logger.error("Missing client_reference_id in checkout session")
+                    return {"received": True}
+                user_id = uuid.UUID(client_ref)
+            except (ValueError, TypeError) as e:
+                logger.error("Invalid client_reference_id: %s", e)
                 return {"received": True}
-            credits = int(credits_str)
-            if credits <= 0:
-                logger.error("Invalid credits amount: %d", credits)
+
+            # Parse and validate credits amount
+            try:
+                metadata = session.get("metadata", {})
+                credits_str = metadata.get("credits")
+                if not credits_str:
+                    logger.error("Missing credits in session metadata")
+                    return {"received": True}
+                credits = int(credits_str)
+                if credits <= 0:
+                    logger.error("Invalid credits amount: %d", credits)
+                    return {"received": True}
+            except (ValueError, TypeError) as e:
+                logger.error("Cannot parse credits from metadata: %s", e)
+                return {"received": True}
+
+            # Get payment_intent for idempotency
+            payment_intent = session.get("payment_intent")
+            if not payment_intent:
+                logger.warning("Checkout session has no payment_intent, skipping for safety")
                 return {"received": True}
-        except (ValueError, TypeError) as e:
-            logger.error("Cannot parse credits from metadata: %s", e)
+
+            # Verify user exists
+            user = await db.get(User, user_id)
+            if not user:
+                logger.warning("Webhook for non-existent user %s", user_id)
+                return {"received": True}
+
+            # Idempotency check
+            existing = await db.scalar(
+                select(CreditLedger).where(
+                    CreditLedger.ref_type == "stripe_payment",
+                    CreditLedger.ref_id == payment_intent,
+                )
+            )
+
+            if not existing:
+                try:
+                    await credit_credits(
+                        db,
+                        user_id,
+                        credits,
+                        reason="purchase",
+                        ref_type="stripe_payment",
+                        ref_id=payment_intent,
+                    )
+                    await db.commit()
+                    logger.info(
+                        "Credits granted: user_id=%s, credits=%d, payment_intent=%s",
+                        user_id,
+                        credits,
+                        payment_intent,
+                    )
+                except Exception as e:
+                    await db.rollback()
+                    logger.error("Failed to grant credits: %s", e)
+                    # Return 5xx so Stripe retries
+                    raise HTTPException(500, "Database error")
+            return {"received": True}
+
+    elif event["type"] == "invoice.payment_succeeded":
+    
+        obj = event.get("data", {}).get("object")
+        if not obj or not isinstance(obj, dict):
             return {"received": True}
 
-        # Get payment_intent for idempotency
-        payment_intent = session.get("payment_intent")
-        if not payment_intent:
-            logger.warning("Checkout session has no payment_intent, skipping for safety")
+        invoice_id = obj.get("id")
+        customer_id = obj.get("customer")
+        if not invoice_id or not customer_id:
             return {"received": True}
 
-        # Verify user exists
-        user = await db.get(User, user_id)
+        # Find user by customer id
+        user = await db.scalar(select(User).where(User.stripe_customer_id == customer_id))
         if not user:
-            logger.warning("Webhook for non-existent user %s", user_id)
             return {"received": True}
 
-        # Idempotency check
+        # Idempotency: ensure we haven't granted for this invoice
         existing = await db.scalar(
             select(CreditLedger).where(
-                CreditLedger.ref_type == "stripe_payment",
-                CreditLedger.ref_id == payment_intent,
+                CreditLedger.ref_type == "stripe_invoice",
+                CreditLedger.ref_id == invoice_id,
             )
         )
-
         if not existing:
             try:
                 await credit_credits(
                     db,
-                    user_id,
-                    credits,
-                    reason="purchase",
-                    ref_type="stripe_payment",
-                    ref_id=payment_intent,
+                    user_id=user.id,
+                    amount=int(settings.PLAN_PRO_MONTHLY_CREDITS or 0),
+                    reason="monthly_allowance",
+                    ref_type="stripe_invoice",
+                    ref_id=invoice_id,
                 )
                 await db.commit()
-                logger.info("Credits granted: user_id=%s, credits=%d, payment_intent=%s",
-                           user_id, credits, payment_intent)
             except Exception as e:
                 await db.rollback()
-                logger.error("Failed to grant credits: %s", e)
-                # Return 5xx so Stripe retries
+                logger.error("Failed to grant monthly credits on invoice: %s", e)
                 raise HTTPException(500, "Database error")
+        return {"received": True}
+
+    elif event["type"] == "customer.subscription.deleted":
+        obj = event.get("data", {}).get("object")
+        if not obj or not isinstance(obj, dict):
+            return {"received": True}
 
-    return {"received": True}
+        customer_id = obj.get("customer")
+        if not customer_id:
+            return {"received": True}
 
+        user = await db.scalar(select(User).where(User.stripe_customer_id == customer_id))
+        if not user:
+            return {"received": True}
+
+        user.plan = "free"
+        user.stripe_subscription_id = None
+        await db.commit()
+        return {"received": True}
+
+    return {"received": True}
diff --git a/backend/app/api/chat.py b/backend/app/api/chat.py
index 71fc751fa90239dfe90bf76e3b30a7aa686d0c3f..d52dc47026e109df283984196581d417a4fea1dc
--- a/backend/app/api/chat.py
+++ b/backend/app/api/chat.py
@@ -133,6 +133,9 @@
 
     # If authenticated, ensure sufficient credits before opening stream
     if user is not None:
+        from app.services.credit_service import ensure_monthly_credits
+        await ensure_monthly_credits(db, user)
+        await db.commit()
         balance = await credit_service.get_user_credits(db, user.id)
         if balance < credit_service.MIN_CREDITS_FOR_CHAT:
             return JSONResponse(
diff --git a/backend/app/core/config.py b/backend/app/core/config.py
index 830f599a7b1ff02463684a9e84e90adfd6318cc1..a8eef6c5b4145c3710d46395bf26465dec42b4a7
--- a/backend/app/core/config.py
+++ b/backend/app/core/config.py
@@ -75,6 +75,10 @@
     CREDITS_PRO: int = 200000
     CREDITS_ENTERPRISE: int = 1000000
     SIGNUP_BONUS_CREDITS: int = 10000
+    # Subscription tiers
+    PLAN_FREE_MONTHLY_CREDITS: int = 10000
+    PLAN_PRO_MONTHLY_CREDITS: int = 100000
+    STRIPE_PRICE_PRO_MONTHLY: str = ''
 
     model_config = SettingsConfigDict(env_file=".env", env_file_encoding="utf-8", case_sensitive=False)
 
diff --git a/backend/app/models/tables.py b/backend/app/models/tables.py
index 2eb9239abb3f01f8a4103944db02efcb27f20149..9caeafd2d73fb05604695d962f9a0dc191da0bf2
--- a/backend/app/models/tables.py
+++ b/backend/app/models/tables.py
@@ -163,6 +163,10 @@
     email_verified: Mapped[Optional[datetime]] = mapped_column(sa.DateTime(timezone=True))
     credits_balance: Mapped[int] = mapped_column(sa.Integer, nullable=False, server_default=sa.text("0"))
     signup_bonus_granted_at: Mapped[Optional[datetime]] = mapped_column(sa.DateTime(timezone=True))
+    plan: Mapped[str] = mapped_column(sa.String(20), nullable=False, server_default=sa.text("'free'"))
+    stripe_customer_id: Mapped[Optional[str]] = mapped_column(sa.String(255))
+    stripe_subscription_id: Mapped[Optional[str]] = mapped_column(sa.String(255))
+    monthly_credits_granted_at: Mapped[Optional[datetime]] = mapped_column(sa.DateTime(timezone=True))
     created_at: Mapped[datetime] = mapped_column(sa.DateTime(timezone=True), server_default=sa.text("now()"))
     updated_at: Mapped[datetime] = mapped_column(
         sa.DateTime(timezone=True), server_default=sa.text("now()"), onupdate=sa.func.now()
diff --git a/backend/app/services/auth_service.py b/backend/app/services/auth_service.py
index cc72086b50ebd5497e7cdada96a60506fa7d9c05..6b57ee07cdff8f392a533172f8e7507a3e131cc4
--- a/backend/app/services/auth_service.py
+++ b/backend/app/services/auth_service.py
@@ -52,6 +52,7 @@
         email_verified=email_verified,
         credits_balance=SIGNUP_BONUS_CREDITS,
         signup_bonus_granted_at=datetime.utcnow(),
+        monthly_credits_granted_at=datetime.utcnow(),
     )
     db.add(user)
 
@@ -179,4 +180,3 @@
     await db.delete(vt)
     await db.commit()
     return vt
-
diff --git a/backend/app/services/credit_service.py b/backend/app/services/credit_service.py
index d89772b0418d1ebe1a79bba3de65f0112a550adb..a599453a961fb9222db98928201795c4fa4e574b
--- a/backend/app/services/credit_service.py
+++ b/backend/app/services/credit_service.py
@@ -7,6 +7,7 @@
 from sqlalchemy.ext.asyncio import AsyncSession
 
 from app.models.tables import CreditLedger, UsageRecord, User
+from app.core.config import settings
 
 
 # Token-to-credit rates by model tier
@@ -144,3 +145,56 @@
     db.add(usage)
     return usage
 
+
+async def ensure_monthly_credits(db: AsyncSession, user: User) -> None:
+    """Grant monthly credits if last grant was over 30 days ago.
+
+    Idempotency: checks CreditLedger for any recent 'monthly_allowance' within 30 days.
+    """
+    from datetime import datetime, timedelta, timezone
+
+    # Determine if grant needed based on timestamp
+    now = datetime.now(timezone.utc)
+    last = user.monthly_credits_granted_at
+    needs_grant = last is None or (now - last) >= timedelta(days=30)
+    if not needs_grant:
+        return
+
+    # Check ledger for idempotency within last 30 days
+    cutoff = now - timedelta(days=30)
+    existing = await db.scalar(
+        sa.select(CreditLedger)
+        .where(CreditLedger.user_id == user.id)
+        .where(CreditLedger.reason == "monthly_allowance")
+        .where(CreditLedger.created_at >= cutoff)
+    )
+    if existing:
+        # Still update marker to avoid repeatedly checking in future requests
+        user.monthly_credits_granted_at = now
+        await db.flush()
+        return
+
+    # Determine allowance by plan
+    plan = (user.plan or "free").lower()
+    if plan == "pro":
+        allowance = int(settings.PLAN_PRO_MONTHLY_CREDITS or 0)
+    else:
+        allowance = int(settings.PLAN_FREE_MONTHLY_CREDITS or 0)
+
+    if allowance <= 0:
+        # Nothing to grant
+        user.monthly_credits_granted_at = now
+        await db.flush()
+        return
+
+    # Grant credits and update marker
+    await credit_credits(
+        db,
+        user_id=user.id,
+        amount=allowance,
+        reason="monthly_allowance",
+        ref_type=None,
+        ref_id=None,
+    )
+    user.monthly_credits_granted_at = now
+    await db.flush()

exec
bash -lc "rg -n \"monthly_credits_granted_at|plan\\: Mapped|ensure_monthly_credits|/subscribe|/portal|STRIPE_PRICE_PRO_MONTHLY|PLAN_PRO_MONTHLY_CREDITS|PLAN_FREE_MONTHLY_CREDITS|stripe_subscription_id|stripe_customer_id\" backend -S" in /Users/mayijie/Projects/Code/010_DocTalk succeeded in 12ms:
backend/alembic/versions/20260206_0004_add_subscription_fields.py:27:    op.add_column("users", sa.Column("stripe_customer_id", sa.String(length=255), nullable=True))
backend/alembic/versions/20260206_0004_add_subscription_fields.py:28:    op.add_column("users", sa.Column("stripe_subscription_id", sa.String(length=255), nullable=True))
backend/alembic/versions/20260206_0004_add_subscription_fields.py:29:    op.add_column("users", sa.Column("monthly_credits_granted_at", sa.DateTime(timezone=True), nullable=True))
backend/alembic/versions/20260206_0004_add_subscription_fields.py:34:    op.drop_column("users", "monthly_credits_granted_at")
backend/alembic/versions/20260206_0004_add_subscription_fields.py:35:    op.drop_column("users", "stripe_subscription_id")
backend/alembic/versions/20260206_0004_add_subscription_fields.py:36:    op.drop_column("users", "stripe_customer_id")
backend/app/services/credit_service.py:149:async def ensure_monthly_credits(db: AsyncSession, user: User) -> None:
backend/app/services/credit_service.py:158:    last = user.monthly_credits_granted_at
backend/app/services/credit_service.py:173:        user.monthly_credits_granted_at = now
backend/app/services/credit_service.py:180:        allowance = int(settings.PLAN_PRO_MONTHLY_CREDITS or 0)
backend/app/services/credit_service.py:182:        allowance = int(settings.PLAN_FREE_MONTHLY_CREDITS or 0)
backend/app/services/credit_service.py:186:        user.monthly_credits_granted_at = now
backend/app/services/credit_service.py:199:    user.monthly_credits_granted_at = now
backend/app/services/auth_service.py:55:        monthly_credits_granted_at=datetime.utcnow(),
backend/app/api/billing.py:62:@router.post("/subscribe")
backend/app/api/billing.py:67:    if not settings.STRIPE_SECRET_KEY or not settings.STRIPE_PRICE_PRO_MONTHLY:
backend/app/api/billing.py:71:    if not user.stripe_customer_id:
backend/app/api/billing.py:73:        user.stripe_customer_id = cust.id
backend/app/api/billing.py:79:        line_items=[{"price": settings.STRIPE_PRICE_PRO_MONTHLY, "quantity": 1}],
backend/app/api/billing.py:82:        customer=user.stripe_customer_id,
file update:
diff --git a/backend/alembic/versions/20260206_0004_add_subscription_fields.py b/backend/alembic/versions/20260206_0004_add_subscription_fields.py
new file mode 100644
index 0000000000000000000000000000000000000000..f84be09226785ea3dbc1b413b3cfd2cb07dff81e
--- /dev/null
+++ b/backend/alembic/versions/20260206_0004_add_subscription_fields.py
@@ -0,0 +1,38 @@
+"""add subscription fields to users
+
+Revision ID: d4e5f6a7b8c9
+Revises: c3d4e5f6a7b8
+Create Date: 2026-02-06 00:40:00
+
+"""
+from __future__ import annotations
+
+from alembic import op
+import sqlalchemy as sa
+
+
+# revision identifiers, used by Alembic.
+revision = "d4e5f6a7b8c9"
+down_revision = "c3d4e5f6a7b8"
+branch_labels = None
+depends_on = None
+
+
+def upgrade() -> None:
+    # Add subscription-related columns to users
+    op.add_column(
+        "users",
+        sa.Column("plan", sa.String(length=20), nullable=False, server_default=sa.text("'free'")),
+    )
+    op.add_column("users", sa.Column("stripe_customer_id", sa.String(length=255), nullable=True))
+    op.add_column("users", sa.Column("stripe_subscription_id", sa.String(length=255), nullable=True))
+    op.add_column("users", sa.Column("monthly_credits_granted_at", sa.DateTime(timezone=True), nullable=True))
+
+
+def downgrade() -> None:
+    # Drop subscription-related columns from users
+    op.drop_column("users", "monthly_credits_granted_at")
+    op.drop_column("users", "stripe_subscription_id")
+    op.drop_column("users", "stripe_customer_id")
+    op.drop_column("users", "plan")
+
diff --git a/backend/app/api/billing.py b/backend/app/api/billing.py
index 851620df69f9c62fb3cab15feeedcafff44cc6bb..f99355cf848497a82c150ed57c5c5b2c20aa5e2e
--- a/backend/app/api/billing.py
+++ b/backend/app/api/billing.py
@@ -58,6 +58,47 @@
     return {"checkout_url": session.url}
 
 
+# Subscriptions
+@router.post("/subscribe")
+async def subscribe(
+    user: User = Depends(require_auth),
+    db: AsyncSession = Depends(get_db_session),
+):
+    if not settings.STRIPE_SECRET_KEY or not settings.STRIPE_PRICE_PRO_MONTHLY:
+        raise HTTPException(503, "Stripe not configured")
+
+    # Ensure customer exists
+    if not user.stripe_customer_id:
+        cust = stripe.Customer.create(email=user.email, name=user.name or None)
+        user.stripe_customer_id = cust.id
+        await db.commit()
+
+    # Create Checkout Session for subscription
+    session = stripe.checkout.Session.create(
+        mode="subscription",
+        line_items=[{"price": settings.STRIPE_PRICE_PRO_MONTHLY, "quantity": 1}],
+        success_url=f"{settings.FRONTEND_URL}/billing",
+        cancel_url=f"{settings.FRONTEND_URL}/billing",
+        customer=user.stripe_customer_id,
+        client_reference_id=str(user.id),
+    )
+    return {"checkout_url": session.url}
+
+
+@router.post("/portal")
+async def customer_portal(user: User = Depends(require_auth)):
+    if not settings.STRIPE_SECRET_KEY:
+        raise HTTPException(503, "Stripe not configured")
+    if not user.stripe_customer_id:
+        raise HTTPException(400, "No Stripe customer for user")
+
+    portal = stripe.billing_portal.Session.create(
+        customer=user.stripe_customer_id,
+        return_url=f"{settings.FRONTEND_URL}/billing",
+    )
+    return {"portal_url": portal.url}
+
+
 @router.post("/webhook")
 async def stripe_webhook(request: Request, db: AsyncSession = Depends(get_db_session)):
     payload = await request.body()
@@ -85,70 +126,196 @@
             logger.error("Invalid event structure: missing data.object")
             return {"received": True}
 
-        # Parse and validate client_reference_id (user_id)
-        try:
-            client_ref = session.get("client_reference_id")
-            if not client_ref:
-                logger.error("Missing client_reference_id in checkout session")
+        mode = session.get("mode")
+
+        # Handle subscription checkout
+        if mode == "subscription":
+            try:
+                client_ref = session.get("client_reference_id")
+                if not client_ref:
+                    logger.error("Missing client_reference_id in subscription session")
+                    return {"received": True}
+                user_id = uuid.UUID(client_ref)
+            except (ValueError, TypeError) as e:
+                logger.error("Invalid client_reference_id: %s", e)
+                return {"received": True}
+
+            user = await db.get(User, user_id)
+            if not user:
+                logger.warning("Subscription completed for non-existent user %s", user_id)
                 return {"received": True}
-            user_id = uuid.UUID(client_ref)
-        except (ValueError, TypeError) as e:
-            logger.error("Invalid client_reference_id: %s", e)
+
+            subscription_id = session.get("subscription")
+            customer_id = session.get("customer")
+
+            # Update user plan and subscription/customer ids
+            user.plan = "pro"
+            if subscription_id:
+                user.stripe_subscription_id = subscription_id
+            if customer_id and not user.stripe_customer_id:
+                user.stripe_customer_id = customer_id
+
+            # Idempotency: only one monthly grant per subscription id at start
+            existing = await db.scalar(
+                select(CreditLedger).where(
+                    CreditLedger.ref_type == "stripe_subscription",
+                    CreditLedger.ref_id == (subscription_id or ""),
+                )
+            )
+
+            if not existing:
+                try:
+                    await credit_credits(
+                        db,
+                        user_id=user.id,
+                        amount=int(settings.PLAN_PRO_MONTHLY_CREDITS or 0),
+                        reason="monthly_allowance",
+                        ref_type="stripe_subscription",
+                        ref_id=subscription_id or "",
+                    )
+                    await db.commit()
+                    logger.info(
+                        "Subscription start credits granted: user_id=%s, subscription=%s",
+                        user.id,
+                        subscription_id,
+                    )
+                except Exception as e:
+                    await db.rollback()
+                    logger.error("Failed to grant subscription start credits: %s", e)
+                    raise HTTPException(500, "Database error")
+            else:
+                await db.commit()
+
             return {"received": True}
 
-        # Parse and validate credits amount
-        try:
-            metadata = session.get("metadata", {})
-            credits_str = metadata.get("credits")
-            if not credits_str:
-                logger.error("Missing credits in session metadata")
+        # Handle one-time credit pack checkout
+        if mode == "payment":
+            # Parse and validate client_reference_id (user_id)
+            try:
+                client_ref = session.get("client_reference_id")
+                if not client_ref:
+                    logger.error("Missing client_reference_id in checkout session")
+                    return {"received": True}
+                user_id = uuid.UUID(client_ref)
+            except (ValueError, TypeError) as e:
+                logger.error("Invalid client_reference_id: %s", e)
                 return {"received": True}
-            credits = int(credits_str)
-            if credits <= 0:
-                logger.error("Invalid credits amount: %d", credits)
+
+            # Parse and validate credits amount
+            try:
+                metadata = session.get("metadata", {})
+                credits_str = metadata.get("credits")
+                if not credits_str:
+                    logger.error("Missing credits in session metadata")
+                    return {"received": True}
+                credits = int(credits_str)
+                if credits <= 0:
+                    logger.error("Invalid credits amount: %d", credits)
+                    return {"received": True}
+            except (ValueError, TypeError) as e:
+                logger.error("Cannot parse credits from metadata: %s", e)
+                return {"received": True}
+
+            # Get payment_intent for idempotency
+            payment_intent = session.get("payment_intent")
+            if not payment_intent:
+                logger.warning("Checkout session has no payment_intent, skipping for safety")
                 return {"received": True}
-        except (ValueError, TypeError) as e:
-            logger.error("Cannot parse credits from metadata: %s", e)
+
+            # Verify user exists
+            user = await db.get(User, user_id)
+            if not user:
+                logger.warning("Webhook for non-existent user %s", user_id)
+                return {"received": True}
+
+            # Idempotency check
+            existing = await db.scalar(
+                select(CreditLedger).where(
+                    CreditLedger.ref_type == "stripe_payment",
+                    CreditLedger.ref_id == payment_intent,
+                )
+            )
+
+            if not existing:
+                try:
+                    await credit_credits(
+                        db,
+                        user_id,
+                        credits,
+                        reason="purchase",
+                        ref_type="stripe_payment",
+                        ref_id=payment_intent,
+                    )
+                    await db.commit()
+                    logger.info(
+                        "Credits granted: user_id=%s, credits=%d, payment_intent=%s",
+                        user_id,
+                        credits,
+                        payment_intent,
+                    )
+                except Exception as e:
+                    await db.rollback()
+                    logger.error("Failed to grant credits: %s", e)
+                    # Return 5xx so Stripe retries
+                    raise HTTPException(500, "Database error")
+            return {"received": True}
+
+    elif event["type"] == "invoice.payment_succeeded":
+    
+        obj = event.get("data", {}).get("object")
+        if not obj or not isinstance(obj, dict):
             return {"received": True}
 
-        # Get payment_intent for idempotency
-        payment_intent = session.get("payment_intent")
-        if not payment_intent:
-            logger.warning("Checkout session has no payment_intent, skipping for safety")
+        invoice_id = obj.get("id")
+        customer_id = obj.get("customer")
+        if not invoice_id or not customer_id:
             return {"received": True}
 
-        # Verify user exists
-        user = await db.get(User, user_id)
+        # Find user by customer id
+        user = await db.scalar(select(User).where(User.stripe_customer_id == customer_id))
         if not user:
-            logger.warning("Webhook for non-existent user %s", user_id)
             return {"received": True}
 
-        # Idempotency check
+        # Idempotency: ensure we haven't granted for this invoice
         existing = await db.scalar(
             select(CreditLedger).where(
-                CreditLedger.ref_type == "stripe_payment",
-                CreditLedger.ref_id == payment_intent,
+                CreditLedger.ref_type == "stripe_invoice",
+                CreditLedger.ref_id == invoice_id,
             )
         )
-
         if not existing:
             try:
                 await credit_credits(
                     db,
-                    user_id,
-                    credits,
-                    reason="purchase",
-                    ref_type="stripe_payment",
-                    ref_id=payment_intent,
+                    user_id=user.id,
+                    amount=int(settings.PLAN_PRO_MONTHLY_CREDITS or 0),
+                    reason="monthly_allowance",
+                    ref_type="stripe_invoice",
+                    ref_id=invoice_id,
                 )
                 await db.commit()
-                logger.info("Credits granted: user_id=%s, credits=%d, payment_intent=%s",
-                           user_id, credits, payment_intent)
             except Exception as e:
                 await db.rollback()
-                logger.error("Failed to grant credits: %s", e)
-                # Return 5xx so Stripe retries
+                logger.error("Failed to grant monthly credits on invoice: %s", e)
                 raise HTTPException(500, "Database error")
+        return {"received": True}
+
+    elif event["type"] == "customer.subscription.deleted":
+        obj = event.get("data", {}).get("object")
+        if not obj or not isinstance(obj, dict):
+            return {"received": True}
 
-    return {"received": True}
+        customer_id = obj.get("customer")
+        if not customer_id:
+            return {"received": True}
 
+        user = await db.scalar(select(User).where(User.stripe_customer_id == customer_id))
+        if not user:
+            return {"received": True}
+
+        user.plan = "free"
+        user.stripe_subscription_id = None
+        await db.commit()
+        return {"received": True}
+
+    return {"received": True}
diff --git a/backend/app/api/chat.py b/backend/app/api/chat.py
index 71fc751fa90239dfe90bf76e3b30a7aa686d0c3f..d52dc47026e109df283984196581d417a4fea1dc
--- a/backend/app/api/chat.py
+++ b/backend/app/api/chat.py
@@ -133,6 +133,9 @@
 
     # If authenticated, ensure sufficient credits before opening stream
     if user is not None:
+        from app.services.credit_service import ensure_monthly_credits
+        await ensure_monthly_credits(db, user)
+        await db.commit()
         balance = await credit_service.get_user_credits(db, user.id)
         if balance < credit_service.MIN_CREDITS_FOR_CHAT:
             return JSONResponse(
diff --git a/backend/app/core/config.py b/backend/app/core/config.py
index 830f599a7b1ff02463684a9e84e90adfd6318cc1..a8eef6c5b4145c3710d46395bf26465dec42b4a7
--- a/backend/app/core/config.py
+++ b/backend/app/core/config.py
@@ -75,6 +75,10 @@
     CREDITS_PRO: int = 200000
     CREDITS_ENTERPRISE: int = 1000000
     SIGNUP_BONUS_CREDITS: int = 10000
+    # Subscription tiers
+    PLAN_FREE_MONTHLY_CREDITS: int = 10000
+    PLAN_PRO_MONTHLY_CREDITS: int = 100000
+    STRIPE_PRICE_PRO_MONTHLY: str = ''
 
     model_config = SettingsConfigDict(env_file=".env", env_file_encoding="utf-8", case_sensitive=False)
 
diff --git a/backend/app/models/tables.py b/backend/app/models/tables.py
index 2eb9239abb3f01f8a4103944db02efcb27f20149..9caeafd2d73fb05604695d962f9a0dc191da0bf2
--- a/backend/app/models/tables.py
+++ b/backend/app/models/tables.py
@@ -163,6 +163,10 @@
     email_verified: Mapped[Optional[datetime]] = mapped_column(sa.DateTime(timezone=True))
     credits_balance: Mapped[int] = mapped_column(sa.Integer, nullable=False, server_default=sa.text("0"))
     signup_bonus_granted_at: Mapped[Optional[datetime]] = mapped_column(sa.DateTime(timezone=True))
+    plan: Mapped[str] = mapped_column(sa.String(20), nullable=False, server_default=sa.text("'free'"))
+    stripe_customer_id: Mapped[Optional[str]] = mapped_column(sa.String(255))
+    stripe_subscription_id: Mapped[Optional[str]] = mapped_column(sa.String(255))
+    monthly_credits_granted_at: Mapped[Optional[datetime]] = mapped_column(sa.DateTime(timezone=True))
     created_at: Mapped[datetime] = mapped_column(sa.DateTime(timezone=True), server_default=sa.text("now()"))
     updated_at: Mapped[datetime] = mapped_column(
         sa.DateTime(timezone=True), server_default=sa.text("now()"), onupdate=sa.func.now()
diff --git a/backend/app/services/auth_service.py b/backend/app/services/auth_service.py
index cc72086b50ebd5497e7cdada96a60506fa7d9c05..6b57ee07cdff8f392a533172f8e7507a3e131cc4
--- a/backend/app/services/auth_service.py
+++ b/backend/app/services/auth_service.py
@@ -52,6 +52,7 @@
         email_verified=email_verified,
         credits_balance=SIGNUP_BONUS_CREDITS,
         signup_bonus_granted_at=datetime.utcnow(),
+        monthly_credits_granted_at=datetime.utcnow(),
     )
     db.add(user)
 
@@ -179,4 +180,3 @@
     await db.delete(vt)
     await db.commit()
     return vt
-
diff --git a/backend/app/services/credit_service.py b/backend/app/services/credit_service.py
index d89772b0418d1ebe1a79bba3de65f0112a550adb..a599453a961fb9222db98928201795c4fa4e574b
--- a/backend/app/services/credit_service.py
+++ b/backend/app/services/credit_service.py
@@ -7,6 +7,7 @@
 from sqlalchemy.ext.asyncio import AsyncSession
 
 from app.models.tables import CreditLedger, UsageRecord, User
+from app.core.config import settings
 
 
 # Token-to-credit rates by model tier
@@ -144,3 +145,56 @@
     db.add(usage)
     return usage
 
+
+async def ensure_monthly_credits(db: AsyncSession, user: User) -> None:
+    """Grant monthly credits if last grant was over 30 days ago.
+
+    Idempotency: checks CreditLedger for any recent 'monthly_allowance' within 30 days.
+    """
+    from datetime import datetime, timedelta, timezone
+
+    # Determine if grant needed based on timestamp
+    now = datetime.now(timezone.utc)
+    last = user.monthly_credits_granted_at
+    needs_grant = last is None or (now - last) >= timedelta(days=30)
+    if not needs_grant:
+        return
+
+    # Check ledger for idempotency within last 30 days
+    cutoff = now - timedelta(days=30)
+    existing = await db.scalar(
+        sa.select(CreditLedger)
+        .where(CreditLedger.user_id == user.id)
+        .where(CreditLedger.reason == "monthly_allowance")
+        .where(CreditLedger.created_at >= cutoff)
+    )
+    if existing:
+        # Still update marker to avoid repeatedly checking in future requests
+        user.monthly_credits_granted_at = now
+        await db.flush()
+        return
+
+    # Determine allowance by plan
+    plan = (user.plan or "free").lower()
+    if plan == "pro":
+        allowance = int(settings.PLAN_PRO_MONTHLY_CREDITS or 0)
+    else:
+        allowance = int(settings.PLAN_FREE_MONTHLY_CREDITS or 0)
+
+    if allowance <= 0:
+        # Nothing to grant
+        user.monthly_credits_granted_at = now
+        await db.flush()
+        return
+
+    # Grant credits and update marker
+    await credit_credits(
+        db,
+        user_id=user.id,
+        amount=allowance,
+        reason="monthly_allowance",
+        ref_type=None,
+        ref_id=None,
+    )
+    user.monthly_credits_granted_at = now
+    await db.flush()

exec
bash -lc "sed -n '1,220p' backend/tests/test_smoke.py" in /Users/mayijie/Projects/Code/010_DocTalk succeeded in 16ms:
import uuid

import pytest


# Minimal valid-ish single-page PDF bytes for testing upload
MINIMAL_PDF = (
    b"%PDF-1.0\n1 0 obj<</Type/Catalog/Pages 2 0 R>>endobj 2 0 obj<</Type/Pages/Kids[3 0 R]/Count 1>>endobj "
    b"3 0 obj<</Type/Page/MediaBox[0 0 612 792]/Parent 2 0 R/Resources<<>>>>endobj\nxref\n0 4\n" 
    b"0000000000 65535 f \n0000000009 00000 n \n0000000058 00000 n \n0000000115 00000 n \n" 
    b"trailer<</Size 4/Root 1 0 R>>\nstartxref\n206\n%%EOF"
)


@pytest.mark.asyncio
async def test_health(client):
    resp = await client.get("/health")
    assert resp.status_code == 200
    data = resp.json()
    assert data.get("status") == "ok"
file update:
diff --git a/backend/alembic/versions/20260206_0004_add_subscription_fields.py b/backend/alembic/versions/20260206_0004_add_subscription_fields.py
new file mode 100644
index 0000000000000000000000000000000000000000..f84be09226785ea3dbc1b413b3cfd2cb07dff81e
--- /dev/null
+++ b/backend/alembic/versions/20260206_0004_add_subscription_fields.py
@@ -0,0 +1,38 @@
+"""add subscription fields to users
+
+Revision ID: d4e5f6a7b8c9
+Revises: c3d4e5f6a7b8
+Create Date: 2026-02-06 00:40:00
+
+"""
+from __future__ import annotations
+
+from alembic import op
+import sqlalchemy as sa
+
+
+# revision identifiers, used by Alembic.
+revision = "d4e5f6a7b8c9"
+down_revision = "c3d4e5f6a7b8"
+branch_labels = None
+depends_on = None
+
+
+def upgrade() -> None:
+    # Add subscription-related columns to users
+    op.add_column(
+        "users",
+        sa.Column("plan", sa.String(length=20), nullable=False, server_default=sa.text("'free'")),
+    )
+    op.add_column("users", sa.Column("stripe_customer_id", sa.String(length=255), nullable=True))
+    op.add_column("users", sa.Column("stripe_subscription_id", sa.String(length=255), nullable=True))
+    op.add_column("users", sa.Column("monthly_credits_granted_at", sa.DateTime(timezone=True), nullable=True))
+
+
+def downgrade() -> None:
+    # Drop subscription-related columns from users
+    op.drop_column("users", "monthly_credits_granted_at")
+    op.drop_column("users", "stripe_subscription_id")
+    op.drop_column("users", "stripe_customer_id")
+    op.drop_column("users", "plan")
+
diff --git a/backend/app/api/billing.py b/backend/app/api/billing.py
index 851620df69f9c62fb3cab15feeedcafff44cc6bb..f99355cf848497a82c150ed57c5c5b2c20aa5e2e
--- a/backend/app/api/billing.py
+++ b/backend/app/api/billing.py
@@ -58,6 +58,47 @@
     return {"checkout_url": session.url}
 
 
+# Subscriptions
+@router.post("/subscribe")
+async def subscribe(
+    user: User = Depends(require_auth),
+    db: AsyncSession = Depends(get_db_session),
+):
+    if not settings.STRIPE_SECRET_KEY or not settings.STRIPE_PRICE_PRO_MONTHLY:
+        raise HTTPException(503, "Stripe not configured")
+
+    # Ensure customer exists
+    if not user.stripe_customer_id:
+        cust = stripe.Customer.create(email=user.email, name=user.name or None)
+        user.stripe_customer_id = cust.id
+        await db.commit()
+
+    # Create Checkout Session for subscription
+    session = stripe.checkout.Session.create(
+        mode="subscription",
+        line_items=[{"price": settings.STRIPE_PRICE_PRO_MONTHLY, "quantity": 1}],
+        success_url=f"{settings.FRONTEND_URL}/billing",
+        cancel_url=f"{settings.FRONTEND_URL}/billing",
+        customer=user.stripe_customer_id,
+        client_reference_id=str(user.id),
+    )
+    return {"checkout_url": session.url}
+
+
+@router.post("/portal")
+async def customer_portal(user: User = Depends(require_auth)):
+    if not settings.STRIPE_SECRET_KEY:
+        raise HTTPException(503, "Stripe not configured")
+    if not user.stripe_customer_id:
+        raise HTTPException(400, "No Stripe customer for user")
+
+    portal = stripe.billing_portal.Session.create(
+        customer=user.stripe_customer_id,
+        return_url=f"{settings.FRONTEND_URL}/billing",
+    )
+    return {"portal_url": portal.url}
+
+
 @router.post("/webhook")
 async def stripe_webhook(request: Request, db: AsyncSession = Depends(get_db_session)):
     payload = await request.body()
@@ -85,70 +126,196 @@
             logger.error("Invalid event structure: missing data.object")
             return {"received": True}
 
-        # Parse and validate client_reference_id (user_id)
-        try:
-            client_ref = session.get("client_reference_id")
-            if not client_ref:
-                logger.error("Missing client_reference_id in checkout session")
+        mode = session.get("mode")
+
+        # Handle subscription checkout
+        if mode == "subscription":
+            try:
+                client_ref = session.get("client_reference_id")
+                if not client_ref:
+                    logger.error("Missing client_reference_id in subscription session")
+                    return {"received": True}
+                user_id = uuid.UUID(client_ref)
+            except (ValueError, TypeError) as e:
+                logger.error("Invalid client_reference_id: %s", e)
+                return {"received": True}
+
+            user = await db.get(User, user_id)
+            if not user:
+                logger.warning("Subscription completed for non-existent user %s", user_id)
                 return {"received": True}
-            user_id = uuid.UUID(client_ref)
-        except (ValueError, TypeError) as e:
-            logger.error("Invalid client_reference_id: %s", e)
+
+            subscription_id = session.get("subscription")
+            customer_id = session.get("customer")
+
+            # Update user plan and subscription/customer ids
+            user.plan = "pro"
+            if subscription_id:
+                user.stripe_subscription_id = subscription_id
+            if customer_id and not user.stripe_customer_id:
+                user.stripe_customer_id = customer_id
+
+            # Idempotency: only one monthly grant per subscription id at start
+            existing = await db.scalar(
+                select(CreditLedger).where(
+                    CreditLedger.ref_type == "stripe_subscription",
+                    CreditLedger.ref_id == (subscription_id or ""),
+                )
+            )
+
+            if not existing:
+                try:
+                    await credit_credits(
+                        db,
+                        user_id=user.id,
+                        amount=int(settings.PLAN_PRO_MONTHLY_CREDITS or 0),
+                        reason="monthly_allowance",
+                        ref_type="stripe_subscription",
+                        ref_id=subscription_id or "",
+                    )
+                    await db.commit()
+                    logger.info(
+                        "Subscription start credits granted: user_id=%s, subscription=%s",
+                        user.id,
+                        subscription_id,
+                    )
+                except Exception as e:
+                    await db.rollback()
+                    logger.error("Failed to grant subscription start credits: %s", e)
+                    raise HTTPException(500, "Database error")
+            else:
+                await db.commit()
+
             return {"received": True}
 
-        # Parse and validate credits amount
-        try:
-            metadata = session.get("metadata", {})
-            credits_str = metadata.get("credits")
-            if not credits_str:
-                logger.error("Missing credits in session metadata")
+        # Handle one-time credit pack checkout
+        if mode == "payment":
+            # Parse and validate client_reference_id (user_id)
+            try:
+                client_ref = session.get("client_reference_id")
+                if not client_ref:
+                    logger.error("Missing client_reference_id in checkout session")
+                    return {"received": True}
+                user_id = uuid.UUID(client_ref)
+            except (ValueError, TypeError) as e:
+                logger.error("Invalid client_reference_id: %s", e)
                 return {"received": True}
-            credits = int(credits_str)
-            if credits <= 0:
-                logger.error("Invalid credits amount: %d", credits)
+
+            # Parse and validate credits amount
+            try:
+                metadata = session.get("metadata", {})
+                credits_str = metadata.get("credits")
+                if not credits_str:
+                    logger.error("Missing credits in session metadata")
+                    return {"received": True}
+                credits = int(credits_str)
+                if credits <= 0:
+                    logger.error("Invalid credits amount: %d", credits)
+                    return {"received": True}
+            except (ValueError, TypeError) as e:
+                logger.error("Cannot parse credits from metadata: %s", e)
+                return {"received": True}
+
+            # Get payment_intent for idempotency
+            payment_intent = session.get("payment_intent")
+            if not payment_intent:
+                logger.warning("Checkout session has no payment_intent, skipping for safety")
                 return {"received": True}
-        except (ValueError, TypeError) as e:
-            logger.error("Cannot parse credits from metadata: %s", e)
+
+            # Verify user exists
+            user = await db.get(User, user_id)
+            if not user:
+                logger.warning("Webhook for non-existent user %s", user_id)
+                return {"received": True}
+
+            # Idempotency check
+            existing = await db.scalar(
+                select(CreditLedger).where(
+                    CreditLedger.ref_type == "stripe_payment",
+                    CreditLedger.ref_id == payment_intent,
+                )
+            )
+
+            if not existing:
+                try:
+                    await credit_credits(
+                        db,
+                        user_id,
+                        credits,
+                        reason="purchase",
+                        ref_type="stripe_payment",
+                        ref_id=payment_intent,
+                    )
+                    await db.commit()
+                    logger.info(
+                        "Credits granted: user_id=%s, credits=%d, payment_intent=%s",
+                        user_id,
+                        credits,
+                        payment_intent,
+                    )
+                except Exception as e:
+                    await db.rollback()
+                    logger.error("Failed to grant credits: %s", e)
+                    # Return 5xx so Stripe retries
+                    raise HTTPException(500, "Database error")
+            return {"received": True}
+
+    elif event["type"] == "invoice.payment_succeeded":
+    
+        obj = event.get("data", {}).get("object")
+        if not obj or not isinstance(obj, dict):
             return {"received": True}
 
-        # Get payment_intent for idempotency
-        payment_intent = session.get("payment_intent")
-        if not payment_intent:
-            logger.warning("Checkout session has no payment_intent, skipping for safety")
+        invoice_id = obj.get("id")
+        customer_id = obj.get("customer")
+        if not invoice_id or not customer_id:
             return {"received": True}
 
-        # Verify user exists
-        user = await db.get(User, user_id)
+        # Find user by customer id
+        user = await db.scalar(select(User).where(User.stripe_customer_id == customer_id))
         if not user:
-            logger.warning("Webhook for non-existent user %s", user_id)
             return {"received": True}
 
-        # Idempotency check
+        # Idempotency: ensure we haven't granted for this invoice
         existing = await db.scalar(
             select(CreditLedger).where(
-                CreditLedger.ref_type == "stripe_payment",
-                CreditLedger.ref_id == payment_intent,
+                CreditLedger.ref_type == "stripe_invoice",
+                CreditLedger.ref_id == invoice_id,
             )
         )
-
         if not existing:
             try:
                 await credit_credits(
                     db,
-                    user_id,
-                    credits,
-                    reason="purchase",
-                    ref_type="stripe_payment",
-                    ref_id=payment_intent,
+                    user_id=user.id,
+                    amount=int(settings.PLAN_PRO_MONTHLY_CREDITS or 0),
+                    reason="monthly_allowance",
+                    ref_type="stripe_invoice",
+                    ref_id=invoice_id,
                 )
                 await db.commit()
-                logger.info("Credits granted: user_id=%s, credits=%d, payment_intent=%s",
-                           user_id, credits, payment_intent)
             except Exception as e:
                 await db.rollback()
-                logger.error("Failed to grant credits: %s", e)
-                # Return 5xx so Stripe retries
+                logger.error("Failed to grant monthly credits on invoice: %s", e)
                 raise HTTPException(500, "Database error")
+        return {"received": True}
+
+    elif event["type"] == "customer.subscription.deleted":
+        obj = event.get("data", {}).get("object")
+        if not obj or not isinstance(obj, dict):
+            return {"received": True}
 
-    return {"received": True}
+        customer_id = obj.get("customer")
+        if not customer_id:
+            return {"received": True}
 
+        user = await db.scalar(select(User).where(User.stripe_customer_id == customer_id))
+        if not user:
+            return {"received": True}
+
+        user.plan = "free"
+        user.stripe_subscription_id = None
+        await db.commit()
+        return {"received": True}
+
+    return {"received": True}
diff --git a/backend/app/api/chat.py b/backend/app/api/chat.py
index 71fc751fa90239dfe90bf76e3b30a7aa686d0c3f..d52dc47026e109df283984196581d417a4fea1dc
--- a/backend/app/api/chat.py
+++ b/backend/app/api/chat.py
@@ -133,6 +133,9 @@
 
     # If authenticated, ensure sufficient credits before opening stream
     if user is not None:
+        from app.services.credit_service import ensure_monthly_credits
+        await ensure_monthly_credits(db, user)
+        await db.commit()
         balance = await credit_service.get_user_credits(db, user.id)
         if balance < credit_service.MIN_CREDITS_FOR_CHAT:
             return JSONResponse(
diff --git a/backend/app/core/config.py b/backend/app/core/config.py
index 830f599a7b1ff02463684a9e84e90adfd6318cc1..a8eef6c5b4145c3710d46395bf26465dec42b4a7
--- a/backend/app/core/config.py
+++ b/backend/app/core/config.py
@@ -75,6 +75,10 @@
     CREDITS_PRO: int = 200000
     CREDITS_ENTERPRISE: int = 1000000
     SIGNUP_BONUS_CREDITS: int = 10000
+    # Subscription tiers
+    PLAN_FREE_MONTHLY_CREDITS: int = 10000
+    PLAN_PRO_MONTHLY_CREDITS: int = 100000
+    STRIPE_PRICE_PRO_MONTHLY: str = ''
 
     model_config = SettingsConfigDict(env_file=".env", env_file_encoding="utf-8", case_sensitive=False)
 
diff --git a/backend/app/models/tables.py b/backend/app/models/tables.py
index 2eb9239abb3f01f8a4103944db02efcb27f20149..9caeafd2d73fb05604695d962f9a0dc191da0bf2
--- a/backend/app/models/tables.py
+++ b/backend/app/models/tables.py
@@ -163,6 +163,10 @@
     email_verified: Mapped[Optional[datetime]] = mapped_column(sa.DateTime(timezone=True))
     credits_balance: Mapped[int] = mapped_column(sa.Integer, nullable=False, server_default=sa.text("0"))
     signup_bonus_granted_at: Mapped[Optional[datetime]] = mapped_column(sa.DateTime(timezone=True))
+    plan: Mapped[str] = mapped_column(sa.String(20), nullable=False, server_default=sa.text("'free'"))
+    stripe_customer_id: Mapped[Optional[str]] = mapped_column(sa.String(255))
+    stripe_subscription_id: Mapped[Optional[str]] = mapped_column(sa.String(255))
+    monthly_credits_granted_at: Mapped[Optional[datetime]] = mapped_column(sa.DateTime(timezone=True))
     created_at: Mapped[datetime] = mapped_column(sa.DateTime(timezone=True), server_default=sa.text("now()"))
     updated_at: Mapped[datetime] = mapped_column(
         sa.DateTime(timezone=True), server_default=sa.text("now()"), onupdate=sa.func.now()
diff --git a/backend/app/services/auth_service.py b/backend/app/services/auth_service.py
index cc72086b50ebd5497e7cdada96a60506fa7d9c05..6b57ee07cdff8f392a533172f8e7507a3e131cc4
--- a/backend/app/services/auth_service.py
+++ b/backend/app/services/auth_service.py
@@ -52,6 +52,7 @@
         email_verified=email_verified,
         credits_balance=SIGNUP_BONUS_CREDITS,
         signup_bonus_granted_at=datetime.utcnow(),
+        monthly_credits_granted_at=datetime.utcnow(),
     )
     db.add(user)
 
@@ -179,4 +180,3 @@
     await db.delete(vt)
     await db.commit()
     return vt
-
diff --git a/backend/app/services/credit_service.py b/backend/app/services/credit_service.py
index d89772b0418d1ebe1a79bba3de65f0112a550adb..a599453a961fb9222db98928201795c4fa4e574b
--- a/backend/app/services/credit_service.py
+++ b/backend/app/services/credit_service.py
@@ -7,6 +7,7 @@
 from sqlalchemy.ext.asyncio import AsyncSession
 
 from app.models.tables import CreditLedger, UsageRecord, User
+from app.core.config import settings
 
 
 # Token-to-credit rates by model tier
@@ -144,3 +145,56 @@
     db.add(usage)
     return usage
 
+
+async def ensure_monthly_credits(db: AsyncSession, user: User) -> None:
+    """Grant monthly credits if last grant was over 30 days ago.
+
+    Idempotency: checks CreditLedger for any recent 'monthly_allowance' within 30 days.
+    """
+    from datetime import datetime, timedelta, timezone
+
+    # Determine if grant needed based on timestamp
+    now = datetime.now(timezone.utc)
+    last = user.monthly_credits_granted_at
+    needs_grant = last is None or (now - last) >= timedelta(days=30)
+    if not needs_grant:
+        return
+
+    # Check ledger for idempotency within last 30 days
+    cutoff = now - timedelta(days=30)
+    existing = await db.scalar(
+        sa.select(CreditLedger)
+        .where(CreditLedger.user_id == user.id)
+        .where(CreditLedger.reason == "monthly_allowance")
+        .where(CreditLedger.created_at >= cutoff)
+    )
+    if existing:
+        # Still update marker to avoid repeatedly checking in future requests
+        user.monthly_credits_granted_at = now
+        await db.flush()
+        return
+
+    # Determine allowance by plan
+    plan = (user.plan or "free").lower()
+    if plan == "pro":
+        allowance = int(settings.PLAN_PRO_MONTHLY_CREDITS or 0)
+    else:
+        allowance = int(settings.PLAN_FREE_MONTHLY_CREDITS or 0)
+
+    if allowance <= 0:
+        # Nothing to grant
+        user.monthly_credits_granted_at = now
+        await db.flush()
+        return
+
+    # Grant credits and update marker
+    await credit_credits(
+        db,
+        user_id=user.id,
+        amount=allowance,
+        reason="monthly_allowance",
+        ref_type=None,
+        ref_id=None,
+    )
+    user.monthly_credits_granted_at = now
+    await db.flush()


thinking
**Ensuring code integrity**

I need to make sure that modifications to the code don’t break any import cycles. For instance, in 'billing.py,' AsyncSession is imported and used in the subscribe function, which seems fine. Next, I should check if "app/models/__init__.py" is exposing Base and others correctly. So, I'll open the app/models directory to confirm everything is set up properly and adapt it if needed. It's crucial to maintain the structure!
exec
bash -lc "ls -la backend/app/models && sed -n '1,200p' backend/app/models/__init__.py" in /Users/mayijie/Projects/Code/010_DocTalk succeeded in 22ms:
total 56
drwxr-xr-x@  7 mayijie  staff    224 Feb  6 13:59 .
drwxr-xr-x@ 10 mayijie  staff    320 Feb  6 11:57 ..
-rw-r--r--@  1 mayijie  staff    386 Feb  5 20:17 __init__.py
-rw-r--r--@  1 mayijie  staff    120 Feb  4 19:41 base.py
-rw-r--r--@  1 mayijie  staff    757 Feb  4 19:41 database.py
-rw-r--r--@  1 mayijie  staff   1158 Feb  4 19:46 sync_database.py
-rw-r--r--@  1 mayijie  staff  11533 Feb  6 14:03 tables.py
from .base import Base
from .tables import (
    Document,
    Page,
    Chunk,
    ChatSession,
    Message,
    User,
    Account,
    VerificationToken,
    CreditLedger,
    UsageRecord,
file update:
diff --git a/backend/alembic/versions/20260206_0004_add_subscription_fields.py b/backend/alembic/versions/20260206_0004_add_subscription_fields.py
new file mode 100644
index 0000000000000000000000000000000000000000..f84be09226785ea3dbc1b413b3cfd2cb07dff81e
--- /dev/null
+++ b/backend/alembic/versions/20260206_0004_add_subscription_fields.py
@@ -0,0 +1,38 @@
+"""add subscription fields to users
+
+Revision ID: d4e5f6a7b8c9
+Revises: c3d4e5f6a7b8
+Create Date: 2026-02-06 00:40:00
+
+"""
+from __future__ import annotations
+
+from alembic import op
+import sqlalchemy as sa
+
+
+# revision identifiers, used by Alembic.
+revision = "d4e5f6a7b8c9"
+down_revision = "c3d4e5f6a7b8"
+branch_labels = None
+depends_on = None
+
+
+def upgrade() -> None:
+    # Add subscription-related columns to users
+    op.add_column(
+        "users",
+        sa.Column("plan", sa.String(length=20), nullable=False, server_default=sa.text("'free'")),
+    )
+    op.add_column("users", sa.Column("stripe_customer_id", sa.String(length=255), nullable=True))
+    op.add_column("users", sa.Column("stripe_subscription_id", sa.String(length=255), nullable=True))
+    op.add_column("users", sa.Column("monthly_credits_granted_at", sa.DateTime(timezone=True), nullable=True))
+
+
+def downgrade() -> None:
+    # Drop subscription-related columns from users
+    op.drop_column("users", "monthly_credits_granted_at")
+    op.drop_column("users", "stripe_subscription_id")
+    op.drop_column("users", "stripe_customer_id")
+    op.drop_column("users", "plan")
+
diff --git a/backend/app/api/billing.py b/backend/app/api/billing.py
index 851620df69f9c62fb3cab15feeedcafff44cc6bb..f99355cf848497a82c150ed57c5c5b2c20aa5e2e
--- a/backend/app/api/billing.py
+++ b/backend/app/api/billing.py
@@ -58,6 +58,47 @@
     return {"checkout_url": session.url}
 
 
+# Subscriptions
+@router.post("/subscribe")
+async def subscribe(
+    user: User = Depends(require_auth),
+    db: AsyncSession = Depends(get_db_session),
+):
+    if not settings.STRIPE_SECRET_KEY or not settings.STRIPE_PRICE_PRO_MONTHLY:
+        raise HTTPException(503, "Stripe not configured")
+
+    # Ensure customer exists
+    if not user.stripe_customer_id:
+        cust = stripe.Customer.create(email=user.email, name=user.name or None)
+        user.stripe_customer_id = cust.id
+        await db.commit()
+
+    # Create Checkout Session for subscription
+    session = stripe.checkout.Session.create(
+        mode="subscription",
+        line_items=[{"price": settings.STRIPE_PRICE_PRO_MONTHLY, "quantity": 1}],
+        success_url=f"{settings.FRONTEND_URL}/billing",
+        cancel_url=f"{settings.FRONTEND_URL}/billing",
+        customer=user.stripe_customer_id,
+        client_reference_id=str(user.id),
+    )
+    return {"checkout_url": session.url}
+
+
+@router.post("/portal")
+async def customer_portal(user: User = Depends(require_auth)):
+    if not settings.STRIPE_SECRET_KEY:
+        raise HTTPException(503, "Stripe not configured")
+    if not user.stripe_customer_id:
+        raise HTTPException(400, "No Stripe customer for user")
+
+    portal = stripe.billing_portal.Session.create(
+        customer=user.stripe_customer_id,
+        return_url=f"{settings.FRONTEND_URL}/billing",
+    )
+    return {"portal_url": portal.url}
+
+
 @router.post("/webhook")
 async def stripe_webhook(request: Request, db: AsyncSession = Depends(get_db_session)):
     payload = await request.body()
@@ -85,70 +126,196 @@
             logger.error("Invalid event structure: missing data.object")
             return {"received": True}
 
-        # Parse and validate client_reference_id (user_id)
-        try:
-            client_ref = session.get("client_reference_id")
-            if not client_ref:
-                logger.error("Missing client_reference_id in checkout session")
+        mode = session.get("mode")
+
+        # Handle subscription checkout
+        if mode == "subscription":
+            try:
+                client_ref = session.get("client_reference_id")
+                if not client_ref:
+                    logger.error("Missing client_reference_id in subscription session")
+                    return {"received": True}
+                user_id = uuid.UUID(client_ref)
+            except (ValueError, TypeError) as e:
+                logger.error("Invalid client_reference_id: %s", e)
+                return {"received": True}
+
+            user = await db.get(User, user_id)
+            if not user:
+                logger.warning("Subscription completed for non-existent user %s", user_id)
                 return {"received": True}
-            user_id = uuid.UUID(client_ref)
-        except (ValueError, TypeError) as e:
-            logger.error("Invalid client_reference_id: %s", e)
+
+            subscription_id = session.get("subscription")
+            customer_id = session.get("customer")
+
+            # Update user plan and subscription/customer ids
+            user.plan = "pro"
+            if subscription_id:
+                user.stripe_subscription_id = subscription_id
+            if customer_id and not user.stripe_customer_id:
+                user.stripe_customer_id = customer_id
+
+            # Idempotency: only one monthly grant per subscription id at start
+            existing = await db.scalar(
+                select(CreditLedger).where(
+                    CreditLedger.ref_type == "stripe_subscription",
+                    CreditLedger.ref_id == (subscription_id or ""),
+                )
+            )
+
+            if not existing:
+                try:
+                    await credit_credits(
+                        db,
+                        user_id=user.id,
+                        amount=int(settings.PLAN_PRO_MONTHLY_CREDITS or 0),
+                        reason="monthly_allowance",
+                        ref_type="stripe_subscription",
+                        ref_id=subscription_id or "",
+                    )
+                    await db.commit()
+                    logger.info(
+                        "Subscription start credits granted: user_id=%s, subscription=%s",
+                        user.id,
+                        subscription_id,
+                    )
+                except Exception as e:
+                    await db.rollback()
+                    logger.error("Failed to grant subscription start credits: %s", e)
+                    raise HTTPException(500, "Database error")
+            else:
+                await db.commit()
+
             return {"received": True}
 
-        # Parse and validate credits amount
-        try:
-            metadata = session.get("metadata", {})
-            credits_str = metadata.get("credits")
-            if not credits_str:
-                logger.error("Missing credits in session metadata")
+        # Handle one-time credit pack checkout
+        if mode == "payment":
+            # Parse and validate client_reference_id (user_id)
+            try:
+                client_ref = session.get("client_reference_id")
+                if not client_ref:
+                    logger.error("Missing client_reference_id in checkout session")
+                    return {"received": True}
+                user_id = uuid.UUID(client_ref)
+            except (ValueError, TypeError) as e:
+                logger.error("Invalid client_reference_id: %s", e)
                 return {"received": True}
-            credits = int(credits_str)
-            if credits <= 0:
-                logger.error("Invalid credits amount: %d", credits)
+
+            # Parse and validate credits amount
+            try:
+                metadata = session.get("metadata", {})
+                credits_str = metadata.get("credits")
+                if not credits_str:
+                    logger.error("Missing credits in session metadata")
+                    return {"received": True}
+                credits = int(credits_str)
+                if credits <= 0:
+                    logger.error("Invalid credits amount: %d", credits)
+                    return {"received": True}
+            except (ValueError, TypeError) as e:
+                logger.error("Cannot parse credits from metadata: %s", e)
+                return {"received": True}
+
+            # Get payment_intent for idempotency
+            payment_intent = session.get("payment_intent")
+            if not payment_intent:
+                logger.warning("Checkout session has no payment_intent, skipping for safety")
                 return {"received": True}
-        except (ValueError, TypeError) as e:
-            logger.error("Cannot parse credits from metadata: %s", e)
+
+            # Verify user exists
+            user = await db.get(User, user_id)
+            if not user:
+                logger.warning("Webhook for non-existent user %s", user_id)
+                return {"received": True}
+
+            # Idempotency check
+            existing = await db.scalar(
+                select(CreditLedger).where(
+                    CreditLedger.ref_type == "stripe_payment",
+                    CreditLedger.ref_id == payment_intent,
+                )
+            )
+
+            if not existing:
+                try:
+                    await credit_credits(
+                        db,
+                        user_id,
+                        credits,
+                        reason="purchase",
+                        ref_type="stripe_payment",
+                        ref_id=payment_intent,
+                    )
+                    await db.commit()
+                    logger.info(
+                        "Credits granted: user_id=%s, credits=%d, payment_intent=%s",
+                        user_id,
+                        credits,
+                        payment_intent,
+                    )
+                except Exception as e:
+                    await db.rollback()
+                    logger.error("Failed to grant credits: %s", e)
+                    # Return 5xx so Stripe retries
+                    raise HTTPException(500, "Database error")
+            return {"received": True}
+
+    elif event["type"] == "invoice.payment_succeeded":
+    
+        obj = event.get("data", {}).get("object")
+        if not obj or not isinstance(obj, dict):
             return {"received": True}
 
-        # Get payment_intent for idempotency
-        payment_intent = session.get("payment_intent")
-        if not payment_intent:
-            logger.warning("Checkout session has no payment_intent, skipping for safety")
+        invoice_id = obj.get("id")
+        customer_id = obj.get("customer")
+        if not invoice_id or not customer_id:
             return {"received": True}
 
-        # Verify user exists
-        user = await db.get(User, user_id)
+        # Find user by customer id
+        user = await db.scalar(select(User).where(User.stripe_customer_id == customer_id))
         if not user:
-            logger.warning("Webhook for non-existent user %s", user_id)
             return {"received": True}
 
-        # Idempotency check
+        # Idempotency: ensure we haven't granted for this invoice
         existing = await db.scalar(
             select(CreditLedger).where(
-                CreditLedger.ref_type == "stripe_payment",
-                CreditLedger.ref_id == payment_intent,
+                CreditLedger.ref_type == "stripe_invoice",
+                CreditLedger.ref_id == invoice_id,
             )
         )
-
         if not existing:
             try:
                 await credit_credits(
                     db,
-                    user_id,
-                    credits,
-                    reason="purchase",
-                    ref_type="stripe_payment",
-                    ref_id=payment_intent,
+                    user_id=user.id,
+                    amount=int(settings.PLAN_PRO_MONTHLY_CREDITS or 0),
+                    reason="monthly_allowance",
+                    ref_type="stripe_invoice",
+                    ref_id=invoice_id,
                 )
                 await db.commit()
-                logger.info("Credits granted: user_id=%s, credits=%d, payment_intent=%s",
-                           user_id, credits, payment_intent)
             except Exception as e:
                 await db.rollback()
-                logger.error("Failed to grant credits: %s", e)
-                # Return 5xx so Stripe retries
+                logger.error("Failed to grant monthly credits on invoice: %s", e)
                 raise HTTPException(500, "Database error")
+        return {"received": True}
+
+    elif event["type"] == "customer.subscription.deleted":
+        obj = event.get("data", {}).get("object")
+        if not obj or not isinstance(obj, dict):
+            return {"received": True}
 
-    return {"received": True}
+        customer_id = obj.get("customer")
+        if not customer_id:
+            return {"received": True}
 
+        user = await db.scalar(select(User).where(User.stripe_customer_id == customer_id))
+        if not user:
+            return {"received": True}
+
+        user.plan = "free"
+        user.stripe_subscription_id = None
+        await db.commit()
+        return {"received": True}
+
+    return {"received": True}
diff --git a/backend/app/api/chat.py b/backend/app/api/chat.py
index 71fc751fa90239dfe90bf76e3b30a7aa686d0c3f..d52dc47026e109df283984196581d417a4fea1dc
--- a/backend/app/api/chat.py
+++ b/backend/app/api/chat.py
@@ -133,6 +133,9 @@
 
     # If authenticated, ensure sufficient credits before opening stream
     if user is not None:
+        from app.services.credit_service import ensure_monthly_credits
+        await ensure_monthly_credits(db, user)
+        await db.commit()
         balance = await credit_service.get_user_credits(db, user.id)
         if balance < credit_service.MIN_CREDITS_FOR_CHAT:
             return JSONResponse(
diff --git a/backend/app/core/config.py b/backend/app/core/config.py
index 830f599a7b1ff02463684a9e84e90adfd6318cc1..a8eef6c5b4145c3710d46395bf26465dec42b4a7
--- a/backend/app/core/config.py
+++ b/backend/app/core/config.py
@@ -75,6 +75,10 @@
     CREDITS_PRO: int = 200000
     CREDITS_ENTERPRISE: int = 1000000
     SIGNUP_BONUS_CREDITS: int = 10000
+    # Subscription tiers
+    PLAN_FREE_MONTHLY_CREDITS: int = 10000
+    PLAN_PRO_MONTHLY_CREDITS: int = 100000
+    STRIPE_PRICE_PRO_MONTHLY: str = ''
 
     model_config = SettingsConfigDict(env_file=".env", env_file_encoding="utf-8", case_sensitive=False)
 
diff --git a/backend/app/models/tables.py b/backend/app/models/tables.py
index 2eb9239abb3f01f8a4103944db02efcb27f20149..9caeafd2d73fb05604695d962f9a0dc191da0bf2
--- a/backend/app/models/tables.py
+++ b/backend/app/models/tables.py
@@ -163,6 +163,10 @@
     email_verified: Mapped[Optional[datetime]] = mapped_column(sa.DateTime(timezone=True))
     credits_balance: Mapped[int] = mapped_column(sa.Integer, nullable=False, server_default=sa.text("0"))
     signup_bonus_granted_at: Mapped[Optional[datetime]] = mapped_column(sa.DateTime(timezone=True))
+    plan: Mapped[str] = mapped_column(sa.String(20), nullable=False, server_default=sa.text("'free'"))
+    stripe_customer_id: Mapped[Optional[str]] = mapped_column(sa.String(255))
+    stripe_subscription_id: Mapped[Optional[str]] = mapped_column(sa.String(255))
+    monthly_credits_granted_at: Mapped[Optional[datetime]] = mapped_column(sa.DateTime(timezone=True))
     created_at: Mapped[datetime] = mapped_column(sa.DateTime(timezone=True), server_default=sa.text("now()"))
     updated_at: Mapped[datetime] = mapped_column(
         sa.DateTime(timezone=True), server_default=sa.text("now()"), onupdate=sa.func.now()
diff --git a/backend/app/services/auth_service.py b/backend/app/services/auth_service.py
index cc72086b50ebd5497e7cdada96a60506fa7d9c05..6b57ee07cdff8f392a533172f8e7507a3e131cc4
--- a/backend/app/services/auth_service.py
+++ b/backend/app/services/auth_service.py
@@ -52,6 +52,7 @@
         email_verified=email_verified,
         credits_balance=SIGNUP_BONUS_CREDITS,
         signup_bonus_granted_at=datetime.utcnow(),
+        monthly_credits_granted_at=datetime.utcnow(),
     )
     db.add(user)
 
@@ -179,4 +180,3 @@
     await db.delete(vt)
     await db.commit()
     return vt
-
diff --git a/backend/app/services/credit_service.py b/backend/app/services/credit_service.py
index d89772b0418d1ebe1a79bba3de65f0112a550adb..a599453a961fb9222db98928201795c4fa4e574b
--- a/backend/app/services/credit_service.py
+++ b/backend/app/services/credit_service.py
@@ -7,6 +7,7 @@
 from sqlalchemy.ext.asyncio import AsyncSession
 
 from app.models.tables import CreditLedger, UsageRecord, User
+from app.core.config import settings
 
 
 # Token-to-credit rates by model tier
@@ -144,3 +145,56 @@
     db.add(usage)
     return usage
 
+
+async def ensure_monthly_credits(db: AsyncSession, user: User) -> None:
+    """Grant monthly credits if last grant was over 30 days ago.
+
+    Idempotency: checks CreditLedger for any recent 'monthly_allowance' within 30 days.
+    """
+    from datetime import datetime, timedelta, timezone
+
+    # Determine if grant needed based on timestamp
+    now = datetime.now(timezone.utc)
+    last = user.monthly_credits_granted_at
+    needs_grant = last is None or (now - last) >= timedelta(days=30)
+    if not needs_grant:
+        return
+
+    # Check ledger for idempotency within last 30 days
+    cutoff = now - timedelta(days=30)
+    existing = await db.scalar(
+        sa.select(CreditLedger)
+        .where(CreditLedger.user_id == user.id)
+        .where(CreditLedger.reason == "monthly_allowance")
+        .where(CreditLedger.created_at >= cutoff)
+    )
+    if existing:
+        # Still update marker to avoid repeatedly checking in future requests
+        user.monthly_credits_granted_at = now
+        await db.flush()
+        return
+
+    # Determine allowance by plan
+    plan = (user.plan or "free").lower()
+    if plan == "pro":
+        allowance = int(settings.PLAN_PRO_MONTHLY_CREDITS or 0)
+    else:
+        allowance = int(settings.PLAN_FREE_MONTHLY_CREDITS or 0)
+
+    if allowance <= 0:
+        # Nothing to grant
+        user.monthly_credits_granted_at = now
+        await db.flush()
+        return
+
+    # Grant credits and update marker
+    await credit_credits(
+        db,
+        user_id=user.id,
+        amount=allowance,
+        reason="monthly_allowance",
+        ref_type=None,
+        ref_id=None,
+    )
+    user.monthly_credits_granted_at = now
+    await db.flush()


thinking
**Checking router aggregation**

I need to confirm that the router aggregator in "app/api/__init__" includes the billing endpoints. So, I’ll look at the main file to see if that router is part of it. However, I can’t make any modifications to the main file; my focus is on ensuring the route prefix is set to /api/billing. It looks like referencing the README isn’t necessary, and I might need to check either app/api.py or main to get the information.
exec
bash -lc "sed -n '1,240p' backend/app/main.py" in /Users/mayijie/Projects/Code/010_DocTalk succeeded in 15ms:
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware

from .core.config import settings
from .api.documents import documents_router
from .api.search import search_router
from .api.chat import chat_router
from .api.chunks import chunks_router
from .api.credits import router as credits_router
from .api.users import router as users_router
from .api.billing import router as billing_router
from .api import auth
from .services.storage_service import storage_service
from .services.embedding_service import embedding_service


app = FastAPI(title="DocTalk API")

# CORS configuration
app.add_middleware(
file update:
diff --git a/backend/alembic/versions/20260206_0004_add_subscription_fields.py b/backend/alembic/versions/20260206_0004_add_subscription_fields.py
new file mode 100644
index 0000000000000000000000000000000000000000..f84be09226785ea3dbc1b413b3cfd2cb07dff81e
--- /dev/null
+++ b/backend/alembic/versions/20260206_0004_add_subscription_fields.py
@@ -0,0 +1,38 @@
+"""add subscription fields to users
+
+Revision ID: d4e5f6a7b8c9
+Revises: c3d4e5f6a7b8
+Create Date: 2026-02-06 00:40:00
+
+"""
+from __future__ import annotations
+
+from alembic import op
+import sqlalchemy as sa
+
+
+# revision identifiers, used by Alembic.
+revision = "d4e5f6a7b8c9"
+down_revision = "c3d4e5f6a7b8"
+branch_labels = None
+depends_on = None
+
+
+def upgrade() -> None:
+    # Add subscription-related columns to users
+    op.add_column(
+        "users",
+        sa.Column("plan", sa.String(length=20), nullable=False, server_default=sa.text("'free'")),
+    )
+    op.add_column("users", sa.Column("stripe_customer_id", sa.String(length=255), nullable=True))
+    op.add_column("users", sa.Column("stripe_subscription_id", sa.String(length=255), nullable=True))
+    op.add_column("users", sa.Column("monthly_credits_granted_at", sa.DateTime(timezone=True), nullable=True))
+
+
+def downgrade() -> None:
+    # Drop subscription-related columns from users
+    op.drop_column("users", "monthly_credits_granted_at")
+    op.drop_column("users", "stripe_subscription_id")
+    op.drop_column("users", "stripe_customer_id")
+    op.drop_column("users", "plan")
+
diff --git a/backend/app/api/billing.py b/backend/app/api/billing.py
index 851620df69f9c62fb3cab15feeedcafff44cc6bb..f99355cf848497a82c150ed57c5c5b2c20aa5e2e
--- a/backend/app/api/billing.py
+++ b/backend/app/api/billing.py
@@ -58,6 +58,47 @@
     return {"checkout_url": session.url}
 
 
+# Subscriptions
+@router.post("/subscribe")
+async def subscribe(
+    user: User = Depends(require_auth),
+    db: AsyncSession = Depends(get_db_session),
+):
+    if not settings.STRIPE_SECRET_KEY or not settings.STRIPE_PRICE_PRO_MONTHLY:
+        raise HTTPException(503, "Stripe not configured")
+
+    # Ensure customer exists
+    if not user.stripe_customer_id:
+        cust = stripe.Customer.create(email=user.email, name=user.name or None)
+        user.stripe_customer_id = cust.id
+        await db.commit()
+
+    # Create Checkout Session for subscription
+    session = stripe.checkout.Session.create(
+        mode="subscription",
+        line_items=[{"price": settings.STRIPE_PRICE_PRO_MONTHLY, "quantity": 1}],
+        success_url=f"{settings.FRONTEND_URL}/billing",
+        cancel_url=f"{settings.FRONTEND_URL}/billing",
+        customer=user.stripe_customer_id,
+        client_reference_id=str(user.id),
+    )
+    return {"checkout_url": session.url}
+
+
+@router.post("/portal")
+async def customer_portal(user: User = Depends(require_auth)):
+    if not settings.STRIPE_SECRET_KEY:
+        raise HTTPException(503, "Stripe not configured")
+    if not user.stripe_customer_id:
+        raise HTTPException(400, "No Stripe customer for user")
+
+    portal = stripe.billing_portal.Session.create(
+        customer=user.stripe_customer_id,
+        return_url=f"{settings.FRONTEND_URL}/billing",
+    )
+    return {"portal_url": portal.url}
+
+
 @router.post("/webhook")
 async def stripe_webhook(request: Request, db: AsyncSession = Depends(get_db_session)):
     payload = await request.body()
@@ -85,70 +126,196 @@
             logger.error("Invalid event structure: missing data.object")
             return {"received": True}
 
-        # Parse and validate client_reference_id (user_id)
-        try:
-            client_ref = session.get("client_reference_id")
-            if not client_ref:
-                logger.error("Missing client_reference_id in checkout session")
+        mode = session.get("mode")
+
+        # Handle subscription checkout
+        if mode == "subscription":
+            try:
+                client_ref = session.get("client_reference_id")
+                if not client_ref:
+                    logger.error("Missing client_reference_id in subscription session")
+                    return {"received": True}
+                user_id = uuid.UUID(client_ref)
+            except (ValueError, TypeError) as e:
+                logger.error("Invalid client_reference_id: %s", e)
+                return {"received": True}
+
+            user = await db.get(User, user_id)
+            if not user:
+                logger.warning("Subscription completed for non-existent user %s", user_id)
                 return {"received": True}
-            user_id = uuid.UUID(client_ref)
-        except (ValueError, TypeError) as e:
-            logger.error("Invalid client_reference_id: %s", e)
+
+            subscription_id = session.get("subscription")
+            customer_id = session.get("customer")
+
+            # Update user plan and subscription/customer ids
+            user.plan = "pro"
+            if subscription_id:
+                user.stripe_subscription_id = subscription_id
+            if customer_id and not user.stripe_customer_id:
+                user.stripe_customer_id = customer_id
+
+            # Idempotency: only one monthly grant per subscription id at start
+            existing = await db.scalar(
+                select(CreditLedger).where(
+                    CreditLedger.ref_type == "stripe_subscription",
+                    CreditLedger.ref_id == (subscription_id or ""),
+                )
+            )
+
+            if not existing:
+                try:
+                    await credit_credits(
+                        db,
+                        user_id=user.id,
+                        amount=int(settings.PLAN_PRO_MONTHLY_CREDITS or 0),
+                        reason="monthly_allowance",
+                        ref_type="stripe_subscription",
+                        ref_id=subscription_id or "",
+                    )
+                    await db.commit()
+                    logger.info(
+                        "Subscription start credits granted: user_id=%s, subscription=%s",
+                        user.id,
+                        subscription_id,
+                    )
+                except Exception as e:
+                    await db.rollback()
+                    logger.error("Failed to grant subscription start credits: %s", e)
+                    raise HTTPException(500, "Database error")
+            else:
+                await db.commit()
+
             return {"received": True}
 
-        # Parse and validate credits amount
-        try:
-            metadata = session.get("metadata", {})
-            credits_str = metadata.get("credits")
-            if not credits_str:
-                logger.error("Missing credits in session metadata")
+        # Handle one-time credit pack checkout
+        if mode == "payment":
+            # Parse and validate client_reference_id (user_id)
+            try:
+                client_ref = session.get("client_reference_id")
+                if not client_ref:
+                    logger.error("Missing client_reference_id in checkout session")
+                    return {"received": True}
+                user_id = uuid.UUID(client_ref)
+            except (ValueError, TypeError) as e:
+                logger.error("Invalid client_reference_id: %s", e)
                 return {"received": True}
-            credits = int(credits_str)
-            if credits <= 0:
-                logger.error("Invalid credits amount: %d", credits)
+
+            # Parse and validate credits amount
+            try:
+                metadata = session.get("metadata", {})
+                credits_str = metadata.get("credits")
+                if not credits_str:
+                    logger.error("Missing credits in session metadata")
+                    return {"received": True}
+                credits = int(credits_str)
+                if credits <= 0:
+                    logger.error("Invalid credits amount: %d", credits)
+                    return {"received": True}
+            except (ValueError, TypeError) as e:
+                logger.error("Cannot parse credits from metadata: %s", e)
+                return {"received": True}
+
+            # Get payment_intent for idempotency
+            payment_intent = session.get("payment_intent")
+            if not payment_intent:
+                logger.warning("Checkout session has no payment_intent, skipping for safety")
                 return {"received": True}
-        except (ValueError, TypeError) as e:
-            logger.error("Cannot parse credits from metadata: %s", e)
+
+            # Verify user exists
+            user = await db.get(User, user_id)
+            if not user:
+                logger.warning("Webhook for non-existent user %s", user_id)
+                return {"received": True}
+
+            # Idempotency check
+            existing = await db.scalar(
+                select(CreditLedger).where(
+                    CreditLedger.ref_type == "stripe_payment",
+                    CreditLedger.ref_id == payment_intent,
+                )
+            )
+
+            if not existing:
+                try:
+                    await credit_credits(
+                        db,
+                        user_id,
+                        credits,
+                        reason="purchase",
+                        ref_type="stripe_payment",
+                        ref_id=payment_intent,
+                    )
+                    await db.commit()
+                    logger.info(
+                        "Credits granted: user_id=%s, credits=%d, payment_intent=%s",
+                        user_id,
+                        credits,
+                        payment_intent,
+                    )
+                except Exception as e:
+                    await db.rollback()
+                    logger.error("Failed to grant credits: %s", e)
+                    # Return 5xx so Stripe retries
+                    raise HTTPException(500, "Database error")
+            return {"received": True}
+
+    elif event["type"] == "invoice.payment_succeeded":
+    
+        obj = event.get("data", {}).get("object")
+        if not obj or not isinstance(obj, dict):
             return {"received": True}
 
-        # Get payment_intent for idempotency
-        payment_intent = session.get("payment_intent")
-        if not payment_intent:
-            logger.warning("Checkout session has no payment_intent, skipping for safety")
+        invoice_id = obj.get("id")
+        customer_id = obj.get("customer")
+        if not invoice_id or not customer_id:
             return {"received": True}
 
-        # Verify user exists
-        user = await db.get(User, user_id)
+        # Find user by customer id
+        user = await db.scalar(select(User).where(User.stripe_customer_id == customer_id))
         if not user:
-            logger.warning("Webhook for non-existent user %s", user_id)
             return {"received": True}
 
-        # Idempotency check
+        # Idempotency: ensure we haven't granted for this invoice
         existing = await db.scalar(
             select(CreditLedger).where(
-                CreditLedger.ref_type == "stripe_payment",
-                CreditLedger.ref_id == payment_intent,
+                CreditLedger.ref_type == "stripe_invoice",
+                CreditLedger.ref_id == invoice_id,
             )
         )
-
         if not existing:
             try:
                 await credit_credits(
                     db,
-                    user_id,
-                    credits,
-                    reason="purchase",
-                    ref_type="stripe_payment",
-                    ref_id=payment_intent,
+                    user_id=user.id,
+                    amount=int(settings.PLAN_PRO_MONTHLY_CREDITS or 0),
+                    reason="monthly_allowance",
+                    ref_type="stripe_invoice",
+                    ref_id=invoice_id,
                 )
                 await db.commit()
-                logger.info("Credits granted: user_id=%s, credits=%d, payment_intent=%s",
-                           user_id, credits, payment_intent)
             except Exception as e:
                 await db.rollback()
-                logger.error("Failed to grant credits: %s", e)
-                # Return 5xx so Stripe retries
+                logger.error("Failed to grant monthly credits on invoice: %s", e)
                 raise HTTPException(500, "Database error")
+        return {"received": True}
+
+    elif event["type"] == "customer.subscription.deleted":
+        obj = event.get("data", {}).get("object")
+        if not obj or not isinstance(obj, dict):
+            return {"received": True}
 
-    return {"received": True}
+        customer_id = obj.get("customer")
+        if not customer_id:
+            return {"received": True}
 
+        user = await db.scalar(select(User).where(User.stripe_customer_id == customer_id))
+        if not user:
+            return {"received": True}
+
+        user.plan = "free"
+        user.stripe_subscription_id = None
+        await db.commit()
+        return {"received": True}
+
+    return {"received": True}
diff --git a/backend/app/api/chat.py b/backend/app/api/chat.py
index 71fc751fa90239dfe90bf76e3b30a7aa686d0c3f..d52dc47026e109df283984196581d417a4fea1dc
--- a/backend/app/api/chat.py
+++ b/backend/app/api/chat.py
@@ -133,6 +133,9 @@
 
     # If authenticated, ensure sufficient credits before opening stream
     if user is not None:
+        from app.services.credit_service import ensure_monthly_credits
+        await ensure_monthly_credits(db, user)
+        await db.commit()
         balance = await credit_service.get_user_credits(db, user.id)
         if balance < credit_service.MIN_CREDITS_FOR_CHAT:
             return JSONResponse(
diff --git a/backend/app/core/config.py b/backend/app/core/config.py
index 830f599a7b1ff02463684a9e84e90adfd6318cc1..a8eef6c5b4145c3710d46395bf26465dec42b4a7
--- a/backend/app/core/config.py
+++ b/backend/app/core/config.py
@@ -75,6 +75,10 @@
     CREDITS_PRO: int = 200000
     CREDITS_ENTERPRISE: int = 1000000
     SIGNUP_BONUS_CREDITS: int = 10000
+    # Subscription tiers
+    PLAN_FREE_MONTHLY_CREDITS: int = 10000
+    PLAN_PRO_MONTHLY_CREDITS: int = 100000
+    STRIPE_PRICE_PRO_MONTHLY: str = ''
 
     model_config = SettingsConfigDict(env_file=".env", env_file_encoding="utf-8", case_sensitive=False)
 
diff --git a/backend/app/models/tables.py b/backend/app/models/tables.py
index 2eb9239abb3f01f8a4103944db02efcb27f20149..9caeafd2d73fb05604695d962f9a0dc191da0bf2
--- a/backend/app/models/tables.py
+++ b/backend/app/models/tables.py
@@ -163,6 +163,10 @@
     email_verified: Mapped[Optional[datetime]] = mapped_column(sa.DateTime(timezone=True))
     credits_balance: Mapped[int] = mapped_column(sa.Integer, nullable=False, server_default=sa.text("0"))
     signup_bonus_granted_at: Mapped[Optional[datetime]] = mapped_column(sa.DateTime(timezone=True))
+    plan: Mapped[str] = mapped_column(sa.String(20), nullable=False, server_default=sa.text("'free'"))
+    stripe_customer_id: Mapped[Optional[str]] = mapped_column(sa.String(255))
+    stripe_subscription_id: Mapped[Optional[str]] = mapped_column(sa.String(255))
+    monthly_credits_granted_at: Mapped[Optional[datetime]] = mapped_column(sa.DateTime(timezone=True))
     created_at: Mapped[datetime] = mapped_column(sa.DateTime(timezone=True), server_default=sa.text("now()"))
     updated_at: Mapped[datetime] = mapped_column(
         sa.DateTime(timezone=True), server_default=sa.text("now()"), onupdate=sa.func.now()
diff --git a/backend/app/services/auth_service.py b/backend/app/services/auth_service.py
index cc72086b50ebd5497e7cdada96a60506fa7d9c05..6b57ee07cdff8f392a533172f8e7507a3e131cc4
--- a/backend/app/services/auth_service.py
+++ b/backend/app/services/auth_service.py
@@ -52,6 +52,7 @@
         email_verified=email_verified,
         credits_balance=SIGNUP_BONUS_CREDITS,
         signup_bonus_granted_at=datetime.utcnow(),
+        monthly_credits_granted_at=datetime.utcnow(),
     )
     db.add(user)
 
@@ -179,4 +180,3 @@
     await db.delete(vt)
     await db.commit()
     return vt
-
diff --git a/backend/app/services/credit_service.py b/backend/app/services/credit_service.py
index d89772b0418d1ebe1a79bba3de65f0112a550adb..a599453a961fb9222db98928201795c4fa4e574b
--- a/backend/app/services/credit_service.py
+++ b/backend/app/services/credit_service.py
@@ -7,6 +7,7 @@
 from sqlalchemy.ext.asyncio import AsyncSession
 
 from app.models.tables import CreditLedger, UsageRecord, User
+from app.core.config import settings
 
 
 # Token-to-credit rates by model tier
@@ -144,3 +145,56 @@
     db.add(usage)
     return usage
 
+
+async def ensure_monthly_credits(db: AsyncSession, user: User) -> None:
+    """Grant monthly credits if last grant was over 30 days ago.
+
+    Idempotency: checks CreditLedger for any recent 'monthly_allowance' within 30 days.
+    """
+    from datetime import datetime, timedelta, timezone
+
+    # Determine if grant needed based on timestamp
+    now = datetime.now(timezone.utc)
+    last = user.monthly_credits_granted_at
+    needs_grant = last is None or (now - last) >= timedelta(days=30)
+    if not needs_grant:
+        return
+
+    # Check ledger for idempotency within last 30 days
+    cutoff = now - timedelta(days=30)
+    existing = await db.scalar(
+        sa.select(CreditLedger)
+        .where(CreditLedger.user_id == user.id)
+        .where(CreditLedger.reason == "monthly_allowance")
+        .where(CreditLedger.created_at >= cutoff)
+    )
+    if existing:
+        # Still update marker to avoid repeatedly checking in future requests
+        user.monthly_credits_granted_at = now
+        await db.flush()
+        return
+
+    # Determine allowance by plan
+    plan = (user.plan or "free").lower()
+    if plan == "pro":
+        allowance = int(settings.PLAN_PRO_MONTHLY_CREDITS or 0)
+    else:
+        allowance = int(settings.PLAN_FREE_MONTHLY_CREDITS or 0)
+
+    if allowance <= 0:
+        # Nothing to grant
+        user.monthly_credits_granted_at = now
+        await db.flush()
+        return
+
+    # Grant credits and update marker
+    await credit_credits(
+        db,
+        user_id=user.id,
+        amount=allowance,
+        reason="monthly_allowance",
+        ref_type=None,
+        ref_id=None,
+    )
+    user.monthly_credits_granted_at = now
+    await db.flush()

exec
bash -lc "sed -n '1,300p' backend/tests/conftest.py" in /Users/mayijie/Projects/Code/010_DocTalk succeeded in 16ms:
import os
import sys
from pathlib import Path

import pytest
import httpx


# Ensure the backend package path (backend/) is importable so `from app.main import app` works
BACKEND_DIR = Path(__file__).resolve().parents[1]
if str(BACKEND_DIR) not in sys.path:
    sys.path.insert(0, str(BACKEND_DIR))

# Provide a default DATABASE_URL so importing the app doesn't fail during tests
# Use asyncpg driver (present in requirements) to avoid missing driver errors.
os.environ.setdefault(
    "DATABASE_URL", "postgresql+asyncpg://postgres:postgres@localhost:5432/postgres"
)


file update:
diff --git a/backend/alembic/versions/20260206_0004_add_subscription_fields.py b/backend/alembic/versions/20260206_0004_add_subscription_fields.py
new file mode 100644
index 0000000000000000000000000000000000000000..f84be09226785ea3dbc1b413b3cfd2cb07dff81e
--- /dev/null
+++ b/backend/alembic/versions/20260206_0004_add_subscription_fields.py
@@ -0,0 +1,38 @@
+"""add subscription fields to users
+
+Revision ID: d4e5f6a7b8c9
+Revises: c3d4e5f6a7b8
+Create Date: 2026-02-06 00:40:00
+
+"""
+from __future__ import annotations
+
+from alembic import op
+import sqlalchemy as sa
+
+
+# revision identifiers, used by Alembic.
+revision = "d4e5f6a7b8c9"
+down_revision = "c3d4e5f6a7b8"
+branch_labels = None
+depends_on = None
+
+
+def upgrade() -> None:
+    # Add subscription-related columns to users
+    op.add_column(
+        "users",
+        sa.Column("plan", sa.String(length=20), nullable=False, server_default=sa.text("'free'")),
+    )
+    op.add_column("users", sa.Column("stripe_customer_id", sa.String(length=255), nullable=True))
+    op.add_column("users", sa.Column("stripe_subscription_id", sa.String(length=255), nullable=True))
+    op.add_column("users", sa.Column("monthly_credits_granted_at", sa.DateTime(timezone=True), nullable=True))
+
+
+def downgrade() -> None:
+    # Drop subscription-related columns from users
+    op.drop_column("users", "monthly_credits_granted_at")
+    op.drop_column("users", "stripe_subscription_id")
+    op.drop_column("users", "stripe_customer_id")
+    op.drop_column("users", "plan")
+
diff --git a/backend/app/api/billing.py b/backend/app/api/billing.py
index 851620df69f9c62fb3cab15feeedcafff44cc6bb..f99355cf848497a82c150ed57c5c5b2c20aa5e2e
--- a/backend/app/api/billing.py
+++ b/backend/app/api/billing.py
@@ -58,6 +58,47 @@
     return {"checkout_url": session.url}
 
 
+# Subscriptions
+@router.post("/subscribe")
+async def subscribe(
+    user: User = Depends(require_auth),
+    db: AsyncSession = Depends(get_db_session),
+):
+    if not settings.STRIPE_SECRET_KEY or not settings.STRIPE_PRICE_PRO_MONTHLY:
+        raise HTTPException(503, "Stripe not configured")
+
+    # Ensure customer exists
+    if not user.stripe_customer_id:
+        cust = stripe.Customer.create(email=user.email, name=user.name or None)
+        user.stripe_customer_id = cust.id
+        await db.commit()
+
+    # Create Checkout Session for subscription
+    session = stripe.checkout.Session.create(
+        mode="subscription",
+        line_items=[{"price": settings.STRIPE_PRICE_PRO_MONTHLY, "quantity": 1}],
+        success_url=f"{settings.FRONTEND_URL}/billing",
+        cancel_url=f"{settings.FRONTEND_URL}/billing",
+        customer=user.stripe_customer_id,
+        client_reference_id=str(user.id),
+    )
+    return {"checkout_url": session.url}
+
+
+@router.post("/portal")
+async def customer_portal(user: User = Depends(require_auth)):
+    if not settings.STRIPE_SECRET_KEY:
+        raise HTTPException(503, "Stripe not configured")
+    if not user.stripe_customer_id:
+        raise HTTPException(400, "No Stripe customer for user")
+
+    portal = stripe.billing_portal.Session.create(
+        customer=user.stripe_customer_id,
+        return_url=f"{settings.FRONTEND_URL}/billing",
+    )
+    return {"portal_url": portal.url}
+
+
 @router.post("/webhook")
 async def stripe_webhook(request: Request, db: AsyncSession = Depends(get_db_session)):
     payload = await request.body()
@@ -85,70 +126,196 @@
             logger.error("Invalid event structure: missing data.object")
             return {"received": True}
 
-        # Parse and validate client_reference_id (user_id)
-        try:
-            client_ref = session.get("client_reference_id")
-            if not client_ref:
-                logger.error("Missing client_reference_id in checkout session")
+        mode = session.get("mode")
+
+        # Handle subscription checkout
+        if mode == "subscription":
+            try:
+                client_ref = session.get("client_reference_id")
+                if not client_ref:
+                    logger.error("Missing client_reference_id in subscription session")
+                    return {"received": True}
+                user_id = uuid.UUID(client_ref)
+            except (ValueError, TypeError) as e:
+                logger.error("Invalid client_reference_id: %s", e)
+                return {"received": True}
+
+            user = await db.get(User, user_id)
+            if not user:
+                logger.warning("Subscription completed for non-existent user %s", user_id)
                 return {"received": True}
-            user_id = uuid.UUID(client_ref)
-        except (ValueError, TypeError) as e:
-            logger.error("Invalid client_reference_id: %s", e)
+
+            subscription_id = session.get("subscription")
+            customer_id = session.get("customer")
+
+            # Update user plan and subscription/customer ids
+            user.plan = "pro"
+            if subscription_id:
+                user.stripe_subscription_id = subscription_id
+            if customer_id and not user.stripe_customer_id:
+                user.stripe_customer_id = customer_id
+
+            # Idempotency: only one monthly grant per subscription id at start
+            existing = await db.scalar(
+                select(CreditLedger).where(
+                    CreditLedger.ref_type == "stripe_subscription",
+                    CreditLedger.ref_id == (subscription_id or ""),
+                )
+            )
+
+            if not existing:
+                try:
+                    await credit_credits(
+                        db,
+                        user_id=user.id,
+                        amount=int(settings.PLAN_PRO_MONTHLY_CREDITS or 0),
+                        reason="monthly_allowance",
+                        ref_type="stripe_subscription",
+                        ref_id=subscription_id or "",
+                    )
+                    await db.commit()
+                    logger.info(
+                        "Subscription start credits granted: user_id=%s, subscription=%s",
+                        user.id,
+                        subscription_id,
+                    )
+                except Exception as e:
+                    await db.rollback()
+                    logger.error("Failed to grant subscription start credits: %s", e)
+                    raise HTTPException(500, "Database error")
+            else:
+                await db.commit()
+
             return {"received": True}
 
-        # Parse and validate credits amount
-        try:
-            metadata = session.get("metadata", {})
-            credits_str = metadata.get("credits")
-            if not credits_str:
-                logger.error("Missing credits in session metadata")
+        # Handle one-time credit pack checkout
+        if mode == "payment":
+            # Parse and validate client_reference_id (user_id)
+            try:
+                client_ref = session.get("client_reference_id")
+                if not client_ref:
+                    logger.error("Missing client_reference_id in checkout session")
+                    return {"received": True}
+                user_id = uuid.UUID(client_ref)
+            except (ValueError, TypeError) as e:
+                logger.error("Invalid client_reference_id: %s", e)
                 return {"received": True}
-            credits = int(credits_str)
-            if credits <= 0:
-                logger.error("Invalid credits amount: %d", credits)
+
+            # Parse and validate credits amount
+            try:
+                metadata = session.get("metadata", {})
+                credits_str = metadata.get("credits")
+                if not credits_str:
+                    logger.error("Missing credits in session metadata")
+                    return {"received": True}
+                credits = int(credits_str)
+                if credits <= 0:
+                    logger.error("Invalid credits amount: %d", credits)
+                    return {"received": True}
+            except (ValueError, TypeError) as e:
+                logger.error("Cannot parse credits from metadata: %s", e)
+                return {"received": True}
+
+            # Get payment_intent for idempotency
+            payment_intent = session.get("payment_intent")
+            if not payment_intent:
+                logger.warning("Checkout session has no payment_intent, skipping for safety")
                 return {"received": True}
-        except (ValueError, TypeError) as e:
-            logger.error("Cannot parse credits from metadata: %s", e)
+
+            # Verify user exists
+            user = await db.get(User, user_id)
+            if not user:
+                logger.warning("Webhook for non-existent user %s", user_id)
+                return {"received": True}
+
+            # Idempotency check
+            existing = await db.scalar(
+                select(CreditLedger).where(
+                    CreditLedger.ref_type == "stripe_payment",
+                    CreditLedger.ref_id == payment_intent,
+                )
+            )
+
+            if not existing:
+                try:
+                    await credit_credits(
+                        db,
+                        user_id,
+                        credits,
+                        reason="purchase",
+                        ref_type="stripe_payment",
+                        ref_id=payment_intent,
+                    )
+                    await db.commit()
+                    logger.info(
+                        "Credits granted: user_id=%s, credits=%d, payment_intent=%s",
+                        user_id,
+                        credits,
+                        payment_intent,
+                    )
+                except Exception as e:
+                    await db.rollback()
+                    logger.error("Failed to grant credits: %s", e)
+                    # Return 5xx so Stripe retries
+                    raise HTTPException(500, "Database error")
+            return {"received": True}
+
+    elif event["type"] == "invoice.payment_succeeded":
+    
+        obj = event.get("data", {}).get("object")
+        if not obj or not isinstance(obj, dict):
             return {"received": True}
 
-        # Get payment_intent for idempotency
-        payment_intent = session.get("payment_intent")
-        if not payment_intent:
-            logger.warning("Checkout session has no payment_intent, skipping for safety")
+        invoice_id = obj.get("id")
+        customer_id = obj.get("customer")
+        if not invoice_id or not customer_id:
             return {"received": True}
 
-        # Verify user exists
-        user = await db.get(User, user_id)
+        # Find user by customer id
+        user = await db.scalar(select(User).where(User.stripe_customer_id == customer_id))
         if not user:
-            logger.warning("Webhook for non-existent user %s", user_id)
             return {"received": True}
 
-        # Idempotency check
+        # Idempotency: ensure we haven't granted for this invoice
         existing = await db.scalar(
             select(CreditLedger).where(
-                CreditLedger.ref_type == "stripe_payment",
-                CreditLedger.ref_id == payment_intent,
+                CreditLedger.ref_type == "stripe_invoice",
+                CreditLedger.ref_id == invoice_id,
             )
         )
-
         if not existing:
             try:
                 await credit_credits(
                     db,
-                    user_id,
-                    credits,
-                    reason="purchase",
-                    ref_type="stripe_payment",
-                    ref_id=payment_intent,
+                    user_id=user.id,
+                    amount=int(settings.PLAN_PRO_MONTHLY_CREDITS or 0),
+                    reason="monthly_allowance",
+                    ref_type="stripe_invoice",
+                    ref_id=invoice_id,
                 )
                 await db.commit()
-                logger.info("Credits granted: user_id=%s, credits=%d, payment_intent=%s",
-                           user_id, credits, payment_intent)
             except Exception as e:
                 await db.rollback()
-                logger.error("Failed to grant credits: %s", e)
-                # Return 5xx so Stripe retries
+                logger.error("Failed to grant monthly credits on invoice: %s", e)
                 raise HTTPException(500, "Database error")
+        return {"received": True}
+
+    elif event["type"] == "customer.subscription.deleted":
+        obj = event.get("data", {}).get("object")
+        if not obj or not isinstance(obj, dict):
+            return {"received": True}
 
-    return {"received": True}
+        customer_id = obj.get("customer")
+        if not customer_id:
+            return {"received": True}
 
+        user = await db.scalar(select(User).where(User.stripe_customer_id == customer_id))
+        if not user:
+            return {"received": True}
+
+        user.plan = "free"
+        user.stripe_subscription_id = None
+        await db.commit()
+        return {"received": True}
+
+    return {"received": True}
diff --git a/backend/app/api/chat.py b/backend/app/api/chat.py
index 71fc751fa90239dfe90bf76e3b30a7aa686d0c3f..d52dc47026e109df283984196581d417a4fea1dc
--- a/backend/app/api/chat.py
+++ b/backend/app/api/chat.py
@@ -133,6 +133,9 @@
 
     # If authenticated, ensure sufficient credits before opening stream
     if user is not None:
+        from app.services.credit_service import ensure_monthly_credits
+        await ensure_monthly_credits(db, user)
+        await db.commit()
         balance = await credit_service.get_user_credits(db, user.id)
         if balance < credit_service.MIN_CREDITS_FOR_CHAT:
             return JSONResponse(
diff --git a/backend/app/core/config.py b/backend/app/core/config.py
index 830f599a7b1ff02463684a9e84e90adfd6318cc1..a8eef6c5b4145c3710d46395bf26465dec42b4a7
--- a/backend/app/core/config.py
+++ b/backend/app/core/config.py
@@ -75,6 +75,10 @@
     CREDITS_PRO: int = 200000
     CREDITS_ENTERPRISE: int = 1000000
     SIGNUP_BONUS_CREDITS: int = 10000
+    # Subscription tiers
+    PLAN_FREE_MONTHLY_CREDITS: int = 10000
+    PLAN_PRO_MONTHLY_CREDITS: int = 100000
+    STRIPE_PRICE_PRO_MONTHLY: str = ''
 
     model_config = SettingsConfigDict(env_file=".env", env_file_encoding="utf-8", case_sensitive=False)
 
diff --git a/backend/app/models/tables.py b/backend/app/models/tables.py
index 2eb9239abb3f01f8a4103944db02efcb27f20149..9caeafd2d73fb05604695d962f9a0dc191da0bf2
--- a/backend/app/models/tables.py
+++ b/backend/app/models/tables.py
@@ -163,6 +163,10 @@
     email_verified: Mapped[Optional[datetime]] = mapped_column(sa.DateTime(timezone=True))
     credits_balance: Mapped[int] = mapped_column(sa.Integer, nullable=False, server_default=sa.text("0"))
     signup_bonus_granted_at: Mapped[Optional[datetime]] = mapped_column(sa.DateTime(timezone=True))
+    plan: Mapped[str] = mapped_column(sa.String(20), nullable=False, server_default=sa.text("'free'"))
+    stripe_customer_id: Mapped[Optional[str]] = mapped_column(sa.String(255))
+    stripe_subscription_id: Mapped[Optional[str]] = mapped_column(sa.String(255))
+    monthly_credits_granted_at: Mapped[Optional[datetime]] = mapped_column(sa.DateTime(timezone=True))
     created_at: Mapped[datetime] = mapped_column(sa.DateTime(timezone=True), server_default=sa.text("now()"))
     updated_at: Mapped[datetime] = mapped_column(
         sa.DateTime(timezone=True), server_default=sa.text("now()"), onupdate=sa.func.now()
diff --git a/backend/app/services/auth_service.py b/backend/app/services/auth_service.py
index cc72086b50ebd5497e7cdada96a60506fa7d9c05..6b57ee07cdff8f392a533172f8e7507a3e131cc4
--- a/backend/app/services/auth_service.py
+++ b/backend/app/services/auth_service.py
@@ -52,6 +52,7 @@
         email_verified=email_verified,
         credits_balance=SIGNUP_BONUS_CREDITS,
         signup_bonus_granted_at=datetime.utcnow(),
+        monthly_credits_granted_at=datetime.utcnow(),
     )
     db.add(user)
 
@@ -179,4 +180,3 @@
     await db.delete(vt)
     await db.commit()
     return vt
-
diff --git a/backend/app/services/credit_service.py b/backend/app/services/credit_service.py
index d89772b0418d1ebe1a79bba3de65f0112a550adb..a599453a961fb9222db98928201795c4fa4e574b
--- a/backend/app/services/credit_service.py
+++ b/backend/app/services/credit_service.py
@@ -7,6 +7,7 @@
 from sqlalchemy.ext.asyncio import AsyncSession
 
 from app.models.tables import CreditLedger, UsageRecord, User
+from app.core.config import settings
 
 
 # Token-to-credit rates by model tier
@@ -144,3 +145,56 @@
     db.add(usage)
     return usage
 
+
+async def ensure_monthly_credits(db: AsyncSession, user: User) -> None:
+    """Grant monthly credits if last grant was over 30 days ago.
+
+    Idempotency: checks CreditLedger for any recent 'monthly_allowance' within 30 days.
+    """
+    from datetime import datetime, timedelta, timezone
+
+    # Determine if grant needed based on timestamp
+    now = datetime.now(timezone.utc)
+    last = user.monthly_credits_granted_at
+    needs_grant = last is None or (now - last) >= timedelta(days=30)
+    if not needs_grant:
+        return
+
+    # Check ledger for idempotency within last 30 days
+    cutoff = now - timedelta(days=30)
+    existing = await db.scalar(
+        sa.select(CreditLedger)
+        .where(CreditLedger.user_id == user.id)
+        .where(CreditLedger.reason == "monthly_allowance")
+        .where(CreditLedger.created_at >= cutoff)
+    )
+    if existing:
+        # Still update marker to avoid repeatedly checking in future requests
+        user.monthly_credits_granted_at = now
+        await db.flush()
+        return
+
+    # Determine allowance by plan
+    plan = (user.plan or "free").lower()
+    if plan == "pro":
+        allowance = int(settings.PLAN_PRO_MONTHLY_CREDITS or 0)
+    else:
+        allowance = int(settings.PLAN_FREE_MONTHLY_CREDITS or 0)
+
+    if allowance <= 0:
+        # Nothing to grant
+        user.monthly_credits_granted_at = now
+        await db.flush()
+        return
+
+    # Grant credits and update marker
+    await credit_credits(
+        db,
+        user_id=user.id,
+        amount=allowance,
+        reason="monthly_allowance",
+        ref_type=None,
+        ref_id=None,
+    )
+    user.monthly_credits_granted_at = now
+    await db.flush()

file update
M /Users/mayijie/Projects/Code/010_DocTalk/backend/app/services/credit_service.py
@@ -158,2 +158,5 @@
     last = user.monthly_credits_granted_at
+    if last is not None and last.tzinfo is None:
+        # Treat naive as UTC
+        last = last.replace(tzinfo=timezone.utc)
     needs_grant = last is None or (now - last) >= timedelta(days=30)
apply_patch(auto_approved=true) exited 0 in 85ms:
Success. Updated the following files:
M backend/app/services/credit_service.py
file update:
diff --git a/backend/alembic/versions/20260206_0004_add_subscription_fields.py b/backend/alembic/versions/20260206_0004_add_subscription_fields.py
new file mode 100644
index 0000000000000000000000000000000000000000..f84be09226785ea3dbc1b413b3cfd2cb07dff81e
--- /dev/null
+++ b/backend/alembic/versions/20260206_0004_add_subscription_fields.py
@@ -0,0 +1,38 @@
+"""add subscription fields to users
+
+Revision ID: d4e5f6a7b8c9
+Revises: c3d4e5f6a7b8
+Create Date: 2026-02-06 00:40:00
+
+"""
+from __future__ import annotations
+
+from alembic import op
+import sqlalchemy as sa
+
+
+# revision identifiers, used by Alembic.
+revision = "d4e5f6a7b8c9"
+down_revision = "c3d4e5f6a7b8"
+branch_labels = None
+depends_on = None
+
+
+def upgrade() -> None:
+    # Add subscription-related columns to users
+    op.add_column(
+        "users",
+        sa.Column("plan", sa.String(length=20), nullable=False, server_default=sa.text("'free'")),
+    )
+    op.add_column("users", sa.Column("stripe_customer_id", sa.String(length=255), nullable=True))
+    op.add_column("users", sa.Column("stripe_subscription_id", sa.String(length=255), nullable=True))
+    op.add_column("users", sa.Column("monthly_credits_granted_at", sa.DateTime(timezone=True), nullable=True))
+
+
+def downgrade() -> None:
+    # Drop subscription-related columns from users
+    op.drop_column("users", "monthly_credits_granted_at")
+    op.drop_column("users", "stripe_subscription_id")
+    op.drop_column("users", "stripe_customer_id")
+    op.drop_column("users", "plan")
+
diff --git a/backend/app/api/billing.py b/backend/app/api/billing.py
index 851620df69f9c62fb3cab15feeedcafff44cc6bb..f99355cf848497a82c150ed57c5c5b2c20aa5e2e
--- a/backend/app/api/billing.py
+++ b/backend/app/api/billing.py
@@ -58,6 +58,47 @@
     return {"checkout_url": session.url}
 
 
+# Subscriptions
+@router.post("/subscribe")
+async def subscribe(
+    user: User = Depends(require_auth),
+    db: AsyncSession = Depends(get_db_session),
+):
+    if not settings.STRIPE_SECRET_KEY or not settings.STRIPE_PRICE_PRO_MONTHLY:
+        raise HTTPException(503, "Stripe not configured")
+
+    # Ensure customer exists
+    if not user.stripe_customer_id:
+        cust = stripe.Customer.create(email=user.email, name=user.name or None)
+        user.stripe_customer_id = cust.id
+        await db.commit()
+
+    # Create Checkout Session for subscription
+    session = stripe.checkout.Session.create(
+        mode="subscription",
+        line_items=[{"price": settings.STRIPE_PRICE_PRO_MONTHLY, "quantity": 1}],
+        success_url=f"{settings.FRONTEND_URL}/billing",
+        cancel_url=f"{settings.FRONTEND_URL}/billing",
+        customer=user.stripe_customer_id,
+        client_reference_id=str(user.id),
+    )
+    return {"checkout_url": session.url}
+
+
+@router.post("/portal")
+async def customer_portal(user: User = Depends(require_auth)):
+    if not settings.STRIPE_SECRET_KEY:
+        raise HTTPException(503, "Stripe not configured")
+    if not user.stripe_customer_id:
+        raise HTTPException(400, "No Stripe customer for user")
+
+    portal = stripe.billing_portal.Session.create(
+        customer=user.stripe_customer_id,
+        return_url=f"{settings.FRONTEND_URL}/billing",
+    )
+    return {"portal_url": portal.url}
+
+
 @router.post("/webhook")
 async def stripe_webhook(request: Request, db: AsyncSession = Depends(get_db_session)):
     payload = await request.body()
@@ -85,70 +126,196 @@
             logger.error("Invalid event structure: missing data.object")
             return {"received": True}
 
-        # Parse and validate client_reference_id (user_id)
-        try:
-            client_ref = session.get("client_reference_id")
-            if not client_ref:
-                logger.error("Missing client_reference_id in checkout session")
+        mode = session.get("mode")
+
+        # Handle subscription checkout
+        if mode == "subscription":
+            try:
+                client_ref = session.get("client_reference_id")
+                if not client_ref:
+                    logger.error("Missing client_reference_id in subscription session")
+                    return {"received": True}
+                user_id = uuid.UUID(client_ref)
+            except (ValueError, TypeError) as e:
+                logger.error("Invalid client_reference_id: %s", e)
+                return {"received": True}
+
+            user = await db.get(User, user_id)
+            if not user:
+                logger.warning("Subscription completed for non-existent user %s", user_id)
                 return {"received": True}
-            user_id = uuid.UUID(client_ref)
-        except (ValueError, TypeError) as e:
-            logger.error("Invalid client_reference_id: %s", e)
+
+            subscription_id = session.get("subscription")
+            customer_id = session.get("customer")
+
+            # Update user plan and subscription/customer ids
+            user.plan = "pro"
+            if subscription_id:
+                user.stripe_subscription_id = subscription_id
+            if customer_id and not user.stripe_customer_id:
+                user.stripe_customer_id = customer_id
+
+            # Idempotency: only one monthly grant per subscription id at start
+            existing = await db.scalar(
+                select(CreditLedger).where(
+                    CreditLedger.ref_type == "stripe_subscription",
+                    CreditLedger.ref_id == (subscription_id or ""),
+                )
+            )
+
+            if not existing:
+                try:
+                    await credit_credits(
+                        db,
+                        user_id=user.id,
+                        amount=int(settings.PLAN_PRO_MONTHLY_CREDITS or 0),
+                        reason="monthly_allowance",
+                        ref_type="stripe_subscription",
+                        ref_id=subscription_id or "",
+                    )
+                    await db.commit()
+                    logger.info(
+                        "Subscription start credits granted: user_id=%s, subscription=%s",
+                        user.id,
+                        subscription_id,
+                    )
+                except Exception as e:
+                    await db.rollback()
+                    logger.error("Failed to grant subscription start credits: %s", e)
+                    raise HTTPException(500, "Database error")
+            else:
+                await db.commit()
+
             return {"received": True}
 
-        # Parse and validate credits amount
-        try:
-            metadata = session.get("metadata", {})
-            credits_str = metadata.get("credits")
-            if not credits_str:
-                logger.error("Missing credits in session metadata")
+        # Handle one-time credit pack checkout
+        if mode == "payment":
+            # Parse and validate client_reference_id (user_id)
+            try:
+                client_ref = session.get("client_reference_id")
+                if not client_ref:
+                    logger.error("Missing client_reference_id in checkout session")
+                    return {"received": True}
+                user_id = uuid.UUID(client_ref)
+            except (ValueError, TypeError) as e:
+                logger.error("Invalid client_reference_id: %s", e)
                 return {"received": True}
-            credits = int(credits_str)
-            if credits <= 0:
-                logger.error("Invalid credits amount: %d", credits)
+
+            # Parse and validate credits amount
+            try:
+                metadata = session.get("metadata", {})
+                credits_str = metadata.get("credits")
+                if not credits_str:
+                    logger.error("Missing credits in session metadata")
+                    return {"received": True}
+                credits = int(credits_str)
+                if credits <= 0:
+                    logger.error("Invalid credits amount: %d", credits)
+                    return {"received": True}
+            except (ValueError, TypeError) as e:
+                logger.error("Cannot parse credits from metadata: %s", e)
+                return {"received": True}
+
+            # Get payment_intent for idempotency
+            payment_intent = session.get("payment_intent")
+            if not payment_intent:
+                logger.warning("Checkout session has no payment_intent, skipping for safety")
                 return {"received": True}
-        except (ValueError, TypeError) as e:
-            logger.error("Cannot parse credits from metadata: %s", e)
+
+            # Verify user exists
+            user = await db.get(User, user_id)
+            if not user:
+                logger.warning("Webhook for non-existent user %s", user_id)
+                return {"received": True}
+
+            # Idempotency check
+            existing = await db.scalar(
+                select(CreditLedger).where(
+                    CreditLedger.ref_type == "stripe_payment",
+                    CreditLedger.ref_id == payment_intent,
+                )
+            )
+
+            if not existing:
+                try:
+                    await credit_credits(
+                        db,
+                        user_id,
+                        credits,
+                        reason="purchase",
+                        ref_type="stripe_payment",
+                        ref_id=payment_intent,
+                    )
+                    await db.commit()
+                    logger.info(
+                        "Credits granted: user_id=%s, credits=%d, payment_intent=%s",
+                        user_id,
+                        credits,
+                        payment_intent,
+                    )
+                except Exception as e:
+                    await db.rollback()
+                    logger.error("Failed to grant credits: %s", e)
+                    # Return 5xx so Stripe retries
+                    raise HTTPException(500, "Database error")
+            return {"received": True}
+
+    elif event["type"] == "invoice.payment_succeeded":
+    
+        obj = event.get("data", {}).get("object")
+        if not obj or not isinstance(obj, dict):
             return {"received": True}
 
-        # Get payment_intent for idempotency
-        payment_intent = session.get("payment_intent")
-        if not payment_intent:
-            logger.warning("Checkout session has no payment_intent, skipping for safety")
+        invoice_id = obj.get("id")
+        customer_id = obj.get("customer")
+        if not invoice_id or not customer_id:
             return {"received": True}
 
-        # Verify user exists
-        user = await db.get(User, user_id)
+        # Find user by customer id
+        user = await db.scalar(select(User).where(User.stripe_customer_id == customer_id))
         if not user:
-            logger.warning("Webhook for non-existent user %s", user_id)
             return {"received": True}
 
-        # Idempotency check
+        # Idempotency: ensure we haven't granted for this invoice
         existing = await db.scalar(
             select(CreditLedger).where(
-                CreditLedger.ref_type == "stripe_payment",
-                CreditLedger.ref_id == payment_intent,
+                CreditLedger.ref_type == "stripe_invoice",
+                CreditLedger.ref_id == invoice_id,
             )
         )
-
         if not existing:
             try:
                 await credit_credits(
                     db,
-                    user_id,
-                    credits,
-                    reason="purchase",
-                    ref_type="stripe_payment",
-                    ref_id=payment_intent,
+                    user_id=user.id,
+                    amount=int(settings.PLAN_PRO_MONTHLY_CREDITS or 0),
+                    reason="monthly_allowance",
+                    ref_type="stripe_invoice",
+                    ref_id=invoice_id,
                 )
                 await db.commit()
-                logger.info("Credits granted: user_id=%s, credits=%d, payment_intent=%s",
-                           user_id, credits, payment_intent)
             except Exception as e:
                 await db.rollback()
-                logger.error("Failed to grant credits: %s", e)
-                # Return 5xx so Stripe retries
+                logger.error("Failed to grant monthly credits on invoice: %s", e)
                 raise HTTPException(500, "Database error")
+        return {"received": True}
+
+    elif event["type"] == "customer.subscription.deleted":
+        obj = event.get("data", {}).get("object")
+        if not obj or not isinstance(obj, dict):
+            return {"received": True}
 
-    return {"received": True}
+        customer_id = obj.get("customer")
+        if not customer_id:
+            return {"received": True}
 
+        user = await db.scalar(select(User).where(User.stripe_customer_id == customer_id))
+        if not user:
+            return {"received": True}
+
+        user.plan = "free"
+        user.stripe_subscription_id = None
+        await db.commit()
+        return {"received": True}
+
+    return {"received": True}
diff --git a/backend/app/api/chat.py b/backend/app/api/chat.py
index 71fc751fa90239dfe90bf76e3b30a7aa686d0c3f..d52dc47026e109df283984196581d417a4fea1dc
--- a/backend/app/api/chat.py
+++ b/backend/app/api/chat.py
@@ -133,6 +133,9 @@
 
     # If authenticated, ensure sufficient credits before opening stream
     if user is not None:
+        from app.services.credit_service import ensure_monthly_credits
+        await ensure_monthly_credits(db, user)
+        await db.commit()
         balance = await credit_service.get_user_credits(db, user.id)
         if balance < credit_service.MIN_CREDITS_FOR_CHAT:
             return JSONResponse(
diff --git a/backend/app/core/config.py b/backend/app/core/config.py
index 830f599a7b1ff02463684a9e84e90adfd6318cc1..a8eef6c5b4145c3710d46395bf26465dec42b4a7
--- a/backend/app/core/config.py
+++ b/backend/app/core/config.py
@@ -75,6 +75,10 @@
     CREDITS_PRO: int = 200000
     CREDITS_ENTERPRISE: int = 1000000
     SIGNUP_BONUS_CREDITS: int = 10000
+    # Subscription tiers
+    PLAN_FREE_MONTHLY_CREDITS: int = 10000
+    PLAN_PRO_MONTHLY_CREDITS: int = 100000
+    STRIPE_PRICE_PRO_MONTHLY: str = ''
 
     model_config = SettingsConfigDict(env_file=".env", env_file_encoding="utf-8", case_sensitive=False)
 
diff --git a/backend/app/models/tables.py b/backend/app/models/tables.py
index 2eb9239abb3f01f8a4103944db02efcb27f20149..9caeafd2d73fb05604695d962f9a0dc191da0bf2
--- a/backend/app/models/tables.py
+++ b/backend/app/models/tables.py
@@ -163,6 +163,10 @@
     email_verified: Mapped[Optional[datetime]] = mapped_column(sa.DateTime(timezone=True))
     credits_balance: Mapped[int] = mapped_column(sa.Integer, nullable=False, server_default=sa.text("0"))
     signup_bonus_granted_at: Mapped[Optional[datetime]] = mapped_column(sa.DateTime(timezone=True))
+    plan: Mapped[str] = mapped_column(sa.String(20), nullable=False, server_default=sa.text("'free'"))
+    stripe_customer_id: Mapped[Optional[str]] = mapped_column(sa.String(255))
+    stripe_subscription_id: Mapped[Optional[str]] = mapped_column(sa.String(255))
+    monthly_credits_granted_at: Mapped[Optional[datetime]] = mapped_column(sa.DateTime(timezone=True))
     created_at: Mapped[datetime] = mapped_column(sa.DateTime(timezone=True), server_default=sa.text("now()"))
     updated_at: Mapped[datetime] = mapped_column(
         sa.DateTime(timezone=True), server_default=sa.text("now()"), onupdate=sa.func.now()
diff --git a/backend/app/services/auth_service.py b/backend/app/services/auth_service.py
index cc72086b50ebd5497e7cdada96a60506fa7d9c05..6b57ee07cdff8f392a533172f8e7507a3e131cc4
--- a/backend/app/services/auth_service.py
+++ b/backend/app/services/auth_service.py
@@ -52,6 +52,7 @@
         email_verified=email_verified,
         credits_balance=SIGNUP_BONUS_CREDITS,
         signup_bonus_granted_at=datetime.utcnow(),
+        monthly_credits_granted_at=datetime.utcnow(),
     )
     db.add(user)
 
@@ -179,4 +180,3 @@
     await db.delete(vt)
     await db.commit()
     return vt
-
diff --git a/backend/app/services/credit_service.py b/backend/app/services/credit_service.py
index d89772b0418d1ebe1a79bba3de65f0112a550adb..55fa0e1abd98fa8c3f32c2aa71826235df6a9fc3
--- a/backend/app/services/credit_service.py
+++ b/backend/app/services/credit_service.py
@@ -7,6 +7,7 @@
 from sqlalchemy.ext.asyncio import AsyncSession
 
 from app.models.tables import CreditLedger, UsageRecord, User
+from app.core.config import settings
 
 
 # Token-to-credit rates by model tier
@@ -144,3 +145,59 @@
     db.add(usage)
     return usage
 
+
+async def ensure_monthly_credits(db: AsyncSession, user: User) -> None:
+    """Grant monthly credits if last grant was over 30 days ago.
+
+    Idempotency: checks CreditLedger for any recent 'monthly_allowance' within 30 days.
+    """
+    from datetime import datetime, timedelta, timezone
+
+    # Determine if grant needed based on timestamp
+    now = datetime.now(timezone.utc)
+    last = user.monthly_credits_granted_at
+    if last is not None and last.tzinfo is None:
+        # Treat naive as UTC
+        last = last.replace(tzinfo=timezone.utc)
+    needs_grant = last is None or (now - last) >= timedelta(days=30)
+    if not needs_grant:
+        return
+
+    # Check ledger for idempotency within last 30 days
+    cutoff = now - timedelta(days=30)
+    existing = await db.scalar(
+        sa.select(CreditLedger)
+        .where(CreditLedger.user_id == user.id)
+        .where(CreditLedger.reason == "monthly_allowance")
+        .where(CreditLedger.created_at >= cutoff)
+    )
+    if existing:
+        # Still update marker to avoid repeatedly checking in future requests
+        user.monthly_credits_granted_at = now
+        await db.flush()
+        return
+
+    # Determine allowance by plan
+    plan = (user.plan or "free").lower()
+    if plan == "pro":
+        allowance = int(settings.PLAN_PRO_MONTHLY_CREDITS or 0)
+    else:
+        allowance = int(settings.PLAN_FREE_MONTHLY_CREDITS or 0)
+
+    if allowance <= 0:
+        # Nothing to grant
+        user.monthly_credits_granted_at = now
+        await db.flush()
+        return
+
+    # Grant credits and update marker
+    await credit_credits(
+        db,
+        user_id=user.id,
+        amount=allowance,
+        reason="monthly_allowance",
+        ref_type=None,
+        ref_id=None,
+    )
+    user.monthly_credits_granted_at = now
+    await db.flush()

file update:
diff --git a/backend/alembic/versions/20260206_0004_add_subscription_fields.py b/backend/alembic/versions/20260206_0004_add_subscription_fields.py
new file mode 100644
index 0000000000000000000000000000000000000000..f84be09226785ea3dbc1b413b3cfd2cb07dff81e
--- /dev/null
+++ b/backend/alembic/versions/20260206_0004_add_subscription_fields.py
@@ -0,0 +1,38 @@
+"""add subscription fields to users
+
+Revision ID: d4e5f6a7b8c9
+Revises: c3d4e5f6a7b8
+Create Date: 2026-02-06 00:40:00
+
+"""
+from __future__ import annotations
+
+from alembic import op
+import sqlalchemy as sa
+
+
+# revision identifiers, used by Alembic.
+revision = "d4e5f6a7b8c9"
+down_revision = "c3d4e5f6a7b8"
+branch_labels = None
+depends_on = None
+
+
+def upgrade() -> None:
+    # Add subscription-related columns to users
+    op.add_column(
+        "users",
+        sa.Column("plan", sa.String(length=20), nullable=False, server_default=sa.text("'free'")),
+    )
+    op.add_column("users", sa.Column("stripe_customer_id", sa.String(length=255), nullable=True))
+    op.add_column("users", sa.Column("stripe_subscription_id", sa.String(length=255), nullable=True))
+    op.add_column("users", sa.Column("monthly_credits_granted_at", sa.DateTime(timezone=True), nullable=True))
+
+
+def downgrade() -> None:
+    # Drop subscription-related columns from users
+    op.drop_column("users", "monthly_credits_granted_at")
+    op.drop_column("users", "stripe_subscription_id")
+    op.drop_column("users", "stripe_customer_id")
+    op.drop_column("users", "plan")
+
diff --git a/backend/app/api/billing.py b/backend/app/api/billing.py
index 851620df69f9c62fb3cab15feeedcafff44cc6bb..f99355cf848497a82c150ed57c5c5b2c20aa5e2e
--- a/backend/app/api/billing.py
+++ b/backend/app/api/billing.py
@@ -58,6 +58,47 @@
     return {"checkout_url": session.url}
 
 
+# Subscriptions
+@router.post("/subscribe")
+async def subscribe(
+    user: User = Depends(require_auth),
+    db: AsyncSession = Depends(get_db_session),
+):
+    if not settings.STRIPE_SECRET_KEY or not settings.STRIPE_PRICE_PRO_MONTHLY:
+        raise HTTPException(503, "Stripe not configured")
+
+    # Ensure customer exists
+    if not user.stripe_customer_id:
+        cust = stripe.Customer.create(email=user.email, name=user.name or None)
+        user.stripe_customer_id = cust.id
+        await db.commit()
+
+    # Create Checkout Session for subscription
+    session = stripe.checkout.Session.create(
+        mode="subscription",
+        line_items=[{"price": settings.STRIPE_PRICE_PRO_MONTHLY, "quantity": 1}],
+        success_url=f"{settings.FRONTEND_URL}/billing",
+        cancel_url=f"{settings.FRONTEND_URL}/billing",
+        customer=user.stripe_customer_id,
+        client_reference_id=str(user.id),
+    )
+    return {"checkout_url": session.url}
+
+
+@router.post("/portal")
+async def customer_portal(user: User = Depends(require_auth)):
+    if not settings.STRIPE_SECRET_KEY:
+        raise HTTPException(503, "Stripe not configured")
+    if not user.stripe_customer_id:
+        raise HTTPException(400, "No Stripe customer for user")
+
+    portal = stripe.billing_portal.Session.create(
+        customer=user.stripe_customer_id,
+        return_url=f"{settings.FRONTEND_URL}/billing",
+    )
+    return {"portal_url": portal.url}
+
+
 @router.post("/webhook")
 async def stripe_webhook(request: Request, db: AsyncSession = Depends(get_db_session)):
     payload = await request.body()
@@ -85,70 +126,196 @@
             logger.error("Invalid event structure: missing data.object")
             return {"received": True}
 
-        # Parse and validate client_reference_id (user_id)
-        try:
-            client_ref = session.get("client_reference_id")
-            if not client_ref:
-                logger.error("Missing client_reference_id in checkout session")
+        mode = session.get("mode")
+
+        # Handle subscription checkout
+        if mode == "subscription":
+            try:
+                client_ref = session.get("client_reference_id")
+                if not client_ref:
+                    logger.error("Missing client_reference_id in subscription session")
+                    return {"received": True}
+                user_id = uuid.UUID(client_ref)
+            except (ValueError, TypeError) as e:
+                logger.error("Invalid client_reference_id: %s", e)
+                return {"received": True}
+
+            user = await db.get(User, user_id)
+            if not user:
+                logger.warning("Subscription completed for non-existent user %s", user_id)
                 return {"received": True}
-            user_id = uuid.UUID(client_ref)
-        except (ValueError, TypeError) as e:
-            logger.error("Invalid client_reference_id: %s", e)
+
+            subscription_id = session.get("subscription")
+            customer_id = session.get("customer")
+
+            # Update user plan and subscription/customer ids
+            user.plan = "pro"
+            if subscription_id:
+                user.stripe_subscription_id = subscription_id
+            if customer_id and not user.stripe_customer_id:
+                user.stripe_customer_id = customer_id
+
+            # Idempotency: only one monthly grant per subscription id at start
+            existing = await db.scalar(
+                select(CreditLedger).where(
+                    CreditLedger.ref_type == "stripe_subscription",
+                    CreditLedger.ref_id == (subscription_id or ""),
+                )
+            )
+
+            if not existing:
+                try:
+                    await credit_credits(
+                        db,
+                        user_id=user.id,
+                        amount=int(settings.PLAN_PRO_MONTHLY_CREDITS or 0),
+                        reason="monthly_allowance",
+                        ref_type="stripe_subscription",
+                        ref_id=subscription_id or "",
+                    )
+                    await db.commit()
+                    logger.info(
+                        "Subscription start credits granted: user_id=%s, subscription=%s",
+                        user.id,
+                        subscription_id,
+                    )
+                except Exception as e:
+                    await db.rollback()
+                    logger.error("Failed to grant subscription start credits: %s", e)
+                    raise HTTPException(500, "Database error")
+            else:
+                await db.commit()
+
             return {"received": True}
 
-        # Parse and validate credits amount
-        try:
-            metadata = session.get("metadata", {})
-            credits_str = metadata.get("credits")
-            if not credits_str:
-                logger.error("Missing credits in session metadata")
+        # Handle one-time credit pack checkout
+        if mode == "payment":
+            # Parse and validate client_reference_id (user_id)
+            try:
+                client_ref = session.get("client_reference_id")
+                if not client_ref:
+                    logger.error("Missing client_reference_id in checkout session")
+                    return {"received": True}
+                user_id = uuid.UUID(client_ref)
+            except (ValueError, TypeError) as e:
+                logger.error("Invalid client_reference_id: %s", e)
                 return {"received": True}
-            credits = int(credits_str)
-            if credits <= 0:
-                logger.error("Invalid credits amount: %d", credits)
+
+            # Parse and validate credits amount
+            try:
+                metadata = session.get("metadata", {})
+                credits_str = metadata.get("credits")
+                if not credits_str:
+                    logger.error("Missing credits in session metadata")
+                    return {"received": True}
+                credits = int(credits_str)
+                if credits <= 0:
+                    logger.error("Invalid credits amount: %d", credits)
+                    return {"received": True}
+            except (ValueError, TypeError) as e:
+                logger.error("Cannot parse credits from metadata: %s", e)
+                return {"received": True}
+
+            # Get payment_intent for idempotency
+            payment_intent = session.get("payment_intent")
+            if not payment_intent:
+                logger.warning("Checkout session has no payment_intent, skipping for safety")
                 return {"received": True}
-        except (ValueError, TypeError) as e:
-            logger.error("Cannot parse credits from metadata: %s", e)
+
+            # Verify user exists
+            user = await db.get(User, user_id)
+            if not user:
+                logger.warning("Webhook for non-existent user %s", user_id)
+                return {"received": True}
+
+            # Idempotency check
+            existing = await db.scalar(
+                select(CreditLedger).where(
+                    CreditLedger.ref_type == "stripe_payment",
+                    CreditLedger.ref_id == payment_intent,
+                )
+            )
+
+            if not existing:
+                try:
+                    await credit_credits(
+                        db,
+                        user_id,
+                        credits,
+                        reason="purchase",
+                        ref_type="stripe_payment",
+                        ref_id=payment_intent,
+                    )
+                    await db.commit()
+                    logger.info(
+                        "Credits granted: user_id=%s, credits=%d, payment_intent=%s",
+                        user_id,
+                        credits,
+                        payment_intent,
+                    )
+                except Exception as e:
+                    await db.rollback()
+                    logger.error("Failed to grant credits: %s", e)
+                    # Return 5xx so Stripe retries
+                    raise HTTPException(500, "Database error")
+            return {"received": True}
+
+    elif event["type"] == "invoice.payment_succeeded":
+    
+        obj = event.get("data", {}).get("object")
+        if not obj or not isinstance(obj, dict):
             return {"received": True}
 
-        # Get payment_intent for idempotency
-        payment_intent = session.get("payment_intent")
-        if not payment_intent:
-            logger.warning("Checkout session has no payment_intent, skipping for safety")
+        invoice_id = obj.get("id")
+        customer_id = obj.get("customer")
+        if not invoice_id or not customer_id:
             return {"received": True}
 
-        # Verify user exists
-        user = await db.get(User, user_id)
+        # Find user by customer id
+        user = await db.scalar(select(User).where(User.stripe_customer_id == customer_id))
         if not user:
-            logger.warning("Webhook for non-existent user %s", user_id)
             return {"received": True}
 
-        # Idempotency check
+        # Idempotency: ensure we haven't granted for this invoice
         existing = await db.scalar(
             select(CreditLedger).where(
-                CreditLedger.ref_type == "stripe_payment",
-                CreditLedger.ref_id == payment_intent,
+                CreditLedger.ref_type == "stripe_invoice",
+                CreditLedger.ref_id == invoice_id,
             )
         )
-
         if not existing:
             try:
                 await credit_credits(
                     db,
-                    user_id,
-                    credits,
-                    reason="purchase",
-                    ref_type="stripe_payment",
-                    ref_id=payment_intent,
+                    user_id=user.id,
+                    amount=int(settings.PLAN_PRO_MONTHLY_CREDITS or 0),
+                    reason="monthly_allowance",
+                    ref_type="stripe_invoice",
+                    ref_id=invoice_id,
                 )
                 await db.commit()
-                logger.info("Credits granted: user_id=%s, credits=%d, payment_intent=%s",
-                           user_id, credits, payment_intent)
             except Exception as e:
                 await db.rollback()
-                logger.error("Failed to grant credits: %s", e)
-                # Return 5xx so Stripe retries
+                logger.error("Failed to grant monthly credits on invoice: %s", e)
                 raise HTTPException(500, "Database error")
+        return {"received": True}
+
+    elif event["type"] == "customer.subscription.deleted":
+        obj = event.get("data", {}).get("object")
+        if not obj or not isinstance(obj, dict):
+            return {"received": True}
 
-    return {"received": True}
+        customer_id = obj.get("customer")
+        if not customer_id:
+            return {"received": True}
 
+        user = await db.scalar(select(User).where(User.stripe_customer_id == customer_id))
+        if not user:
+            return {"received": True}
+
+        user.plan = "free"
+        user.stripe_subscription_id = None
+        await db.commit()
+        return {"received": True}
+
+    return {"received": True}
diff --git a/backend/app/api/chat.py b/backend/app/api/chat.py
index 71fc751fa90239dfe90bf76e3b30a7aa686d0c3f..d52dc47026e109df283984196581d417a4fea1dc
--- a/backend/app/api/chat.py
+++ b/backend/app/api/chat.py
@@ -133,6 +133,9 @@
 
     # If authenticated, ensure sufficient credits before opening stream
     if user is not None:
+        from app.services.credit_service import ensure_monthly_credits
+        await ensure_monthly_credits(db, user)
+        await db.commit()
         balance = await credit_service.get_user_credits(db, user.id)
         if balance < credit_service.MIN_CREDITS_FOR_CHAT:
             return JSONResponse(
diff --git a/backend/app/core/config.py b/backend/app/core/config.py
index 830f599a7b1ff02463684a9e84e90adfd6318cc1..a8eef6c5b4145c3710d46395bf26465dec42b4a7
--- a/backend/app/core/config.py
+++ b/backend/app/core/config.py
@@ -75,6 +75,10 @@
     CREDITS_PRO: int = 200000
     CREDITS_ENTERPRISE: int = 1000000
     SIGNUP_BONUS_CREDITS: int = 10000
+    # Subscription tiers
+    PLAN_FREE_MONTHLY_CREDITS: int = 10000
+    PLAN_PRO_MONTHLY_CREDITS: int = 100000
+    STRIPE_PRICE_PRO_MONTHLY: str = ''
 
     model_config = SettingsConfigDict(env_file=".env", env_file_encoding="utf-8", case_sensitive=False)
 
diff --git a/backend/app/models/tables.py b/backend/app/models/tables.py
index 2eb9239abb3f01f8a4103944db02efcb27f20149..9caeafd2d73fb05604695d962f9a0dc191da0bf2
--- a/backend/app/models/tables.py
+++ b/backend/app/models/tables.py
@@ -163,6 +163,10 @@
     email_verified: Mapped[Optional[datetime]] = mapped_column(sa.DateTime(timezone=True))
     credits_balance: Mapped[int] = mapped_column(sa.Integer, nullable=False, server_default=sa.text("0"))
     signup_bonus_granted_at: Mapped[Optional[datetime]] = mapped_column(sa.DateTime(timezone=True))
+    plan: Mapped[str] = mapped_column(sa.String(20), nullable=False, server_default=sa.text("'free'"))
+    stripe_customer_id: Mapped[Optional[str]] = mapped_column(sa.String(255))
+    stripe_subscription_id: Mapped[Optional[str]] = mapped_column(sa.String(255))
+    monthly_credits_granted_at: Mapped[Optional[datetime]] = mapped_column(sa.DateTime(timezone=True))
     created_at: Mapped[datetime] = mapped_column(sa.DateTime(timezone=True), server_default=sa.text("now()"))
     updated_at: Mapped[datetime] = mapped_column(
         sa.DateTime(timezone=True), server_default=sa.text("now()"), onupdate=sa.func.now()
diff --git a/backend/app/services/auth_service.py b/backend/app/services/auth_service.py
index cc72086b50ebd5497e7cdada96a60506fa7d9c05..6b57ee07cdff8f392a533172f8e7507a3e131cc4
--- a/backend/app/services/auth_service.py
+++ b/backend/app/services/auth_service.py
@@ -52,6 +52,7 @@
         email_verified=email_verified,
         credits_balance=SIGNUP_BONUS_CREDITS,
         signup_bonus_granted_at=datetime.utcnow(),
+        monthly_credits_granted_at=datetime.utcnow(),
     )
     db.add(user)
 
@@ -179,4 +180,3 @@
     await db.delete(vt)
     await db.commit()
     return vt
-
diff --git a/backend/app/services/credit_service.py b/backend/app/services/credit_service.py
index d89772b0418d1ebe1a79bba3de65f0112a550adb..55fa0e1abd98fa8c3f32c2aa71826235df6a9fc3
--- a/backend/app/services/credit_service.py
+++ b/backend/app/services/credit_service.py
@@ -7,6 +7,7 @@
 from sqlalchemy.ext.asyncio import AsyncSession
 
 from app.models.tables import CreditLedger, UsageRecord, User
+from app.core.config import settings
 
 
 # Token-to-credit rates by model tier
@@ -144,3 +145,59 @@
     db.add(usage)
     return usage
 
+
+async def ensure_monthly_credits(db: AsyncSession, user: User) -> None:
+    """Grant monthly credits if last grant was over 30 days ago.
+
+    Idempotency: checks CreditLedger for any recent 'monthly_allowance' within 30 days.
+    """
+    from datetime import datetime, timedelta, timezone
+
+    # Determine if grant needed based on timestamp
+    now = datetime.now(timezone.utc)
+    last = user.monthly_credits_granted_at
+    if last is not None and last.tzinfo is None:
+        # Treat naive as UTC
+        last = last.replace(tzinfo=timezone.utc)
+    needs_grant = last is None or (now - last) >= timedelta(days=30)
+    if not needs_grant:
+        return
+
+    # Check ledger for idempotency within last 30 days
+    cutoff = now - timedelta(days=30)
+    existing = await db.scalar(
+        sa.select(CreditLedger)
+        .where(CreditLedger.user_id == user.id)
+        .where(CreditLedger.reason == "monthly_allowance")
+        .where(CreditLedger.created_at >= cutoff)
+    )
+    if existing:
+        # Still update marker to avoid repeatedly checking in future requests
+        user.monthly_credits_granted_at = now
+        await db.flush()
+        return
+
+    # Determine allowance by plan
+    plan = (user.plan or "free").lower()
+    if plan == "pro":
+        allowance = int(settings.PLAN_PRO_MONTHLY_CREDITS or 0)
+    else:
+        allowance = int(settings.PLAN_FREE_MONTHLY_CREDITS or 0)
+
+    if allowance <= 0:
+        # Nothing to grant
+        user.monthly_credits_granted_at = now
+        await db.flush()
+        return
+
+    # Grant credits and update marker
+    await credit_credits(
+        db,
+        user_id=user.id,
+        amount=allowance,
+        reason="monthly_allowance",
+        ref_type=None,
+        ref_id=None,
+    )
+    user.monthly_credits_granted_at = now
+    await db.flush()


thinking
**Checking service implementation**

It looks like I'm diving into the function 'auth_service.create_user,' which sets monthly_credits_granted_at as naive. I'll need to decide about making it timezone aware to prevent future confusion, but since the instruction says to use datetime.utcnow() for it, we must stick to that. So, only adjustments can happen in ensure_monthly_credits. I also need to verify that the 'subscribe' function returns the 'checkout_url' as required and confirm the proper imports in 'billing.py.' Additionally, I should check if 'stripe' is included in the requirements.
exec
bash -lc "sed -n '1,200p' backend/requirements.txt" in /Users/mayijie/Projects/Code/010_DocTalk succeeded in 15ms:
fastapi
uvicorn
sqlalchemy
alembic
asyncpg
celery
redis
pymupdf
minio
qdrant-client
openai
python-multipart
pydantic-settings
email-validator
python-jose[cryptography]
itsdangerous
stripe

file update:
diff --git a/backend/alembic/versions/20260206_0004_add_subscription_fields.py b/backend/alembic/versions/20260206_0004_add_subscription_fields.py
new file mode 100644
index 0000000000000000000000000000000000000000..f84be09226785ea3dbc1b413b3cfd2cb07dff81e
--- /dev/null
+++ b/backend/alembic/versions/20260206_0004_add_subscription_fields.py
@@ -0,0 +1,38 @@
+"""add subscription fields to users
+
+Revision ID: d4e5f6a7b8c9
+Revises: c3d4e5f6a7b8
+Create Date: 2026-02-06 00:40:00
+
+"""
+from __future__ import annotations
+
+from alembic import op
+import sqlalchemy as sa
+
+
+# revision identifiers, used by Alembic.
+revision = "d4e5f6a7b8c9"
+down_revision = "c3d4e5f6a7b8"
+branch_labels = None
+depends_on = None
+
+
+def upgrade() -> None:
+    # Add subscription-related columns to users
+    op.add_column(
+        "users",
+        sa.Column("plan", sa.String(length=20), nullable=False, server_default=sa.text("'free'")),
+    )
+    op.add_column("users", sa.Column("stripe_customer_id", sa.String(length=255), nullable=True))
+    op.add_column("users", sa.Column("stripe_subscription_id", sa.String(length=255), nullable=True))
+    op.add_column("users", sa.Column("monthly_credits_granted_at", sa.DateTime(timezone=True), nullable=True))
+
+
+def downgrade() -> None:
+    # Drop subscription-related columns from users
+    op.drop_column("users", "monthly_credits_granted_at")
+    op.drop_column("users", "stripe_subscription_id")
+    op.drop_column("users", "stripe_customer_id")
+    op.drop_column("users", "plan")
+
diff --git a/backend/app/api/billing.py b/backend/app/api/billing.py
index 851620df69f9c62fb3cab15feeedcafff44cc6bb..f99355cf848497a82c150ed57c5c5b2c20aa5e2e
--- a/backend/app/api/billing.py
+++ b/backend/app/api/billing.py
@@ -58,6 +58,47 @@
     return {"checkout_url": session.url}
 
 
+# Subscriptions
+@router.post("/subscribe")
+async def subscribe(
+    user: User = Depends(require_auth),
+    db: AsyncSession = Depends(get_db_session),
+):
+    if not settings.STRIPE_SECRET_KEY or not settings.STRIPE_PRICE_PRO_MONTHLY:
+        raise HTTPException(503, "Stripe not configured")
+
+    # Ensure customer exists
+    if not user.stripe_customer_id:
+        cust = stripe.Customer.create(email=user.email, name=user.name or None)
+        user.stripe_customer_id = cust.id
+        await db.commit()
+
+    # Create Checkout Session for subscription
+    session = stripe.checkout.Session.create(
+        mode="subscription",
+        line_items=[{"price": settings.STRIPE_PRICE_PRO_MONTHLY, "quantity": 1}],
+        success_url=f"{settings.FRONTEND_URL}/billing",
+        cancel_url=f"{settings.FRONTEND_URL}/billing",
+        customer=user.stripe_customer_id,
+        client_reference_id=str(user.id),
+    )
+    return {"checkout_url": session.url}
+
+
+@router.post("/portal")
+async def customer_portal(user: User = Depends(require_auth)):
+    if not settings.STRIPE_SECRET_KEY:
+        raise HTTPException(503, "Stripe not configured")
+    if not user.stripe_customer_id:
+        raise HTTPException(400, "No Stripe customer for user")
+
+    portal = stripe.billing_portal.Session.create(
+        customer=user.stripe_customer_id,
+        return_url=f"{settings.FRONTEND_URL}/billing",
+    )
+    return {"portal_url": portal.url}
+
+
 @router.post("/webhook")
 async def stripe_webhook(request: Request, db: AsyncSession = Depends(get_db_session)):
     payload = await request.body()
@@ -85,70 +126,196 @@
             logger.error("Invalid event structure: missing data.object")
             return {"received": True}
 
-        # Parse and validate client_reference_id (user_id)
-        try:
-            client_ref = session.get("client_reference_id")
-            if not client_ref:
-                logger.error("Missing client_reference_id in checkout session")
+        mode = session.get("mode")
+
+        # Handle subscription checkout
+        if mode == "subscription":
+            try:
+                client_ref = session.get("client_reference_id")
+                if not client_ref:
+                    logger.error("Missing client_reference_id in subscription session")
+                    return {"received": True}
+                user_id = uuid.UUID(client_ref)
+            except (ValueError, TypeError) as e:
+                logger.error("Invalid client_reference_id: %s", e)
+                return {"received": True}
+
+            user = await db.get(User, user_id)
+            if not user:
+                logger.warning("Subscription completed for non-existent user %s", user_id)
                 return {"received": True}
-            user_id = uuid.UUID(client_ref)
-        except (ValueError, TypeError) as e:
-            logger.error("Invalid client_reference_id: %s", e)
+
+            subscription_id = session.get("subscription")
+            customer_id = session.get("customer")
+
+            # Update user plan and subscription/customer ids
+            user.plan = "pro"
+            if subscription_id:
+                user.stripe_subscription_id = subscription_id
+            if customer_id and not user.stripe_customer_id:
+                user.stripe_customer_id = customer_id
+
+            # Idempotency: only one monthly grant per subscription id at start
+            existing = await db.scalar(
+                select(CreditLedger).where(
+                    CreditLedger.ref_type == "stripe_subscription",
+                    CreditLedger.ref_id == (subscription_id or ""),
+                )
+            )
+
+            if not existing:
+                try:
+                    await credit_credits(
+                        db,
+                        user_id=user.id,
+                        amount=int(settings.PLAN_PRO_MONTHLY_CREDITS or 0),
+                        reason="monthly_allowance",
+                        ref_type="stripe_subscription",
+                        ref_id=subscription_id or "",
+                    )
+                    await db.commit()
+                    logger.info(
+                        "Subscription start credits granted: user_id=%s, subscription=%s",
+                        user.id,
+                        subscription_id,
+                    )
+                except Exception as e:
+                    await db.rollback()
+                    logger.error("Failed to grant subscription start credits: %s", e)
+                    raise HTTPException(500, "Database error")
+            else:
+                await db.commit()
+
             return {"received": True}
 
-        # Parse and validate credits amount
-        try:
-            metadata = session.get("metadata", {})
-            credits_str = metadata.get("credits")
-            if not credits_str:
-                logger.error("Missing credits in session metadata")
+        # Handle one-time credit pack checkout
+        if mode == "payment":
+            # Parse and validate client_reference_id (user_id)
+            try:
+                client_ref = session.get("client_reference_id")
+                if not client_ref:
+                    logger.error("Missing client_reference_id in checkout session")
+                    return {"received": True}
+                user_id = uuid.UUID(client_ref)
+            except (ValueError, TypeError) as e:
+                logger.error("Invalid client_reference_id: %s", e)
                 return {"received": True}
-            credits = int(credits_str)
-            if credits <= 0:
-                logger.error("Invalid credits amount: %d", credits)
+
+            # Parse and validate credits amount
+            try:
+                metadata = session.get("metadata", {})
+                credits_str = metadata.get("credits")
+                if not credits_str:
+                    logger.error("Missing credits in session metadata")
+                    return {"received": True}
+                credits = int(credits_str)
+                if credits <= 0:
+                    logger.error("Invalid credits amount: %d", credits)
+                    return {"received": True}
+            except (ValueError, TypeError) as e:
+                logger.error("Cannot parse credits from metadata: %s", e)
+                return {"received": True}
+
+            # Get payment_intent for idempotency
+            payment_intent = session.get("payment_intent")
+            if not payment_intent:
+                logger.warning("Checkout session has no payment_intent, skipping for safety")
                 return {"received": True}
-        except (ValueError, TypeError) as e:
-            logger.error("Cannot parse credits from metadata: %s", e)
+
+            # Verify user exists
+            user = await db.get(User, user_id)
+            if not user:
+                logger.warning("Webhook for non-existent user %s", user_id)
+                return {"received": True}
+
+            # Idempotency check
+            existing = await db.scalar(
+                select(CreditLedger).where(
+                    CreditLedger.ref_type == "stripe_payment",
+                    CreditLedger.ref_id == payment_intent,
+                )
+            )
+
+            if not existing:
+                try:
+                    await credit_credits(
+                        db,
+                        user_id,
+                        credits,
+                        reason="purchase",
+                        ref_type="stripe_payment",
+                        ref_id=payment_intent,
+                    )
+                    await db.commit()
+                    logger.info(
+                        "Credits granted: user_id=%s, credits=%d, payment_intent=%s",
+                        user_id,
+                        credits,
+                        payment_intent,
+                    )
+                except Exception as e:
+                    await db.rollback()
+                    logger.error("Failed to grant credits: %s", e)
+                    # Return 5xx so Stripe retries
+                    raise HTTPException(500, "Database error")
+            return {"received": True}
+
+    elif event["type"] == "invoice.payment_succeeded":
+    
+        obj = event.get("data", {}).get("object")
+        if not obj or not isinstance(obj, dict):
             return {"received": True}
 
-        # Get payment_intent for idempotency
-        payment_intent = session.get("payment_intent")
-        if not payment_intent:
-            logger.warning("Checkout session has no payment_intent, skipping for safety")
+        invoice_id = obj.get("id")
+        customer_id = obj.get("customer")
+        if not invoice_id or not customer_id:
             return {"received": True}
 
-        # Verify user exists
-        user = await db.get(User, user_id)
+        # Find user by customer id
+        user = await db.scalar(select(User).where(User.stripe_customer_id == customer_id))
         if not user:
-            logger.warning("Webhook for non-existent user %s", user_id)
             return {"received": True}
 
-        # Idempotency check
+        # Idempotency: ensure we haven't granted for this invoice
         existing = await db.scalar(
             select(CreditLedger).where(
-                CreditLedger.ref_type == "stripe_payment",
-                CreditLedger.ref_id == payment_intent,
+                CreditLedger.ref_type == "stripe_invoice",
+                CreditLedger.ref_id == invoice_id,
             )
         )
-
         if not existing:
             try:
                 await credit_credits(
                     db,
-                    user_id,
-                    credits,
-                    reason="purchase",
-                    ref_type="stripe_payment",
-                    ref_id=payment_intent,
+                    user_id=user.id,
+                    amount=int(settings.PLAN_PRO_MONTHLY_CREDITS or 0),
+                    reason="monthly_allowance",
+                    ref_type="stripe_invoice",
+                    ref_id=invoice_id,
                 )
                 await db.commit()
-                logger.info("Credits granted: user_id=%s, credits=%d, payment_intent=%s",
-                           user_id, credits, payment_intent)
             except Exception as e:
                 await db.rollback()
-                logger.error("Failed to grant credits: %s", e)
-                # Return 5xx so Stripe retries
+                logger.error("Failed to grant monthly credits on invoice: %s", e)
                 raise HTTPException(500, "Database error")
+        return {"received": True}
+
+    elif event["type"] == "customer.subscription.deleted":
+        obj = event.get("data", {}).get("object")
+        if not obj or not isinstance(obj, dict):
+            return {"received": True}
 
-    return {"received": True}
+        customer_id = obj.get("customer")
+        if not customer_id:
+            return {"received": True}
 
+        user = await db.scalar(select(User).where(User.stripe_customer_id == customer_id))
+        if not user:
+            return {"received": True}
+
+        user.plan = "free"
+        user.stripe_subscription_id = None
+        await db.commit()
+        return {"received": True}
+
+    return {"received": True}
diff --git a/backend/app/api/chat.py b/backend/app/api/chat.py
index 71fc751fa90239dfe90bf76e3b30a7aa686d0c3f..d52dc47026e109df283984196581d417a4fea1dc
--- a/backend/app/api/chat.py
+++ b/backend/app/api/chat.py
@@ -133,6 +133,9 @@
 
     # If authenticated, ensure sufficient credits before opening stream
     if user is not None:
+        from app.services.credit_service import ensure_monthly_credits
+        await ensure_monthly_credits(db, user)
+        await db.commit()
         balance = await credit_service.get_user_credits(db, user.id)
         if balance < credit_service.MIN_CREDITS_FOR_CHAT:
             return JSONResponse(
diff --git a/backend/app/core/config.py b/backend/app/core/config.py
index 830f599a7b1ff02463684a9e84e90adfd6318cc1..a8eef6c5b4145c3710d46395bf26465dec42b4a7
--- a/backend/app/core/config.py
+++ b/backend/app/core/config.py
@@ -75,6 +75,10 @@
     CREDITS_PRO: int = 200000
     CREDITS_ENTERPRISE: int = 1000000
     SIGNUP_BONUS_CREDITS: int = 10000
+    # Subscription tiers
+    PLAN_FREE_MONTHLY_CREDITS: int = 10000
+    PLAN_PRO_MONTHLY_CREDITS: int = 100000
+    STRIPE_PRICE_PRO_MONTHLY: str = ''
 
     model_config = SettingsConfigDict(env_file=".env", env_file_encoding="utf-8", case_sensitive=False)
 
diff --git a/backend/app/models/tables.py b/backend/app/models/tables.py
index 2eb9239abb3f01f8a4103944db02efcb27f20149..9caeafd2d73fb05604695d962f9a0dc191da0bf2
--- a/backend/app/models/tables.py
+++ b/backend/app/models/tables.py
@@ -163,6 +163,10 @@
     email_verified: Mapped[Optional[datetime]] = mapped_column(sa.DateTime(timezone=True))
     credits_balance: Mapped[int] = mapped_column(sa.Integer, nullable=False, server_default=sa.text("0"))
     signup_bonus_granted_at: Mapped[Optional[datetime]] = mapped_column(sa.DateTime(timezone=True))
+    plan: Mapped[str] = mapped_column(sa.String(20), nullable=False, server_default=sa.text("'free'"))
+    stripe_customer_id: Mapped[Optional[str]] = mapped_column(sa.String(255))
+    stripe_subscription_id: Mapped[Optional[str]] = mapped_column(sa.String(255))
+    monthly_credits_granted_at: Mapped[Optional[datetime]] = mapped_column(sa.DateTime(timezone=True))
     created_at: Mapped[datetime] = mapped_column(sa.DateTime(timezone=True), server_default=sa.text("now()"))
     updated_at: Mapped[datetime] = mapped_column(
         sa.DateTime(timezone=True), server_default=sa.text("now()"), onupdate=sa.func.now()
diff --git a/backend/app/services/auth_service.py b/backend/app/services/auth_service.py
index cc72086b50ebd5497e7cdada96a60506fa7d9c05..6b57ee07cdff8f392a533172f8e7507a3e131cc4
--- a/backend/app/services/auth_service.py
+++ b/backend/app/services/auth_service.py
@@ -52,6 +52,7 @@
         email_verified=email_verified,
         credits_balance=SIGNUP_BONUS_CREDITS,
         signup_bonus_granted_at=datetime.utcnow(),
+        monthly_credits_granted_at=datetime.utcnow(),
     )
     db.add(user)
 
@@ -179,4 +180,3 @@
     await db.delete(vt)
     await db.commit()
     return vt
-
diff --git a/backend/app/services/credit_service.py b/backend/app/services/credit_service.py
index d89772b0418d1ebe1a79bba3de65f0112a550adb..55fa0e1abd98fa8c3f32c2aa71826235df6a9fc3
--- a/backend/app/services/credit_service.py
+++ b/backend/app/services/credit_service.py
@@ -7,6 +7,7 @@
 from sqlalchemy.ext.asyncio import AsyncSession
 
 from app.models.tables import CreditLedger, UsageRecord, User
+from app.core.config import settings
 
 
 # Token-to-credit rates by model tier
@@ -144,3 +145,59 @@
     db.add(usage)
     return usage
 
+
+async def ensure_monthly_credits(db: AsyncSession, user: User) -> None:
+    """Grant monthly credits if last grant was over 30 days ago.
+
+    Idempotency: checks CreditLedger for any recent 'monthly_allowance' within 30 days.
+    """
+    from datetime import datetime, timedelta, timezone
+
+    # Determine if grant needed based on timestamp
+    now = datetime.now(timezone.utc)
+    last = user.monthly_credits_granted_at
+    if last is not None and last.tzinfo is None:
+        # Treat naive as UTC
+        last = last.replace(tzinfo=timezone.utc)
+    needs_grant = last is None or (now - last) >= timedelta(days=30)
+    if not needs_grant:
+        return
+
+    # Check ledger for idempotency within last 30 days
+    cutoff = now - timedelta(days=30)
+    existing = await db.scalar(
+        sa.select(CreditLedger)
+        .where(CreditLedger.user_id == user.id)
+        .where(CreditLedger.reason == "monthly_allowance")
+        .where(CreditLedger.created_at >= cutoff)
+    )
+    if existing:
+        # Still update marker to avoid repeatedly checking in future requests
+        user.monthly_credits_granted_at = now
+        await db.flush()
+        return
+
+    # Determine allowance by plan
+    plan = (user.plan or "free").lower()
+    if plan == "pro":
+        allowance = int(settings.PLAN_PRO_MONTHLY_CREDITS or 0)
+    else:
+        allowance = int(settings.PLAN_FREE_MONTHLY_CREDITS or 0)
+
+    if allowance <= 0:
+        # Nothing to grant
+        user.monthly_credits_granted_at = now
+        await db.flush()
+        return
+
+    # Grant credits and update marker
+    await credit_credits(
+        db,
+        user_id=user.id,
+        amount=allowance,
+        reason="monthly_allowance",
+        ref_type=None,
+        ref_id=None,
+    )
+    user.monthly_credits_granted_at = now
+    await db.flush()

exec
bash -lc 'pytest -q' in /Users/mayijie/Projects/Code/010_DocTalk exited 127 in 19ms:
bash: pytest: command not found
file update:
diff --git a/backend/alembic/versions/20260206_0004_add_subscription_fields.py b/backend/alembic/versions/20260206_0004_add_subscription_fields.py
new file mode 100644
index 0000000000000000000000000000000000000000..f84be09226785ea3dbc1b413b3cfd2cb07dff81e
--- /dev/null
+++ b/backend/alembic/versions/20260206_0004_add_subscription_fields.py
@@ -0,0 +1,38 @@
+"""add subscription fields to users
+
+Revision ID: d4e5f6a7b8c9
+Revises: c3d4e5f6a7b8
+Create Date: 2026-02-06 00:40:00
+
+"""
+from __future__ import annotations
+
+from alembic import op
+import sqlalchemy as sa
+
+
+# revision identifiers, used by Alembic.
+revision = "d4e5f6a7b8c9"
+down_revision = "c3d4e5f6a7b8"
+branch_labels = None
+depends_on = None
+
+
+def upgrade() -> None:
+    # Add subscription-related columns to users
+    op.add_column(
+        "users",
+        sa.Column("plan", sa.String(length=20), nullable=False, server_default=sa.text("'free'")),
+    )
+    op.add_column("users", sa.Column("stripe_customer_id", sa.String(length=255), nullable=True))
+    op.add_column("users", sa.Column("stripe_subscription_id", sa.String(length=255), nullable=True))
+    op.add_column("users", sa.Column("monthly_credits_granted_at", sa.DateTime(timezone=True), nullable=True))
+
+
+def downgrade() -> None:
+    # Drop subscription-related columns from users
+    op.drop_column("users", "monthly_credits_granted_at")
+    op.drop_column("users", "stripe_subscription_id")
+    op.drop_column("users", "stripe_customer_id")
+    op.drop_column("users", "plan")
+
diff --git a/backend/app/api/billing.py b/backend/app/api/billing.py
index 851620df69f9c62fb3cab15feeedcafff44cc6bb..f99355cf848497a82c150ed57c5c5b2c20aa5e2e
--- a/backend/app/api/billing.py
+++ b/backend/app/api/billing.py
@@ -58,6 +58,47 @@
     return {"checkout_url": session.url}
 
 
+# Subscriptions
+@router.post("/subscribe")
+async def subscribe(
+    user: User = Depends(require_auth),
+    db: AsyncSession = Depends(get_db_session),
+):
+    if not settings.STRIPE_SECRET_KEY or not settings.STRIPE_PRICE_PRO_MONTHLY:
+        raise HTTPException(503, "Stripe not configured")
+
+    # Ensure customer exists
+    if not user.stripe_customer_id:
+        cust = stripe.Customer.create(email=user.email, name=user.name or None)
+        user.stripe_customer_id = cust.id
+        await db.commit()
+
+    # Create Checkout Session for subscription
+    session = stripe.checkout.Session.create(
+        mode="subscription",
+        line_items=[{"price": settings.STRIPE_PRICE_PRO_MONTHLY, "quantity": 1}],
+        success_url=f"{settings.FRONTEND_URL}/billing",
+        cancel_url=f"{settings.FRONTEND_URL}/billing",
+        customer=user.stripe_customer_id,
+        client_reference_id=str(user.id),
+    )
+    return {"checkout_url": session.url}
+
+
+@router.post("/portal")
+async def customer_portal(user: User = Depends(require_auth)):
+    if not settings.STRIPE_SECRET_KEY:
+        raise HTTPException(503, "Stripe not configured")
+    if not user.stripe_customer_id:
+        raise HTTPException(400, "No Stripe customer for user")
+
+    portal = stripe.billing_portal.Session.create(
+        customer=user.stripe_customer_id,
+        return_url=f"{settings.FRONTEND_URL}/billing",
+    )
+    return {"portal_url": portal.url}
+
+
 @router.post("/webhook")
 async def stripe_webhook(request: Request, db: AsyncSession = Depends(get_db_session)):
     payload = await request.body()
@@ -85,70 +126,196 @@
             logger.error("Invalid event structure: missing data.object")
             return {"received": True}
 
-        # Parse and validate client_reference_id (user_id)
-        try:
-            client_ref = session.get("client_reference_id")
-            if not client_ref:
-                logger.error("Missing client_reference_id in checkout session")
+        mode = session.get("mode")
+
+        # Handle subscription checkout
+        if mode == "subscription":
+            try:
+                client_ref = session.get("client_reference_id")
+                if not client_ref:
+                    logger.error("Missing client_reference_id in subscription session")
+                    return {"received": True}
+                user_id = uuid.UUID(client_ref)
+            except (ValueError, TypeError) as e:
+                logger.error("Invalid client_reference_id: %s", e)
+                return {"received": True}
+
+            user = await db.get(User, user_id)
+            if not user:
+                logger.warning("Subscription completed for non-existent user %s", user_id)
                 return {"received": True}
-            user_id = uuid.UUID(client_ref)
-        except (ValueError, TypeError) as e:
-            logger.error("Invalid client_reference_id: %s", e)
+
+            subscription_id = session.get("subscription")
+            customer_id = session.get("customer")
+
+            # Update user plan and subscription/customer ids
+            user.plan = "pro"
+            if subscription_id:
+                user.stripe_subscription_id = subscription_id
+            if customer_id and not user.stripe_customer_id:
+                user.stripe_customer_id = customer_id
+
+            # Idempotency: only one monthly grant per subscription id at start
+            existing = await db.scalar(
+                select(CreditLedger).where(
+                    CreditLedger.ref_type == "stripe_subscription",
+                    CreditLedger.ref_id == (subscription_id or ""),
+                )
+            )
+
+            if not existing:
+                try:
+                    await credit_credits(
+                        db,
+                        user_id=user.id,
+                        amount=int(settings.PLAN_PRO_MONTHLY_CREDITS or 0),
+                        reason="monthly_allowance",
+                        ref_type="stripe_subscription",
+                        ref_id=subscription_id or "",
+                    )
+                    await db.commit()
+                    logger.info(
+                        "Subscription start credits granted: user_id=%s, subscription=%s",
+                        user.id,
+                        subscription_id,
+                    )
+                except Exception as e:
+                    await db.rollback()
+                    logger.error("Failed to grant subscription start credits: %s", e)
+                    raise HTTPException(500, "Database error")
+            else:
+                await db.commit()
+
             return {"received": True}
 
-        # Parse and validate credits amount
-        try:
-            metadata = session.get("metadata", {})
-            credits_str = metadata.get("credits")
-            if not credits_str:
-                logger.error("Missing credits in session metadata")
+        # Handle one-time credit pack checkout
+        if mode == "payment":
+            # Parse and validate client_reference_id (user_id)
+            try:
+                client_ref = session.get("client_reference_id")
+                if not client_ref:
+                    logger.error("Missing client_reference_id in checkout session")
+                    return {"received": True}
+                user_id = uuid.UUID(client_ref)
+            except (ValueError, TypeError) as e:
+                logger.error("Invalid client_reference_id: %s", e)
                 return {"received": True}
-            credits = int(credits_str)
-            if credits <= 0:
-                logger.error("Invalid credits amount: %d", credits)
+
+            # Parse and validate credits amount
+            try:
+                metadata = session.get("metadata", {})
+                credits_str = metadata.get("credits")
+                if not credits_str:
+                    logger.error("Missing credits in session metadata")
+                    return {"received": True}
+                credits = int(credits_str)
+                if credits <= 0:
+                    logger.error("Invalid credits amount: %d", credits)
+                    return {"received": True}
+            except (ValueError, TypeError) as e:
+                logger.error("Cannot parse credits from metadata: %s", e)
+                return {"received": True}
+
+            # Get payment_intent for idempotency
+            payment_intent = session.get("payment_intent")
+            if not payment_intent:
+                logger.warning("Checkout session has no payment_intent, skipping for safety")
                 return {"received": True}
-        except (ValueError, TypeError) as e:
-            logger.error("Cannot parse credits from metadata: %s", e)
+
+            # Verify user exists
+            user = await db.get(User, user_id)
+            if not user:
+                logger.warning("Webhook for non-existent user %s", user_id)
+                return {"received": True}
+
+            # Idempotency check
+            existing = await db.scalar(
+                select(CreditLedger).where(
+                    CreditLedger.ref_type == "stripe_payment",
+                    CreditLedger.ref_id == payment_intent,
+                )
+            )
+
+            if not existing:
+                try:
+                    await credit_credits(
+                        db,
+                        user_id,
+                        credits,
+                        reason="purchase",
+                        ref_type="stripe_payment",
+                        ref_id=payment_intent,
+                    )
+                    await db.commit()
+                    logger.info(
+                        "Credits granted: user_id=%s, credits=%d, payment_intent=%s",
+                        user_id,
+                        credits,
+                        payment_intent,
+                    )
+                except Exception as e:
+                    await db.rollback()
+                    logger.error("Failed to grant credits: %s", e)
+                    # Return 5xx so Stripe retries
+                    raise HTTPException(500, "Database error")
+            return {"received": True}
+
+    elif event["type"] == "invoice.payment_succeeded":
+    
+        obj = event.get("data", {}).get("object")
+        if not obj or not isinstance(obj, dict):
             return {"received": True}
 
-        # Get payment_intent for idempotency
-        payment_intent = session.get("payment_intent")
-        if not payment_intent:
-            logger.warning("Checkout session has no payment_intent, skipping for safety")
+        invoice_id = obj.get("id")
+        customer_id = obj.get("customer")
+        if not invoice_id or not customer_id:
             return {"received": True}
 
-        # Verify user exists
-        user = await db.get(User, user_id)
+        # Find user by customer id
+        user = await db.scalar(select(User).where(User.stripe_customer_id == customer_id))
         if not user:
-            logger.warning("Webhook for non-existent user %s", user_id)
             return {"received": True}
 
-        # Idempotency check
+        # Idempotency: ensure we haven't granted for this invoice
         existing = await db.scalar(
             select(CreditLedger).where(
-                CreditLedger.ref_type == "stripe_payment",
-                CreditLedger.ref_id == payment_intent,
+                CreditLedger.ref_type == "stripe_invoice",
+                CreditLedger.ref_id == invoice_id,
             )
         )
-
         if not existing:
             try:
                 await credit_credits(
                     db,
-                    user_id,
-                    credits,
-                    reason="purchase",
-                    ref_type="stripe_payment",
-                    ref_id=payment_intent,
+                    user_id=user.id,
+                    amount=int(settings.PLAN_PRO_MONTHLY_CREDITS or 0),
+                    reason="monthly_allowance",
+                    ref_type="stripe_invoice",
+                    ref_id=invoice_id,
                 )
                 await db.commit()
-                logger.info("Credits granted: user_id=%s, credits=%d, payment_intent=%s",
-                           user_id, credits, payment_intent)
             except Exception as e:
                 await db.rollback()
-                logger.error("Failed to grant credits: %s", e)
-                # Return 5xx so Stripe retries
+                logger.error("Failed to grant monthly credits on invoice: %s", e)
                 raise HTTPException(500, "Database error")
+        return {"received": True}
+
+    elif event["type"] == "customer.subscription.deleted":
+        obj = event.get("data", {}).get("object")
+        if not obj or not isinstance(obj, dict):
+            return {"received": True}
 
-    return {"received": True}
+        customer_id = obj.get("customer")
+        if not customer_id:
+            return {"received": True}
 
+        user = await db.scalar(select(User).where(User.stripe_customer_id == customer_id))
+        if not user:
+            return {"received": True}
+
+        user.plan = "free"
+        user.stripe_subscription_id = None
+        await db.commit()
+        return {"received": True}
+
+    return {"received": True}
diff --git a/backend/app/api/chat.py b/backend/app/api/chat.py
index 71fc751fa90239dfe90bf76e3b30a7aa686d0c3f..d52dc47026e109df283984196581d417a4fea1dc
--- a/backend/app/api/chat.py
+++ b/backend/app/api/chat.py
@@ -133,6 +133,9 @@
 
     # If authenticated, ensure sufficient credits before opening stream
     if user is not None:
+        from app.services.credit_service import ensure_monthly_credits
+        await ensure_monthly_credits(db, user)
+        await db.commit()
         balance = await credit_service.get_user_credits(db, user.id)
         if balance < credit_service.MIN_CREDITS_FOR_CHAT:
             return JSONResponse(
diff --git a/backend/app/core/config.py b/backend/app/core/config.py
index 830f599a7b1ff02463684a9e84e90adfd6318cc1..a8eef6c5b4145c3710d46395bf26465dec42b4a7
--- a/backend/app/core/config.py
+++ b/backend/app/core/config.py
@@ -75,6 +75,10 @@
     CREDITS_PRO: int = 200000
     CREDITS_ENTERPRISE: int = 1000000
     SIGNUP_BONUS_CREDITS: int = 10000
+    # Subscription tiers
+    PLAN_FREE_MONTHLY_CREDITS: int = 10000
+    PLAN_PRO_MONTHLY_CREDITS: int = 100000
+    STRIPE_PRICE_PRO_MONTHLY: str = ''
 
     model_config = SettingsConfigDict(env_file=".env", env_file_encoding="utf-8", case_sensitive=False)
 
diff --git a/backend/app/models/tables.py b/backend/app/models/tables.py
index 2eb9239abb3f01f8a4103944db02efcb27f20149..9caeafd2d73fb05604695d962f9a0dc191da0bf2
--- a/backend/app/models/tables.py
+++ b/backend/app/models/tables.py
@@ -163,6 +163,10 @@
     email_verified: Mapped[Optional[datetime]] = mapped_column(sa.DateTime(timezone=True))
     credits_balance: Mapped[int] = mapped_column(sa.Integer, nullable=False, server_default=sa.text("0"))
     signup_bonus_granted_at: Mapped[Optional[datetime]] = mapped_column(sa.DateTime(timezone=True))
+    plan: Mapped[str] = mapped_column(sa.String(20), nullable=False, server_default=sa.text("'free'"))
+    stripe_customer_id: Mapped[Optional[str]] = mapped_column(sa.String(255))
+    stripe_subscription_id: Mapped[Optional[str]] = mapped_column(sa.String(255))
+    monthly_credits_granted_at: Mapped[Optional[datetime]] = mapped_column(sa.DateTime(timezone=True))
     created_at: Mapped[datetime] = mapped_column(sa.DateTime(timezone=True), server_default=sa.text("now()"))
     updated_at: Mapped[datetime] = mapped_column(
         sa.DateTime(timezone=True), server_default=sa.text("now()"), onupdate=sa.func.now()
diff --git a/backend/app/services/auth_service.py b/backend/app/services/auth_service.py
index cc72086b50ebd5497e7cdada96a60506fa7d9c05..6b57ee07cdff8f392a533172f8e7507a3e131cc4
--- a/backend/app/services/auth_service.py
+++ b/backend/app/services/auth_service.py
@@ -52,6 +52,7 @@
         email_verified=email_verified,
         credits_balance=SIGNUP_BONUS_CREDITS,
         signup_bonus_granted_at=datetime.utcnow(),
+        monthly_credits_granted_at=datetime.utcnow(),
     )
     db.add(user)
 
@@ -179,4 +180,3 @@
     await db.delete(vt)
     await db.commit()
     return vt
-
diff --git a/backend/app/services/credit_service.py b/backend/app/services/credit_service.py
index d89772b0418d1ebe1a79bba3de65f0112a550adb..55fa0e1abd98fa8c3f32c2aa71826235df6a9fc3
--- a/backend/app/services/credit_service.py
+++ b/backend/app/services/credit_service.py
@@ -7,6 +7,7 @@
 from sqlalchemy.ext.asyncio import AsyncSession
 
 from app.models.tables import CreditLedger, UsageRecord, User
+from app.core.config import settings
 
 
 # Token-to-credit rates by model tier
@@ -144,3 +145,59 @@
     db.add(usage)
     return usage
 
+
+async def ensure_monthly_credits(db: AsyncSession, user: User) -> None:
+    """Grant monthly credits if last grant was over 30 days ago.
+
+    Idempotency: checks CreditLedger for any recent 'monthly_allowance' within 30 days.
+    """
+    from datetime import datetime, timedelta, timezone
+
+    # Determine if grant needed based on timestamp
+    now = datetime.now(timezone.utc)
+    last = user.monthly_credits_granted_at
+    if last is not None and last.tzinfo is None:
+        # Treat naive as UTC
+        last = last.replace(tzinfo=timezone.utc)
+    needs_grant = last is None or (now - last) >= timedelta(days=30)
+    if not needs_grant:
+        return
+
+    # Check ledger for idempotency within last 30 days
+    cutoff = now - timedelta(days=30)
+    existing = await db.scalar(
+        sa.select(CreditLedger)
+        .where(CreditLedger.user_id == user.id)
+        .where(CreditLedger.reason == "monthly_allowance")
+        .where(CreditLedger.created_at >= cutoff)
+    )
+    if existing:
+        # Still update marker to avoid repeatedly checking in future requests
+        user.monthly_credits_granted_at = now
+        await db.flush()
+        return
+
+    # Determine allowance by plan
+    plan = (user.plan or "free").lower()
+    if plan == "pro":
+        allowance = int(settings.PLAN_PRO_MONTHLY_CREDITS or 0)
+    else:
+        allowance = int(settings.PLAN_FREE_MONTHLY_CREDITS or 0)
+
+    if allowance <= 0:
+        # Nothing to grant
+        user.monthly_credits_granted_at = now
+        await db.flush()
+        return
+
+    # Grant credits and update marker
+    await credit_credits(
+        db,
+        user_id=user.id,
+        amount=allowance,
+        reason="monthly_allowance",
+        ref_type=None,
+        ref_id=None,
+    )
+    user.monthly_credits_granted_at = now
+    await db.flush()






thinking
**Following formatting guidelines**

I need to ensure I adhere to the final answer formatting guidelines, which means using bullet points and including file references with clickable paths and optional line numbers. It’s essential to add the relevant file path and line references individually while also keeping everything concise. This will help provide clear and structured information for the user, making it easier for them to follow along. Keeping things organized is so important!
thinking
**Compiling final message**

I’m putting together the final message to summarize the tasks completed. Phase 1 and 2 are finished. For A1, I added a migration file with an ID, using `op.add_column` with server defaults. In A2, I updated the User model in 'tables.py'. A3 involved adding subscription config constants.  

B1 focused on the `ensure_monthly_credits` function, while B2 integrated it into the chat endpoint. I've also created new endpoints: /subscribe and /portal, which require authentication. The webhook has been extended to manage various subscription events.  

Should I run the alembic migration or any additional tests?
thinking
**Structuring the final message**

I need to keep the message concise, ideally under 10 lines. The final guidelines emphasize brevity, but I can be slightly more descriptive for multi-section changes. I'll organize a structured summary using bullet lists under sections without making it too long.

I'll create sections such as Migrations, Models & Config, Credits, Chat, Billing API, Auth, and Notes/Next steps.  

For file references, I’ll include the migration file path and any relevant lines from updated files without needing extensive detail.  

It’s important to maintain clarity while ensuring we stay focused on key points!
thinking
**Final response preparation**

I need to provide paths with approximate line numbers for updates. I noted the plan field at `backend/app/models/tables.py:166`, which is good. 

For the config file, I should reference `backend/app/core/config.py`, likely around lines 79 to 81, and keep it minimal.  

The `ensure_monthly_credits` function is in `backend/app/services/credit_service.py` at line 149.  

For chat changes, I’ll mention `backend/app/api/chat.py`, lines 136-139, and the new billing API endpoints in `backend/app/api/billing.py` at lines 62 and 88.  

The auth service update is in `backend/app/services/auth_service.py`, line 55. I’ll format these in a "file:line" style.  

While I didn't use the `update_plan` tool, I think we'll skip it for brevity since it's optional!
thinking
**Final checks and message**

I’m doing one last check on the chat function import style to see if it might overshadow the `credit_service` import for `ensure_monthly_credits`, which seems good. 

I noted that the 'subscribe' endpoint uses `db.commit()` after setting the Stripe customer ID, but we didn’t commit for plan changes in the webhook before applying credits. We did commit after credits, which is fine.  

Now, I need to ensure that no unrelated code or files were modified. Everything looks good to deliver the final message!
codex
I’ve reviewed the backend and implemented the requested subscription features and monthly credit logic. Here’s what changed.

**Migrations**
- Added migration adding user subscription fields: `backend/alembic/versions/20260206_0004_add_subscription_fields.py`
  - Adds `plan`, `stripe_customer_id`, `stripe_subscription_id`, `monthly_credits_granted_at`
  - Proper downgrade drops these columns

**Models & Config**
- User fields added: `backend/app/models/tables.py:166`
  - `plan`, `stripe_customer_id`, `stripe_subscription_id`, `monthly_credits_granted_at`
- Subscription settings added: `backend/app/core/config.py:79`
  - `PLAN_FREE_MONTHLY_CREDITS=10000`, `PLAN_PRO_MONTHLY_CREDITS=100000`, `STRIPE_PRICE_PRO_MONTHLY=''`

**Credits**
- Monthly grant function: `backend/app/services/credit_service.py:149`
  - `ensure_monthly_credits(db, user)` checks 30-day window, uses plan to decide allowance, ensures idempotency (no `monthly_allowance` ledger in last 30 days), calls `credit_credits`, updates `user.monthly_credits_granted_at`
  - Handles naive vs timezone-aware timestamps safely

**Chat**
- Monthly credits ensured before balance check: `backend/app/api/chat.py:136`
  - In `chat_stream`, after session verification and before credit check:
    - Imports and calls `ensure_monthly_credits(db, user)` then commits

**Billing API**
- Subscribe (Stripe Checkout subscription): `backend/app/api/billing.py:62`
  - `POST /api/billing/subscribe` (auth required)
  - Creates Stripe Customer if missing and persists `stripe_customer_id` (commits)
  - Creates Checkout Session with `mode='subscription'`, `price=settings.STRIPE_PRICE_PRO_MONTHLY`
  - Returns `checkout_url`
- Customer portal: `backend/app/api/billing.py:88`
  - `POST /api/billing/portal` (auth required)
  - Requires `stripe_customer_id`, returns `portal_url`
- Webhook extended: `backend/app/api/billing.py:120`
  - `checkout.session.completed`
    - If `mode=='subscription'`: set `user.plan='pro'`, store `stripe_subscription_id`, persist `stripe_customer_id` if present, grant 100k credits with idempotency via `ref_type='stripe_subscription'` and `ref_id=subscription`
    - If `mode=='payment'`: keeps existing pack-purchase behavior
  - `invoice.payment_succeeded`: grants 100k credits with idempotency via `ref_type='stripe_invoice'` and `ref_id=invoice.id`
  - `customer.subscription.deleted`: sets `user.plan='free'`, clears `stripe_subscription_id`

**Auth**
- Set initial monthly grant timestamp on user creation: `backend/app/services/auth_service.py:55`
  - `monthly_credits_granted_at=datetime.utcnow()`

Notes
- ensure_monthly_credits uses timezone-aware now; it normalizes stored naive timestamps to avoid comparison errors.
- Let me know if you want me to run Alembic migrations locally or adjust Stripe price/envs in `.env`.
file update:
diff --git a/backend/alembic/versions/20260206_0004_add_subscription_fields.py b/backend/alembic/versions/20260206_0004_add_subscription_fields.py
new file mode 100644
index 0000000000000000000000000000000000000000..f84be09226785ea3dbc1b413b3cfd2cb07dff81e
--- /dev/null
+++ b/backend/alembic/versions/20260206_0004_add_subscription_fields.py
@@ -0,0 +1,38 @@
+"""add subscription fields to users
+
+Revision ID: d4e5f6a7b8c9
+Revises: c3d4e5f6a7b8
+Create Date: 2026-02-06 00:40:00
+
+"""
+from __future__ import annotations
+
+from alembic import op
+import sqlalchemy as sa
+
+
+# revision identifiers, used by Alembic.
+revision = "d4e5f6a7b8c9"
+down_revision = "c3d4e5f6a7b8"
+branch_labels = None
+depends_on = None
+
+
+def upgrade() -> None:
+    # Add subscription-related columns to users
+    op.add_column(
+        "users",
+        sa.Column("plan", sa.String(length=20), nullable=False, server_default=sa.text("'free'")),
+    )
+    op.add_column("users", sa.Column("stripe_customer_id", sa.String(length=255), nullable=True))
+    op.add_column("users", sa.Column("stripe_subscription_id", sa.String(length=255), nullable=True))
+    op.add_column("users", sa.Column("monthly_credits_granted_at", sa.DateTime(timezone=True), nullable=True))
+
+
+def downgrade() -> None:
+    # Drop subscription-related columns from users
+    op.drop_column("users", "monthly_credits_granted_at")
+    op.drop_column("users", "stripe_subscription_id")
+    op.drop_column("users", "stripe_customer_id")
+    op.drop_column("users", "plan")
+
diff --git a/backend/app/api/billing.py b/backend/app/api/billing.py
index 851620df69f9c62fb3cab15feeedcafff44cc6bb..f99355cf848497a82c150ed57c5c5b2c20aa5e2e
--- a/backend/app/api/billing.py
+++ b/backend/app/api/billing.py
@@ -58,6 +58,47 @@
     return {"checkout_url": session.url}
 
 
+# Subscriptions
+@router.post("/subscribe")
+async def subscribe(
+    user: User = Depends(require_auth),
+    db: AsyncSession = Depends(get_db_session),
+):
+    if not settings.STRIPE_SECRET_KEY or not settings.STRIPE_PRICE_PRO_MONTHLY:
+        raise HTTPException(503, "Stripe not configured")
+
+    # Ensure customer exists
+    if not user.stripe_customer_id:
+        cust = stripe.Customer.create(email=user.email, name=user.name or None)
+        user.stripe_customer_id = cust.id
+        await db.commit()
+
+    # Create Checkout Session for subscription
+    session = stripe.checkout.Session.create(
+        mode="subscription",
+        line_items=[{"price": settings.STRIPE_PRICE_PRO_MONTHLY, "quantity": 1}],
+        success_url=f"{settings.FRONTEND_URL}/billing",
+        cancel_url=f"{settings.FRONTEND_URL}/billing",
+        customer=user.stripe_customer_id,
+        client_reference_id=str(user.id),
+    )
+    return {"checkout_url": session.url}
+
+
+@router.post("/portal")
+async def customer_portal(user: User = Depends(require_auth)):
+    if not settings.STRIPE_SECRET_KEY:
+        raise HTTPException(503, "Stripe not configured")
+    if not user.stripe_customer_id:
+        raise HTTPException(400, "No Stripe customer for user")
+
+    portal = stripe.billing_portal.Session.create(
+        customer=user.stripe_customer_id,
+        return_url=f"{settings.FRONTEND_URL}/billing",
+    )
+    return {"portal_url": portal.url}
+
+
 @router.post("/webhook")
 async def stripe_webhook(request: Request, db: AsyncSession = Depends(get_db_session)):
     payload = await request.body()
@@ -85,70 +126,196 @@
             logger.error("Invalid event structure: missing data.object")
             return {"received": True}
 
-        # Parse and validate client_reference_id (user_id)
-        try:
-            client_ref = session.get("client_reference_id")
-            if not client_ref:
-                logger.error("Missing client_reference_id in checkout session")
+        mode = session.get("mode")
+
+        # Handle subscription checkout
+        if mode == "subscription":
+            try:
+                client_ref = session.get("client_reference_id")
+                if not client_ref:
+                    logger.error("Missing client_reference_id in subscription session")
+                    return {"received": True}
+                user_id = uuid.UUID(client_ref)
+            except (ValueError, TypeError) as e:
+                logger.error("Invalid client_reference_id: %s", e)
+                return {"received": True}
+
+            user = await db.get(User, user_id)
+            if not user:
+                logger.warning("Subscription completed for non-existent user %s", user_id)
                 return {"received": True}
-            user_id = uuid.UUID(client_ref)
-        except (ValueError, TypeError) as e:
-            logger.error("Invalid client_reference_id: %s", e)
+
+            subscription_id = session.get("subscription")
+            customer_id = session.get("customer")
+
+            # Update user plan and subscription/customer ids
+            user.plan = "pro"
+            if subscription_id:
+                user.stripe_subscription_id = subscription_id
+            if customer_id and not user.stripe_customer_id:
+                user.stripe_customer_id = customer_id
+
+            # Idempotency: only one monthly grant per subscription id at start
+            existing = await db.scalar(
+                select(CreditLedger).where(
+                    CreditLedger.ref_type == "stripe_subscription",
+                    CreditLedger.ref_id == (subscription_id or ""),
+                )
+            )
+
+            if not existing:
+                try:
+                    await credit_credits(
+                        db,
+                        user_id=user.id,
+                        amount=int(settings.PLAN_PRO_MONTHLY_CREDITS or 0),
+                        reason="monthly_allowance",
+                        ref_type="stripe_subscription",
+                        ref_id=subscription_id or "",
+                    )
+                    await db.commit()
+                    logger.info(
+                        "Subscription start credits granted: user_id=%s, subscription=%s",
+                        user.id,
+                        subscription_id,
+                    )
+                except Exception as e:
+                    await db.rollback()
+                    logger.error("Failed to grant subscription start credits: %s", e)
+                    raise HTTPException(500, "Database error")
+            else:
+                await db.commit()
+
             return {"received": True}
 
-        # Parse and validate credits amount
-        try:
-            metadata = session.get("metadata", {})
-            credits_str = metadata.get("credits")
-            if not credits_str:
-                logger.error("Missing credits in session metadata")
+        # Handle one-time credit pack checkout
+        if mode == "payment":
+            # Parse and validate client_reference_id (user_id)
+            try:
+                client_ref = session.get("client_reference_id")
+                if not client_ref:
+                    logger.error("Missing client_reference_id in checkout session")
+                    return {"received": True}
+                user_id = uuid.UUID(client_ref)
+            except (ValueError, TypeError) as e:
+                logger.error("Invalid client_reference_id: %s", e)
                 return {"received": True}
-            credits = int(credits_str)
-            if credits <= 0:
-                logger.error("Invalid credits amount: %d", credits)
+
+            # Parse and validate credits amount
+            try:
+                metadata = session.get("metadata", {})
+                credits_str = metadata.get("credits")
+                if not credits_str:
+                    logger.error("Missing credits in session metadata")
+                    return {"received": True}
+                credits = int(credits_str)
+                if credits <= 0:
+                    logger.error("Invalid credits amount: %d", credits)
+                    return {"received": True}
+            except (ValueError, TypeError) as e:
+                logger.error("Cannot parse credits from metadata: %s", e)
+                return {"received": True}
+
+            # Get payment_intent for idempotency
+            payment_intent = session.get("payment_intent")
+            if not payment_intent:
+                logger.warning("Checkout session has no payment_intent, skipping for safety")
                 return {"received": True}
-        except (ValueError, TypeError) as e:
-            logger.error("Cannot parse credits from metadata: %s", e)
+
+            # Verify user exists
+            user = await db.get(User, user_id)
+            if not user:
+                logger.warning("Webhook for non-existent user %s", user_id)
+                return {"received": True}
+
+            # Idempotency check
+            existing = await db.scalar(
+                select(CreditLedger).where(
+                    CreditLedger.ref_type == "stripe_payment",
+                    CreditLedger.ref_id == payment_intent,
+                )
+            )
+
+            if not existing:
+                try:
+                    await credit_credits(
+                        db,
+                        user_id,
+                        credits,
+                        reason="purchase",
+                        ref_type="stripe_payment",
+                        ref_id=payment_intent,
+                    )
+                    await db.commit()
+                    logger.info(
+                        "Credits granted: user_id=%s, credits=%d, payment_intent=%s",
+                        user_id,
+                        credits,
+                        payment_intent,
+                    )
+                except Exception as e:
+                    await db.rollback()
+                    logger.error("Failed to grant credits: %s", e)
+                    # Return 5xx so Stripe retries
+                    raise HTTPException(500, "Database error")
+            return {"received": True}
+
+    elif event["type"] == "invoice.payment_succeeded":
+    
+        obj = event.get("data", {}).get("object")
+        if not obj or not isinstance(obj, dict):
             return {"received": True}
 
-        # Get payment_intent for idempotency
-        payment_intent = session.get("payment_intent")
-        if not payment_intent:
-            logger.warning("Checkout session has no payment_intent, skipping for safety")
+        invoice_id = obj.get("id")
+        customer_id = obj.get("customer")
+        if not invoice_id or not customer_id:
             return {"received": True}
 
-        # Verify user exists
-        user = await db.get(User, user_id)
+        # Find user by customer id
+        user = await db.scalar(select(User).where(User.stripe_customer_id == customer_id))
         if not user:
-            logger.warning("Webhook for non-existent user %s", user_id)
             return {"received": True}
 
-        # Idempotency check
+        # Idempotency: ensure we haven't granted for this invoice
         existing = await db.scalar(
             select(CreditLedger).where(
-                CreditLedger.ref_type == "stripe_payment",
-                CreditLedger.ref_id == payment_intent,
+                CreditLedger.ref_type == "stripe_invoice",
+                CreditLedger.ref_id == invoice_id,
             )
         )
-
         if not existing:
             try:
                 await credit_credits(
                     db,
-                    user_id,
-                    credits,
-                    reason="purchase",
-                    ref_type="stripe_payment",
-                    ref_id=payment_intent,
+                    user_id=user.id,
+                    amount=int(settings.PLAN_PRO_MONTHLY_CREDITS or 0),
+                    reason="monthly_allowance",
+                    ref_type="stripe_invoice",
+                    ref_id=invoice_id,
                 )
                 await db.commit()
-                logger.info("Credits granted: user_id=%s, credits=%d, payment_intent=%s",
-                           user_id, credits, payment_intent)
             except Exception as e:
                 await db.rollback()
-                logger.error("Failed to grant credits: %s", e)
-                # Return 5xx so Stripe retries
+                logger.error("Failed to grant monthly credits on invoice: %s", e)
                 raise HTTPException(500, "Database error")
+        return {"received": True}
+
+    elif event["type"] == "customer.subscription.deleted":
+        obj = event.get("data", {}).get("object")
+        if not obj or not isinstance(obj, dict):
+            return {"received": True}
 
-    return {"received": True}
+        customer_id = obj.get("customer")
+        if not customer_id:
+            return {"received": True}
 
+        user = await db.scalar(select(User).where(User.stripe_customer_id == customer_id))
+        if not user:
+            return {"received": True}
+
+        user.plan = "free"
+        user.stripe_subscription_id = None
+        await db.commit()
+        return {"received": True}
+
+    return {"received": True}
diff --git a/backend/app/api/chat.py b/backend/app/api/chat.py
index 71fc751fa90239dfe90bf76e3b30a7aa686d0c3f..d52dc47026e109df283984196581d417a4fea1dc
--- a/backend/app/api/chat.py
+++ b/backend/app/api/chat.py
@@ -133,6 +133,9 @@
 
     # If authenticated, ensure sufficient credits before opening stream
     if user is not None:
+        from app.services.credit_service import ensure_monthly_credits
+        await ensure_monthly_credits(db, user)
+        await db.commit()
         balance = await credit_service.get_user_credits(db, user.id)
         if balance < credit_service.MIN_CREDITS_FOR_CHAT:
             return JSONResponse(
diff --git a/backend/app/core/config.py b/backend/app/core/config.py
index 830f599a7b1ff02463684a9e84e90adfd6318cc1..a8eef6c5b4145c3710d46395bf26465dec42b4a7
--- a/backend/app/core/config.py
+++ b/backend/app/core/config.py
@@ -75,6 +75,10 @@
     CREDITS_PRO: int = 200000
     CREDITS_ENTERPRISE: int = 1000000
     SIGNUP_BONUS_CREDITS: int = 10000
+    # Subscription tiers
+    PLAN_FREE_MONTHLY_CREDITS: int = 10000
+    PLAN_PRO_MONTHLY_CREDITS: int = 100000
+    STRIPE_PRICE_PRO_MONTHLY: str = ''
 
     model_config = SettingsConfigDict(env_file=".env", env_file_encoding="utf-8", case_sensitive=False)
 
diff --git a/backend/app/models/tables.py b/backend/app/models/tables.py
index 2eb9239abb3f01f8a4103944db02efcb27f20149..9caeafd2d73fb05604695d962f9a0dc191da0bf2
--- a/backend/app/models/tables.py
+++ b/backend/app/models/tables.py
@@ -163,6 +163,10 @@
     email_verified: Mapped[Optional[datetime]] = mapped_column(sa.DateTime(timezone=True))
     credits_balance: Mapped[int] = mapped_column(sa.Integer, nullable=False, server_default=sa.text("0"))
     signup_bonus_granted_at: Mapped[Optional[datetime]] = mapped_column(sa.DateTime(timezone=True))
+    plan: Mapped[str] = mapped_column(sa.String(20), nullable=False, server_default=sa.text("'free'"))
+    stripe_customer_id: Mapped[Optional[str]] = mapped_column(sa.String(255))
+    stripe_subscription_id: Mapped[Optional[str]] = mapped_column(sa.String(255))
+    monthly_credits_granted_at: Mapped[Optional[datetime]] = mapped_column(sa.DateTime(timezone=True))
     created_at: Mapped[datetime] = mapped_column(sa.DateTime(timezone=True), server_default=sa.text("now()"))
     updated_at: Mapped[datetime] = mapped_column(
         sa.DateTime(timezone=True), server_default=sa.text("now()"), onupdate=sa.func.now()
diff --git a/backend/app/services/auth_service.py b/backend/app/services/auth_service.py
index cc72086b50ebd5497e7cdada96a60506fa7d9c05..6b57ee07cdff8f392a533172f8e7507a3e131cc4
--- a/backend/app/services/auth_service.py
+++ b/backend/app/services/auth_service.py
@@ -52,6 +52,7 @@
         email_verified=email_verified,
         credits_balance=SIGNUP_BONUS_CREDITS,
         signup_bonus_granted_at=datetime.utcnow(),
+        monthly_credits_granted_at=datetime.utcnow(),
     )
     db.add(user)
 
@@ -179,4 +180,3 @@
     await db.delete(vt)
     await db.commit()
     return vt
-
diff --git a/backend/app/services/credit_service.py b/backend/app/services/credit_service.py
index d89772b0418d1ebe1a79bba3de65f0112a550adb..55fa0e1abd98fa8c3f32c2aa71826235df6a9fc3
--- a/backend/app/services/credit_service.py
+++ b/backend/app/services/credit_service.py
@@ -7,6 +7,7 @@
 from sqlalchemy.ext.asyncio import AsyncSession
 
 from app.models.tables import CreditLedger, UsageRecord, User
+from app.core.config import settings
 
 
 # Token-to-credit rates by model tier
@@ -144,3 +145,59 @@
     db.add(usage)
     return usage
 
+
+async def ensure_monthly_credits(db: AsyncSession, user: User) -> None:
+    """Grant monthly credits if last grant was over 30 days ago.
+
+    Idempotency: checks CreditLedger for any recent 'monthly_allowance' within 30 days.
+    """
+    from datetime import datetime, timedelta, timezone
+
+    # Determine if grant needed based on timestamp
+    now = datetime.now(timezone.utc)
+    last = user.monthly_credits_granted_at
+    if last is not None and last.tzinfo is None:
+        # Treat naive as UTC
+        last = last.replace(tzinfo=timezone.utc)
+    needs_grant = last is None or (now - last) >= timedelta(days=30)
+    if not needs_grant:
+        return
+
+    # Check ledger for idempotency within last 30 days
+    cutoff = now - timedelta(days=30)
+    existing = await db.scalar(
+        sa.select(CreditLedger)
+        .where(CreditLedger.user_id == user.id)
+        .where(CreditLedger.reason == "monthly_allowance")
+        .where(CreditLedger.created_at >= cutoff)
+    )
+    if existing:
+        # Still update marker to avoid repeatedly checking in future requests
+        user.monthly_credits_granted_at = now
+        await db.flush()
+        return
+
+    # Determine allowance by plan
+    plan = (user.plan or "free").lower()
+    if plan == "pro":
+        allowance = int(settings.PLAN_PRO_MONTHLY_CREDITS or 0)
+    else:
+        allowance = int(settings.PLAN_FREE_MONTHLY_CREDITS or 0)
+
+    if allowance <= 0:
+        # Nothing to grant
+        user.monthly_credits_granted_at = now
+        await db.flush()
+        return
+
+    # Grant credits and update marker
+    await credit_credits(
+        db,
+        user_id=user.id,
+        amount=allowance,
+        reason="monthly_allowance",
+        ref_type=None,
+        ref_id=None,
+    )
+    user.monthly_credits_granted_at = now
+    await db.flush()

tokens used
194,467
I’ve reviewed the backend and implemented the requested subscription features and monthly credit logic. Here’s what changed.

**Migrations**
- Added migration adding user subscription fields: `backend/alembic/versions/20260206_0004_add_subscription_fields.py`
  - Adds `plan`, `stripe_customer_id`, `stripe_subscription_id`, `monthly_credits_granted_at`
  - Proper downgrade drops these columns

**Models & Config**
- User fields added: `backend/app/models/tables.py:166`
  - `plan`, `stripe_customer_id`, `stripe_subscription_id`, `monthly_credits_granted_at`
- Subscription settings added: `backend/app/core/config.py:79`
  - `PLAN_FREE_MONTHLY_CREDITS=10000`, `PLAN_PRO_MONTHLY_CREDITS=100000`, `STRIPE_PRICE_PRO_MONTHLY=''`

**Credits**
- Monthly grant function: `backend/app/services/credit_service.py:149`
  - `ensure_monthly_credits(db, user)` checks 30-day window, uses plan to decide allowance, ensures idempotency (no `monthly_allowance` ledger in last 30 days), calls `credit_credits`, updates `user.monthly_credits_granted_at`
  - Handles naive vs timezone-aware timestamps safely

**Chat**
- Monthly credits ensured before balance check: `backend/app/api/chat.py:136`
  - In `chat_stream`, after session verification and before credit check:
    - Imports and calls `ensure_monthly_credits(db, user)` then commits

**Billing API**
- Subscribe (Stripe Checkout subscription): `backend/app/api/billing.py:62`
  - `POST /api/billing/subscribe` (auth required)
  - Creates Stripe Customer if missing and persists `stripe_customer_id` (commits)
  - Creates Checkout Session with `mode='subscription'`, `price=settings.STRIPE_PRICE_PRO_MONTHLY`
  - Returns `checkout_url`
- Customer portal: `backend/app/api/billing.py:88`
  - `POST /api/billing/portal` (auth required)
  - Requires `stripe_customer_id`, returns `portal_url`
- Webhook extended: `backend/app/api/billing.py:120`
  - `checkout.session.completed`
    - If `mode=='subscription'`: set `user.plan='pro'`, store `stripe_subscription_id`, persist `stripe_customer_id` if present, grant 100k credits with idempotency via `ref_type='stripe_subscription'` and `ref_id=subscription`
    - If `mode=='payment'`: keeps existing pack-purchase behavior
  - `invoice.payment_succeeded`: grants 100k credits with idempotency via `ref_type='stripe_invoice'` and `ref_id=invoice.id`
  - `customer.subscription.deleted`: sets `user.plan='free'`, clears `stripe_subscription_id`

**Auth**
- Set initial monthly grant timestamp on user creation: `backend/app/services/auth_service.py:55`
  - `monthly_credits_granted_at=datetime.utcnow()`

Notes
- ensure_monthly_credits uses timezone-aware now; it normalizes stored naive timestamps to avoid comparison errors.
- Let me know if you want me to run Alembic migrations locally or adjust Stripe price/envs in `.env`.
